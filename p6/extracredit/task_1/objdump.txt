
p6:     file format elf32-i386


Disassembly of section .init:

080490c8 <_init>:
 80490c8:	53                   	push   %ebx
 80490c9:	83 ec 08             	sub    $0x8,%esp
 80490cc:	e8 9f 0a 00 00       	call   8049b70 <__x86.get_pc_thunk.bx>
 80490d1:	81 c3 5f 50 00 00    	add    $0x505f,%ebx
 80490d7:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 80490dd:	85 c0                	test   %eax,%eax
 80490df:	74 05                	je     80490e6 <_init+0x1e>
 80490e1:	e8 6a 00 00 00       	call   8049150 <__gmon_start__@plt>
 80490e6:	83 c4 08             	add    $0x8,%esp
 80490e9:	5b                   	pop    %ebx
 80490ea:	c3                   	ret    

Disassembly of section .plt:

080490f0 <_ZGTtdlPv@plt-0x10>:
 80490f0:	ff 35 34 e1 04 08    	pushl  0x804e134
 80490f6:	ff 25 38 e1 04 08    	jmp    *0x804e138
 80490fc:	00 00                	add    %al,(%eax)
	...

08049100 <_ZGTtdlPv@plt>:
 8049100:	ff 25 3c e1 04 08    	jmp    *0x804e13c
 8049106:	68 00 00 00 00       	push   $0x0
 804910b:	e9 e0 ff ff ff       	jmp    80490f0 <_init+0x28>

08049110 <__cxa_atexit@plt>:
 8049110:	ff 25 40 e1 04 08    	jmp    *0x804e140
 8049116:	68 08 00 00 00       	push   $0x8
 804911b:	e9 d0 ff ff ff       	jmp    80490f0 <_init+0x28>

08049120 <memcmp@plt>:
 8049120:	ff 25 44 e1 04 08    	jmp    *0x804e144
 8049126:	68 10 00 00 00       	push   $0x10
 804912b:	e9 c0 ff ff ff       	jmp    80490f0 <_init+0x28>

08049130 <_ZSt16__throw_bad_castv@plt>:
 8049130:	ff 25 48 e1 04 08    	jmp    *0x804e148
 8049136:	68 18 00 00 00       	push   $0x18
 804913b:	e9 b0 ff ff ff       	jmp    80490f0 <_init+0x28>

08049140 <signal@plt>:
 8049140:	ff 25 4c e1 04 08    	jmp    *0x804e14c
 8049146:	68 20 00 00 00       	push   $0x20
 804914b:	e9 a0 ff ff ff       	jmp    80490f0 <_init+0x28>

08049150 <__gmon_start__@plt>:
 8049150:	ff 25 50 e1 04 08    	jmp    *0x804e150
 8049156:	68 28 00 00 00       	push   $0x28
 804915b:	e9 90 ff ff ff       	jmp    80490f0 <_init+0x28>

08049160 <sched_yield@plt>:
 8049160:	ff 25 54 e1 04 08    	jmp    *0x804e154
 8049166:	68 30 00 00 00       	push   $0x30
 804916b:	e9 80 ff ff ff       	jmp    80490f0 <_init+0x28>

08049170 <_ZdlPv@plt>:
 8049170:	ff 25 58 e1 04 08    	jmp    *0x804e158
 8049176:	68 38 00 00 00       	push   $0x38
 804917b:	e9 70 ff ff ff       	jmp    80490f0 <_init+0x28>

08049180 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>:
 8049180:	ff 25 5c e1 04 08    	jmp    *0x804e15c
 8049186:	68 40 00 00 00       	push   $0x40
 804918b:	e9 60 ff ff ff       	jmp    80490f0 <_init+0x28>

08049190 <_ZSt11_Hash_bytesPKvjj@plt>:
 8049190:	ff 25 60 e1 04 08    	jmp    *0x804e160
 8049196:	68 48 00 00 00       	push   $0x48
 804919b:	e9 50 ff ff ff       	jmp    80490f0 <_init+0x28>

080491a0 <_ITM_commitTransaction@plt>:
 80491a0:	ff 25 64 e1 04 08    	jmp    *0x804e164
 80491a6:	68 50 00 00 00       	push   $0x50
 80491ab:	e9 40 ff ff ff       	jmp    80490f0 <_init+0x28>

080491b0 <__cxa_throw_bad_array_new_length@plt>:
 80491b0:	ff 25 68 e1 04 08    	jmp    *0x804e168
 80491b6:	68 58 00 00 00       	push   $0x58
 80491bb:	e9 30 ff ff ff       	jmp    80490f0 <_init+0x28>

080491c0 <_ZNSt8ios_base4InitC1Ev@plt>:
 80491c0:	ff 25 6c e1 04 08    	jmp    *0x804e16c
 80491c6:	68 60 00 00 00       	push   $0x60
 80491cb:	e9 20 ff ff ff       	jmp    80490f0 <_init+0x28>

080491d0 <_ZNSs4_Rep10_M_refdataEv@plt>:
 80491d0:	ff 25 70 e1 04 08    	jmp    *0x804e170
 80491d6:	68 68 00 00 00       	push   $0x68
 80491db:	e9 10 ff ff ff       	jmp    80490f0 <_init+0x28>

080491e0 <__libc_start_main@plt>:
 80491e0:	ff 25 74 e1 04 08    	jmp    *0x804e174
 80491e6:	68 70 00 00 00       	push   $0x70
 80491eb:	e9 00 ff ff ff       	jmp    80490f0 <_init+0x28>

080491f0 <_ZNSsC1ERKSs@plt>:
 80491f0:	ff 25 78 e1 04 08    	jmp    *0x804e178
 80491f6:	68 78 00 00 00       	push   $0x78
 80491fb:	e9 f0 fe ff ff       	jmp    80490f0 <_init+0x28>

08049200 <_ZNSt6thread15_M_start_threadESt10shared_ptrINS_10_Impl_baseEE@plt>:
 8049200:	ff 25 7c e1 04 08    	jmp    *0x804e17c
 8049206:	68 80 00 00 00       	push   $0x80
 804920b:	e9 e0 fe ff ff       	jmp    80490f0 <_init+0x28>

08049210 <__assert_fail@plt>:
 8049210:	ff 25 80 e1 04 08    	jmp    *0x804e180
 8049216:	68 88 00 00 00       	push   $0x88
 804921b:	e9 d0 fe ff ff       	jmp    80490f0 <_init+0x28>

08049220 <_ITM_commitTransactionEH@plt>:
 8049220:	ff 25 84 e1 04 08    	jmp    *0x804e184
 8049226:	68 90 00 00 00       	push   $0x90
 804922b:	e9 c0 fe ff ff       	jmp    80490f0 <_init+0x28>

08049230 <_ZNSt8ios_base4InitD1Ev@plt>:
 8049230:	ff 25 88 e1 04 08    	jmp    *0x804e188
 8049236:	68 98 00 00 00       	push   $0x98
 804923b:	e9 b0 fe ff ff       	jmp    80490f0 <_init+0x28>

08049240 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>:
 8049240:	ff 25 8c e1 04 08    	jmp    *0x804e18c
 8049246:	68 a0 00 00 00       	push   $0xa0
 804924b:	e9 a0 fe ff ff       	jmp    80490f0 <_init+0x28>

08049250 <strtol@plt>:
 8049250:	ff 25 90 e1 04 08    	jmp    *0x804e190
 8049256:	68 a8 00 00 00       	push   $0xa8
 804925b:	e9 90 fe ff ff       	jmp    80490f0 <_init+0x28>

08049260 <_ZNSsD1Ev@plt>:
 8049260:	ff 25 94 e1 04 08    	jmp    *0x804e194
 8049266:	68 b0 00 00 00       	push   $0xb0
 804926b:	e9 80 fe ff ff       	jmp    80490f0 <_init+0x28>

08049270 <_ZGTtnwj@plt>:
 8049270:	ff 25 98 e1 04 08    	jmp    *0x804e198
 8049276:	68 b8 00 00 00       	push   $0xb8
 804927b:	e9 70 fe ff ff       	jmp    80490f0 <_init+0x28>

08049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>:
 8049280:	ff 25 9c e1 04 08    	jmp    *0x804e19c
 8049286:	68 c0 00 00 00       	push   $0xc0
 804928b:	e9 60 fe ff ff       	jmp    80490f0 <_init+0x28>

08049290 <_ZGTtnaj@plt>:
 8049290:	ff 25 a0 e1 04 08    	jmp    *0x804e1a0
 8049296:	68 c8 00 00 00       	push   $0xc8
 804929b:	e9 50 fe ff ff       	jmp    80490f0 <_init+0x28>

080492a0 <getopt@plt>:
 80492a0:	ff 25 a4 e1 04 08    	jmp    *0x804e1a4
 80492a6:	68 d0 00 00 00       	push   $0xd0
 80492ab:	e9 40 fe ff ff       	jmp    80490f0 <_init+0x28>

080492b0 <_ITM_beginTransaction@plt>:
 80492b0:	ff 25 a8 e1 04 08    	jmp    *0x804e1a8
 80492b6:	68 d8 00 00 00       	push   $0xd8
 80492bb:	e9 30 fe ff ff       	jmp    80490f0 <_init+0x28>

080492c0 <alarm@plt>:
 80492c0:	ff 25 ac e1 04 08    	jmp    *0x804e1ac
 80492c6:	68 e0 00 00 00       	push   $0xe0
 80492cb:	e9 20 fe ff ff       	jmp    80490f0 <_init+0x28>

080492d0 <_ITM_WU4@plt>:
 80492d0:	ff 25 b0 e1 04 08    	jmp    *0x804e1b0
 80492d6:	68 e8 00 00 00       	push   $0xe8
 80492db:	e9 10 fe ff ff       	jmp    80490f0 <_init+0x28>

080492e0 <_ZNSt6thread4joinEv@plt>:
 80492e0:	ff 25 b4 e1 04 08    	jmp    *0x804e1b4
 80492e6:	68 f0 00 00 00       	push   $0xf0
 80492eb:	e9 00 fe ff ff       	jmp    80490f0 <_init+0x28>

080492f0 <_ZSt9terminatev@plt>:
 80492f0:	ff 25 b8 e1 04 08    	jmp    *0x804e1b8
 80492f6:	68 f8 00 00 00       	push   $0xf8
 80492fb:	e9 f0 fd ff ff       	jmp    80490f0 <_init+0x28>

08049300 <rand_r@plt>:
 8049300:	ff 25 bc e1 04 08    	jmp    *0x804e1bc
 8049306:	68 00 01 00 00       	push   $0x100
 804930b:	e9 e0 fd ff ff       	jmp    80490f0 <_init+0x28>

08049310 <_ITM_deregisterTMCloneTable@plt>:
 8049310:	ff 25 c0 e1 04 08    	jmp    *0x804e1c0
 8049316:	68 08 01 00 00       	push   $0x108
 804931b:	e9 d0 fd ff ff       	jmp    80490f0 <_init+0x28>

08049320 <__cxa_pure_virtual@plt>:
 8049320:	ff 25 c4 e1 04 08    	jmp    *0x804e1c4
 8049326:	68 10 01 00 00       	push   $0x110
 804932b:	e9 c0 fd ff ff       	jmp    80490f0 <_init+0x28>

08049330 <_ZNSs10_S_compareEjj@plt>:
 8049330:	ff 25 c8 e1 04 08    	jmp    *0x804e1c8
 8049336:	68 18 01 00 00       	push   $0x118
 804933b:	e9 b0 fd ff ff       	jmp    80490f0 <_init+0x28>

08049340 <_Znwj@plt>:
 8049340:	ff 25 cc e1 04 08    	jmp    *0x804e1cc
 8049346:	68 20 01 00 00       	push   $0x120
 804934b:	e9 a0 fd ff ff       	jmp    80490f0 <_init+0x28>

08049350 <clock_gettime@plt>:
 8049350:	ff 25 d0 e1 04 08    	jmp    *0x804e1d0
 8049356:	68 28 01 00 00       	push   $0x128
 804935b:	e9 90 fd ff ff       	jmp    80490f0 <_init+0x28>

08049360 <_ZNSo9_M_insertIyEERSoT_@plt>:
 8049360:	ff 25 d4 e1 04 08    	jmp    *0x804e1d4
 8049366:	68 30 01 00 00       	push   $0x130
 804936b:	e9 80 fd ff ff       	jmp    80490f0 <_init+0x28>

08049370 <_Znaj@plt>:
 8049370:	ff 25 d8 e1 04 08    	jmp    *0x804e1d8
 8049376:	68 38 01 00 00       	push   $0x138
 804937b:	e9 70 fd ff ff       	jmp    80490f0 <_init+0x28>

08049380 <_ZNSo5flushEv@plt>:
 8049380:	ff 25 dc e1 04 08    	jmp    *0x804e1dc
 8049386:	68 40 01 00 00       	push   $0x140
 804938b:	e9 60 fd ff ff       	jmp    80490f0 <_init+0x28>

08049390 <_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate@plt>:
 8049390:	ff 25 e0 e1 04 08    	jmp    *0x804e1e0
 8049396:	68 48 01 00 00       	push   $0x148
 804939b:	e9 50 fd ff ff       	jmp    80490f0 <_init+0x28>

080493a0 <_ZNSo9_M_insertImEERSoT_@plt>:
 80493a0:	ff 25 e4 e1 04 08    	jmp    *0x804e1e4
 80493a6:	68 50 01 00 00       	push   $0x150
 80493ab:	e9 40 fd ff ff       	jmp    80490f0 <_init+0x28>

080493b0 <_ZSt17__throw_bad_allocv@plt>:
 80493b0:	ff 25 e8 e1 04 08    	jmp    *0x804e1e8
 80493b6:	68 58 01 00 00       	push   $0x158
 80493bb:	e9 30 fd ff ff       	jmp    80490f0 <_init+0x28>

080493c0 <_ITM_changeTransactionMode@plt>:
 80493c0:	ff 25 ec e1 04 08    	jmp    *0x804e1ec
 80493c6:	68 60 01 00 00       	push   $0x160
 80493cb:	e9 20 fd ff ff       	jmp    80490f0 <_init+0x28>

080493d0 <__udivdi3@plt>:
 80493d0:	ff 25 f0 e1 04 08    	jmp    *0x804e1f0
 80493d6:	68 68 01 00 00       	push   $0x168
 80493db:	e9 10 fd ff ff       	jmp    80490f0 <_init+0x28>

080493e0 <_ITM_RU4@plt>:
 80493e0:	ff 25 f4 e1 04 08    	jmp    *0x804e1f4
 80493e6:	68 70 01 00 00       	push   $0x170
 80493eb:	e9 00 fd ff ff       	jmp    80490f0 <_init+0x28>

080493f0 <__pthread_key_create@plt>:
 80493f0:	ff 25 f8 e1 04 08    	jmp    *0x804e1f8
 80493f6:	68 78 01 00 00       	push   $0x178
 80493fb:	e9 f0 fc ff ff       	jmp    80490f0 <_init+0x28>

08049400 <__gxx_personality_v0@plt>:
 8049400:	ff 25 fc e1 04 08    	jmp    *0x804e1fc
 8049406:	68 80 01 00 00       	push   $0x180
 804940b:	e9 e0 fc ff ff       	jmp    80490f0 <_init+0x28>

08049410 <_ZNSs4_Rep12_S_empty_repEv@plt>:
 8049410:	ff 25 00 e2 04 08    	jmp    *0x804e200
 8049416:	68 88 01 00 00       	push   $0x188
 804941b:	e9 d0 fc ff ff       	jmp    80490f0 <_init+0x28>

08049420 <_ITM_registerTMCloneTable@plt>:
 8049420:	ff 25 04 e2 04 08    	jmp    *0x804e204
 8049426:	68 90 01 00 00       	push   $0x190
 804942b:	e9 c0 fc ff ff       	jmp    80490f0 <_init+0x28>

08049430 <_Unwind_Resume@plt>:
 8049430:	ff 25 08 e2 04 08    	jmp    *0x804e208
 8049436:	68 98 01 00 00       	push   $0x198
 804943b:	e9 b0 fc ff ff       	jmp    80490f0 <_init+0x28>

08049440 <_ZNSs12_S_empty_repEv@plt>:
 8049440:	ff 25 0c e2 04 08    	jmp    *0x804e20c
 8049446:	68 a0 01 00 00       	push   $0x1a0
 804944b:	e9 a0 fc ff ff       	jmp    80490f0 <_init+0x28>

08049450 <_ZNSo3putEc@plt>:
 8049450:	ff 25 10 e2 04 08    	jmp    *0x804e210
 8049456:	68 a8 01 00 00       	push   $0x1a8
 804945b:	e9 90 fc ff ff       	jmp    80490f0 <_init+0x28>

08049460 <exit@plt>:
 8049460:	ff 25 14 e2 04 08    	jmp    *0x804e214
 8049466:	68 b0 01 00 00       	push   $0x1b0
 804946b:	e9 80 fc ff ff       	jmp    80490f0 <_init+0x28>

08049470 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i@plt>:
 8049470:	ff 25 18 e2 04 08    	jmp    *0x804e218
 8049476:	68 b8 01 00 00       	push   $0x1b8
 804947b:	e9 70 fc ff ff       	jmp    80490f0 <_init+0x28>

08049480 <_ZNSs7reserveEj@plt>:
 8049480:	ff 25 1c e2 04 08    	jmp    *0x804e21c
 8049486:	68 c0 01 00 00       	push   $0x1c0
 804948b:	e9 60 fc ff ff       	jmp    80490f0 <_init+0x28>

Disassembly of section .text:

08049490 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc.part.5>:
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);

  // Partial specializations
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
 8049490:	53                   	push   %ebx
 8049491:	83 ec 18             	sub    $0x18,%esp
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
 8049494:	8b 10                	mov    (%eax),%edx
 8049496:	03 42 f4             	add    -0xc(%edx),%eax
 8049499:	89 c3                	mov    %eax,%ebx
       *
       *  See std::ios_base::iostate for the possible bit values.
      */
      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }
 804949b:	8b 40 14             	mov    0x14(%eax),%eax
 804949e:	e8 6d 09 00 00       	call   8049e10 <_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv.isra.1>
 80494a3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 80494aa:	00 
 80494ab:	89 04 24             	mov    %eax,(%esp)
 80494ae:	e8 9d 10 00 00       	call   804a550 <_ZStorSt12_Ios_IostateS_>
 80494b3:	89 1c 24             	mov    %ebx,(%esp)
 80494b6:	89 44 24 04          	mov    %eax,0x4(%esp)
 80494ba:	e8 d1 fe ff ff       	call   8049390 <_ZNSt9basic_iosIcSt11char_traitsIcEE5clearESt12_Ios_Iostate@plt>
      else
	__ostream_insert(__out, __s,
			 static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }
 80494bf:	83 c4 18             	add    $0x18,%esp
 80494c2:	5b                   	pop    %ebx
 80494c3:	c3                   	ret    

080494c4 <_ZL18__gthread_active_pv>:
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &GTHR_ACTIVE_PROXY;
  return __gthread_active_ptr != 0;
 80494c4:	b8 f0 93 04 08       	mov    $0x80493f0,%eax
 80494c9:	85 c0                	test   %eax,%eax
 80494cb:	0f 95 c0             	setne  %al
 80494ce:	0f b6 c0             	movzbl %al,%eax
}
 80494d1:	c3                   	ret    

080494d2 <_ZGTtN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.9>:
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
 80494d2:	53                   	push   %ebx
 80494d3:	89 c3                	mov    %eax,%ebx
 80494d5:	83 ec 08             	sub    $0x8,%esp
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 80494d8:	e8 e7 ff ff ff       	call   80494c4 <_ZL18__gthread_active_pv>
 80494dd:	85 c0                	test   %eax,%eax
 80494df:	74 10                	je     80494f1 <_ZGTtN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.9+0x1f>
 80494e1:	31 c0                	xor    %eax,%eax
 80494e3:	e8 d8 fe ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 80494e8:	83 c8 ff             	or     $0xffffffff,%eax
 80494eb:	f0 0f c1 03          	lock xadd %eax,(%ebx)
 80494ef:	eb 07                	jmp    80494f8 <_ZGTtN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.9+0x26>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 80494f1:	8b 03                	mov    (%ebx),%eax
    *__mem += __val;
 80494f3:	8d 50 ff             	lea    -0x1(%eax),%edx
 80494f6:	89 13                	mov    %edx,(%ebx)
    else
      return __exchange_and_add_single(__mem, __val);
#else
    return __exchange_and_add_single(__mem, __val);
#endif
  }
 80494f8:	83 c4 08             	add    $0x8,%esp
 80494fb:	5b                   	pop    %ebx
 80494fc:	c3                   	ret    

080494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>:
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
 80494fd:	53                   	push   %ebx
 80494fe:	89 c3                	mov    %eax,%ebx
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 8049500:	e8 bf ff ff ff       	call   80494c4 <_ZL18__gthread_active_pv>
 8049505:	85 c0                	test   %eax,%eax
 8049507:	74 09                	je     8049512 <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12+0x15>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 8049509:	83 c8 ff             	or     $0xffffffff,%eax
 804950c:	f0 0f c1 03          	lock xadd %eax,(%ebx)
 8049510:	eb 07                	jmp    8049519 <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12+0x1c>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 8049512:	8b 03                	mov    (%ebx),%eax
    *__mem += __val;
 8049514:	8d 50 ff             	lea    -0x1(%eax),%edx
 8049517:	89 13                	mov    %edx,(%ebx)
    else
      return __exchange_and_add_single(__mem, __val);
#else
    return __exchange_and_add_single(__mem, __val);
#endif
  }
 8049519:	5b                   	pop    %ebx
 804951a:	c3                   	ret    
 804951b:	66 90                	xchg   %ax,%ax
 804951d:	66 90                	xchg   %ax,%ax
 804951f:	90                   	nop

08049520 <main>:
 *  Main routine... it's a bit ugly to hide main() inside this function, but
 *  it means we could easily switch to a different data structure by
 *  replacing ListBench.cpp, and main() wouldn't change at all.
 */
int main(int argc, char** argv)
{
 8049520:	55                   	push   %ebp
 8049521:	89 e5                	mov    %esp,%ebp
 8049523:	57                   	push   %edi
 8049524:	56                   	push   %esi
 8049525:	53                   	push   %ebx
 8049526:	83 e4 f0             	and    $0xfffffff0,%esp
 8049529:	81 ec 50 04 00 00    	sub    $0x450,%esp
    // parse the command line
    parseargs(argc, argv);
 804952f:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049532:	8d 7c 24 50          	lea    0x50(%esp),%edi
 8049536:	89 44 24 04          	mov    %eax,0x4(%esp)
 804953a:	8b 45 08             	mov    0x8(%ebp),%eax
 804953d:	89 04 24             	mov    %eax,(%esp)
 8049540:	e8 cb 0b 00 00       	call   804a110 <_Z9parseargsiPPc>

    // initialize the benchmark
    bench_init();
 8049545:	e8 86 12 00 00       	call   804a7d0 <_Z10bench_initv>
 804954a:	31 c0                	xor    %eax,%eax
 804954c:	b9 00 01 00 00       	mov    $0x100,%ecx

    // for tracking our threads
    std::thread threads[256];

    // launch the threads
    for (uint32_t j = 1; j < Config::CFG.threads; j++)
 8049551:	83 3d c4 e4 04 08 01 	cmpl   $0x1,0x804e4c4
 8049558:	f3 ab                	rep stos %eax,%es:(%edi)
 804955a:	c7 44 24 30 01 00 00 	movl   $0x1,0x30(%esp)
 8049561:	00 
 8049562:	0f 86 e0 03 00 00    	jbe    8049948 <main+0x428>
 8049568:	8d 44 24 30          	lea    0x30(%esp),%eax
 804956c:	89 04 24             	mov    %eax,(%esp)
 804956f:	e8 0c 10 00 00       	call   804a580 <_ZSt7forwardIRjEOT_RNSt16remove_referenceIS1_E4typeE>
 8049574:	c7 04 24 60 9c 04 08 	movl   $0x8049c60,(%esp)
 804957b:	89 c6                	mov    %eax,%esi
 804957d:	e8 ee 0f 00 00       	call   804a570 <_ZSt7forwardIRFvjEEOT_RNSt16remove_referenceIS2_E4typeE>
 8049582:	89 c7                	mov    %eax,%edi
 8049584:	8d 44 24 48          	lea    0x48(%esp),%eax
 8049588:	89 04 24             	mov    %eax,(%esp)
 804958b:	e8 e0 10 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>
 8049590:	89 34 24             	mov    %esi,(%esp)
 8049593:	89 c3                	mov    %eax,%ebx
 8049595:	e8 e6 0f 00 00       	call   804a580 <_ZSt7forwardIRjEOT_RNSt16remove_referenceIS1_E4typeE>
 804959a:	89 3c 24             	mov    %edi,(%esp)
 804959d:	8d 7c 24 40          	lea    0x40(%esp),%edi
 80495a1:	89 c6                	mov    %eax,%esi
 80495a3:	e8 c8 0f 00 00       	call   804a570 <_ZSt7forwardIRFvjEEOT_RNSt16remove_referenceIS2_E4typeE>
 80495a8:	89 3c 24             	mov    %edi,(%esp)
 80495ab:	89 44 24 28          	mov    %eax,0x28(%esp)
 80495af:	e8 dc 10 00 00       	call   804a690 <_ZNSt26_Maybe_wrap_member_pointerIPFvjEE9__do_wrapEOS1_>
 80495b4:	89 34 24             	mov    %esi,(%esp)
 80495b7:	89 c7                	mov    %eax,%edi
 80495b9:	e8 c2 0f 00 00       	call   804a580 <_ZSt7forwardIRjEOT_RNSt16remove_referenceIS1_E4typeE>
 80495be:	89 3c 24             	mov    %edi,(%esp)
 80495c1:	89 c6                	mov    %eax,%esi
 80495c3:	e8 d8 10 00 00       	call   804a6a0 <_ZSt4moveIRPFvjEEONSt16remove_referenceIT_E4typeEOS4_>
 80495c8:	89 34 24             	mov    %esi,(%esp)
 80495cb:	89 c7                	mov    %eax,%edi
 80495cd:	e8 ae 0f 00 00       	call   804a580 <_ZSt7forwardIRjEOT_RNSt16remove_referenceIS1_E4typeE>
 80495d2:	89 3c 24             	mov    %edi,(%esp)
 80495d5:	89 c6                	mov    %eax,%esi
 80495d7:	e8 84 10 00 00       	call   804a660 <_ZSt7forwardIPFvjEEOT_RNSt16remove_referenceIS2_E4typeE>
 80495dc:	89 34 24             	mov    %esi,(%esp)
 80495df:	89 c7                	mov    %eax,%edi
 80495e1:	e8 9a 0f 00 00       	call   804a580 <_ZSt7forwardIRjEOT_RNSt16remove_referenceIS1_E4typeE>
 80495e6:	89 3c 24             	mov    %edi,(%esp)
 80495e9:	89 c6                	mov    %eax,%esi
 80495eb:	e8 70 10 00 00       	call   804a660 <_ZSt7forwardIPFvjEEOT_RNSt16remove_referenceIS2_E4typeE>
 80495f0:	89 04 24             	mov    %eax,(%esp)
 80495f3:	e8 68 10 00 00       	call   804a660 <_ZSt7forwardIPFvjEEOT_RNSt16remove_referenceIS2_E4typeE>
 80495f8:	89 34 24             	mov    %esi,(%esp)
 80495fb:	89 44 24 24          	mov    %eax,0x24(%esp)
 80495ff:	e8 7c 0f 00 00       	call   804a580 <_ZSt7forwardIRjEOT_RNSt16remove_referenceIS1_E4typeE>
 8049604:	89 04 24             	mov    %eax,(%esp)
 8049607:	e8 74 0f 00 00       	call   804a580 <_ZSt7forwardIRjEOT_RNSt16remove_referenceIS1_E4typeE>
 804960c:	89 1c 24             	mov    %ebx,(%esp)
 804960f:	89 c7                	mov    %eax,%edi
 8049611:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 8049615:	e8 56 10 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>
 804961a:	89 04 24             	mov    %eax,(%esp)
 804961d:	e8 4e 10 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>
 8049622:	89 04 24             	mov    %eax,(%esp)
 8049625:	e8 46 10 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>
 804962a:	89 04 24             	mov    %eax,(%esp)
 804962d:	e8 3e 10 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>
 8049632:	89 44 24 20          	mov    %eax,0x20(%esp)
 8049636:	e8 f5 07 00 00       	call   8049e30 <_ZNK9__gnu_cxx13new_allocatorISt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS9_ELNS_12_Lock_policyE2EEE8max_sizeEv.isra.10>
    {
      typedef _Bind_simple_helper<_Callable, _Args...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::__type __result_type;
      return __result_type(
          __maybe_type::__do_wrap( std::forward<_Callable>(__callable)),
 804963b:	8b 4c 24 28          	mov    0x28(%esp),%ecx

      template<typename _UHead, typename = typename
	       enable_if<!is_convertible<_UHead,
	                                 __uses_alloc_base>::value>::type>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 804963f:	8b 17                	mov    (%edi),%edx
    class id
    {
      native_handle_type	_M_thread;

    public:
      id() noexcept : _M_thread() { }
 8049641:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
 8049648:	00 
 8049649:	89 4c 24 40          	mov    %ecx,0x40(%esp)
 804964d:	8b 4c 24 24          	mov    0x24(%esp),%ecx
 8049651:	89 54 24 48          	mov    %edx,0x48(%esp)
      // NB: __n is permitted to be 0.  The C++ standard says nothing
      // about what the return value is when __n == 0.
      pointer
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
 8049655:	85 c0                	test   %eax,%eax
 8049657:	8b 11                	mov    (%ecx),%edx
      // This constructor is non-standard, it is used by allocate_shared.
      template<typename _Alloc, typename... _Args>
	__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
		     _Args&&... __args)
	: _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,
				std::forward<_Args>(__args)...)
 8049659:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
 8049660:	00 
	}

      template<typename _Tp, typename _Alloc, typename... _Args>
	__shared_count(_Sp_make_shared_tag, _Tp*, const _Alloc& __a,
		       _Args&&... __args)
	: _M_pi(0)
 8049661:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
 8049668:	00 
 8049669:	89 54 24 4c          	mov    %edx,0x4c(%esp)
 804966d:	0f 85 b2 00 00 00    	jne    8049725 <main+0x205>
 8049673:	e9 9d 03 00 00       	jmp    8049a15 <main+0x4f5>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 8049678:	8b 53 04             	mov    0x4(%ebx),%edx
    *__mem += __val;
 804967b:	8d 4a ff             	lea    -0x1(%edx),%ecx
      void
      _M_release() noexcept
      {
        // Be race-detector-friendly.  For more info see bits/c++config.
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
 804967e:	83 fa 01             	cmp    $0x1,%edx
 8049681:	89 4b 04             	mov    %ecx,0x4(%ebx)
 8049684:	0f 84 3e 02 00 00    	je     80498c8 <main+0x3a8>
        threads[j] = thread(run, j);
 804968a:	8b 5c 24 30          	mov    0x30(%esp),%ebx
 804968e:	8d 74 9c 50          	lea    0x50(%esp,%ebx,4),%esi
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_(pthread_equal) (__t1, __t2);
 8049692:	8b 06                	mov    (%esi),%eax
 8049694:	e8 a7 07 00 00       	call   8049e40 <pthread_equal.constprop.28>

    thread& operator=(const thread&) = delete;

    thread& operator=(thread&& __t) noexcept
    {
      if (joinable())
 8049699:	85 c0                	test   %eax,%eax
 804969b:	0f 84 6f 03 00 00    	je     8049a10 <main+0x4f0>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80496a1:	89 34 24             	mov    %esi,(%esp)
 80496a4:	e8 b7 0e 00 00       	call   804a560 <_ZSt4moveIRNSt6thread2idEEONSt16remove_referenceIT_E4typeEOS4_>
 80496a9:	8b 00                	mov    (%eax),%eax
 80496ab:	89 44 24 48          	mov    %eax,0x48(%esp)
      __a = _GLIBCXX_MOVE(__b);
 80496af:	8d 44 24 34          	lea    0x34(%esp),%eax
 80496b3:	89 04 24             	mov    %eax,(%esp)
 80496b6:	e8 a5 0e 00 00       	call   804a560 <_ZSt4moveIRNSt6thread2idEEONSt16remove_referenceIT_E4typeEOS4_>
 80496bb:	8b 00                	mov    (%eax),%eax
 80496bd:	89 06                	mov    %eax,(%esi)
      __b = _GLIBCXX_MOVE(__tmp);
 80496bf:	8d 44 24 48          	lea    0x48(%esp),%eax
 80496c3:	89 04 24             	mov    %eax,(%esp)
 80496c6:	e8 95 0e 00 00       	call   804a560 <_ZSt4moveIRNSt6thread2idEEONSt16remove_referenceIT_E4typeEOS4_>
 80496cb:	8b 00                	mov    (%eax),%eax
 80496cd:	89 44 24 34          	mov    %eax,0x34(%esp)
 80496d1:	e8 6a 07 00 00       	call   8049e40 <pthread_equal.constprop.28>
                std::forward<_Args>(__args)...)));
      }

    ~thread()
    {
      if (joinable())
 80496d6:	85 c0                	test   %eax,%eax
 80496d8:	0f 84 32 03 00 00    	je     8049a10 <main+0x4f0>

    // for tracking our threads
    std::thread threads[256];

    // launch the threads
    for (uint32_t j = 1; j < Config::CFG.threads; j++)
 80496de:	83 c3 01             	add    $0x1,%ebx
 80496e1:	39 1d c4 e4 04 08    	cmp    %ebx,0x804e4c4
 80496e7:	89 5c 24 30          	mov    %ebx,0x30(%esp)
 80496eb:	0f 86 57 02 00 00    	jbe    8049948 <main+0x428>
 80496f1:	8b 44 24 28          	mov    0x28(%esp),%eax
    class id
    {
      native_handle_type	_M_thread;

    public:
      id() noexcept : _M_thread() { }
 80496f5:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
 80496fc:	00 
 80496fd:	89 44 24 40          	mov    %eax,0x40(%esp)
 8049701:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8049705:	8b 00                	mov    (%eax),%eax
 8049707:	89 44 24 48          	mov    %eax,0x48(%esp)
 804970b:	8b 44 24 24          	mov    0x24(%esp),%eax
 804970f:	8b 00                	mov    (%eax),%eax
      // This constructor is non-standard, it is used by allocate_shared.
      template<typename _Alloc, typename... _Args>
	__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
		     _Args&&... __args)
	: _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,
				std::forward<_Args>(__args)...)
 8049711:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
 8049718:	00 
	}

      template<typename _Tp, typename _Alloc, typename... _Args>
	__shared_count(_Sp_make_shared_tag, _Tp*, const _Alloc& __a,
		       _Args&&... __args)
	: _M_pi(0)
 8049719:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
 8049720:	00 
 8049721:	89 44 24 4c          	mov    %eax,0x4c(%esp)
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 8049725:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
 804972c:	e8 0f fc ff ff       	call   8049340 <_Znwj@plt>
 8049731:	89 c3                	mov    %eax,%ebx
	  typename _Alloc_traits::allocator_type __a2(__a);
	  _Sp_cp_type* __mem = _Alloc_traits::allocate(__a2, 1);
	  __try
	    {
	      _Alloc_traits::construct(__a2, __mem, std::move(__a),
		    std::forward<_Args>(__args)...);
 8049733:	8b 44 24 20          	mov    0x20(%esp),%eax
 8049737:	89 04 24             	mov    %eax,(%esp)
 804973a:	e8 31 0f 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>
       *  arguments @a __args...
      */
      template<typename _Tp, typename... _Args>
	static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
	-> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
	{ _S_construct(__a, __p, std::forward<_Args>(__args)...); }
 804973f:	89 04 24             	mov    %eax,(%esp)
 8049742:	e8 29 0f 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>

      template<typename _Tp, typename... _Args>
	static typename
       	enable_if<__construct_helper<_Tp, _Args...>::value, void>::type
       	_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
	{ __a.construct(__p, std::forward<_Args>(__args)...); }
 8049747:	89 04 24             	mov    %eax,(%esp)
 804974a:	e8 21 0f 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 804974f:	89 04 24             	mov    %eax,(%esp)
 8049752:	e8 19 0f 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>
 8049757:	89 c6                	mov    %eax,%esi
 8049759:	89 d8                	mov    %ebx,%eax
 804975b:	e8 c0 06 00 00       	call   8049e20 <_ZnwjPv.isra.3>
 8049760:	85 c0                	test   %eax,%eax
 8049762:	89 c7                	mov    %eax,%edi
 8049764:	0f 84 bb 00 00 00    	je     8049825 <main+0x305>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
 804976a:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
 8049771:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
      };

    public:
      template<typename... _Args>
	_Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
	: _M_impl(__a)
 8049778:	c7 00 68 cf 04 08    	movl   $0x804cf68,(%eax)
	{
	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
	  // 2070.  allocate_shared should use allocator_traits<A>::construct
	  allocator_traits<_Alloc>::construct(__a, _M_ptr(),
	      std::forward<_Args>(__args)...); // might throw
 804977e:	89 34 24             	mov    %esi,(%esp)
 8049781:	e8 ea 0e 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>
 8049786:	89 3c 24             	mov    %edi,(%esp)
 8049789:	89 c6                	mov    %eax,%esi
 804978b:	e8 40 0f 00 00       	call   804a6d0 <_ZNSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS7_ELN9__gnu_cxx12_Lock_policyE2EE6_M_ptrEv>
       *  arguments @a __args...
      */
      template<typename _Tp, typename... _Args>
	static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
	-> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
	{ _S_construct(__a, __p, std::forward<_Args>(__args)...); }
 8049790:	89 34 24             	mov    %esi,(%esp)
 8049793:	89 44 24 2c          	mov    %eax,0x2c(%esp)
 8049797:	e8 d4 0e 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>

      template<typename _Tp, typename... _Args>
	static typename
       	enable_if<__construct_helper<_Tp, _Args...>::value, void>::type
       	_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
	{ __a.construct(__p, std::forward<_Args>(__args)...); }
 804979c:	89 04 24             	mov    %eax,(%esp)
 804979f:	e8 cc 0e 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>
 80497a4:	89 04 24             	mov    %eax,(%esp)
 80497a7:	e8 c4 0e 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>
 80497ac:	89 c7                	mov    %eax,%edi
 80497ae:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 80497b2:	e8 69 06 00 00       	call   8049e20 <_ZnwjPv.isra.3>
 80497b7:	85 c0                	test   %eax,%eax
 80497b9:	89 c6                	mov    %eax,%esi
 80497bb:	74 68                	je     8049825 <main+0x305>
	operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id);
    };

    // Simple base type that the templatized, derived class containing
    // an arbitrary functor can be converted to and called.
    struct _Impl_base
 80497bd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 80497c4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    template<typename _Callable>
      struct _Impl : public _Impl_base
      {
	_Callable		_M_func;

	_Impl(_Callable&& __f) : _M_func(std::forward<_Callable>(__f))
 80497cb:	c7 00 50 cf 04 08    	movl   $0x804cf50,(%eax)
 80497d1:	89 3c 24             	mov    %edi,(%esp)
 80497d4:	e8 97 0e 00 00       	call   804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
	              is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))), 
 80497d9:	89 04 24             	mov    %eax,(%esp)
 80497dc:	89 c7                	mov    %eax,%edi
 80497de:	e8 4d 0e 00 00       	call   804a630 <_ZNSt11_Tuple_implILj0EIPFvjEjEE7_M_tailERS2_>
 80497e3:	89 04 24             	mov    %eax,(%esp)
 80497e6:	e8 55 0e 00 00       	call   804a640 <_ZSt4moveIRSt11_Tuple_implILj1EIjEEEONSt16remove_referenceIT_E4typeEOS4_>
	_Base(std::forward<_Head>(_M_head(__in))) { }
 80497eb:	89 04 24             	mov    %eax,(%esp)
 80497ee:	e8 1d 0e 00 00       	call   804a610 <_ZNSt11_Tuple_implILj1EIjEE7_M_headERS0_>
 80497f3:	89 04 24             	mov    %eax,(%esp)
 80497f6:	e8 25 0e 00 00       	call   804a620 <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>

      template<typename _UHead, typename = typename
	       enable_if<!is_convertible<_UHead,
	                                 __uses_alloc_base>::value>::type>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 80497fb:	89 04 24             	mov    %eax,(%esp)
 80497fe:	e8 1d 0e 00 00       	call   804a620 <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 8049803:	8b 00                	mov    (%eax),%eax
 8049805:	89 46 0c             	mov    %eax,0xc(%esi)
      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
	              is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))), 
	_Base(std::forward<_Head>(_M_head(__in))) { }
 8049808:	89 3c 24             	mov    %edi,(%esp)
 804980b:	e8 40 0e 00 00       	call   804a650 <_ZNSt11_Tuple_implILj0EIPFvjEjEE7_M_headERS2_>
 8049810:	89 04 24             	mov    %eax,(%esp)
 8049813:	e8 48 0e 00 00       	call   804a660 <_ZSt7forwardIPFvjEEOT_RNSt16remove_referenceIS2_E4typeE>

      template<typename _UHead, typename = typename
	       enable_if<!is_convertible<_UHead,
	                                 __uses_alloc_base>::value>::type>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 8049818:	89 04 24             	mov    %eax,(%esp)
 804981b:	e8 40 0e 00 00       	call   804a660 <_ZSt7forwardIPFvjEEOT_RNSt16remove_referenceIS2_E4typeE>
 8049820:	8b 00                	mov    (%eax),%eax
 8049822:	89 46 10             	mov    %eax,0x10(%esi)
      _M_unique() const noexcept
      { return this->_M_get_use_count() == 1; }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }
 8049825:	31 c0                	xor    %eax,%eax
 8049827:	85 db                	test   %ebx,%ebx
	  _Sp_cp_type* __mem = _Alloc_traits::allocate(__a2, 1);
	  __try
	    {
	      _Alloc_traits::construct(__a2, __mem, std::move(__a),
		    std::forward<_Args>(__args)...);
	      _M_pi = __mem;
 8049829:	89 5c 24 44          	mov    %ebx,0x44(%esp)
      _M_unique() const noexcept
      { return this->_M_get_use_count() == 1; }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }
 804982d:	74 10                	je     804983f <main+0x31f>
 804982f:	8b 03                	mov    (%ebx),%eax
 8049831:	c7 44 24 04 34 ce 04 	movl   $0x804ce34,0x4(%esp)
 8049838:	08 
 8049839:	89 1c 24             	mov    %ebx,(%esp)
 804983c:	ff 50 10             	call   *0x10(%eax)
				std::forward<_Args>(__args)...)
	{
	  // _M_ptr needs to point to the newly constructed object.
	  // This relies on _Sp_counted_ptr_inplace::_M_get_deleter.
	  void* __p = _M_refcount._M_get_deleter(typeid(__tag));
	  _M_ptr = static_cast<_Tp*>(__p);
 804983f:	89 44 24 40          	mov    %eax,0x40(%esp)
       *  @post   *this contains the old value of @a __r, @a __r is empty.
       */
      template<typename _Tp1, typename = typename
	       std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
	shared_ptr(shared_ptr<_Tp1>&& __r) noexcept
	: __shared_ptr<_Tp>(std::move(__r)) { }
 8049843:	8d 44 24 40          	lea    0x40(%esp),%eax
 8049847:	89 04 24             	mov    %eax,(%esp)
 804984a:	e8 31 0e 00 00       	call   804a680 <_ZSt4moveIRSt10shared_ptrINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEEEEONSt16remove_referenceIT_E4typeEOSC_>
      }

      template<typename _Tp1, typename = typename
	       std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
	__shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r) noexcept
	: _M_ptr(__r._M_ptr), _M_refcount()
 804984f:	8b 10                	mov    (%eax),%edx
	{
	  _M_refcount._M_swap(__r._M_refcount);
	  __r._M_ptr = 0;
 8049851:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      }

      template<typename _Tp1, typename = typename
	       std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
	__shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r) noexcept
	: _M_ptr(__r._M_ptr), _M_refcount()
 8049857:	89 54 24 38          	mov    %edx,0x38(%esp)
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 804985b:	8b 50 04             	mov    0x4(%eax),%edx
	__r._M_pi = _M_pi;
 804985e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    template<typename _Callable, typename... _Args>
      explicit 
      thread(_Callable&& __f, _Args&&... __args)
      {
        _M_start_thread(_M_make_routine(std::__bind_simple(
 8049865:	8d 44 24 38          	lea    0x38(%esp),%eax
 8049869:	89 44 24 04          	mov    %eax,0x4(%esp)
 804986d:	8d 44 24 34          	lea    0x34(%esp),%eax
 8049871:	89 04 24             	mov    %eax,(%esp)
	_M_pi = __tmp;
 8049874:	89 54 24 3c          	mov    %edx,0x3c(%esp)
 8049878:	e8 83 f9 ff ff       	call   8049200 <_ZNSt6thread15_M_start_threadESt10shared_ptrINS_10_Impl_baseEE@plt>
      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
      explicit __shared_count(const __weak_count<_Lp>& __r);

      ~__shared_count() noexcept
      {
	if (_M_pi != 0)
 804987d:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
 8049881:	85 db                	test   %ebx,%ebx
 8049883:	74 17                	je     804989c <main+0x37c>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 8049885:	e8 b6 03 00 00       	call   8049c40 <_ZL18__gthread_active_pv>
 804988a:	85 c0                	test   %eax,%eax
 804988c:	75 72                	jne    8049900 <main+0x3e0>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 804988e:	8b 53 04             	mov    0x4(%ebx),%edx
    *__mem += __val;
 8049891:	8d 4a ff             	lea    -0x1(%edx),%ecx
      void
      _M_release() noexcept
      {
        // Be race-detector-friendly.  For more info see bits/c++config.
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
 8049894:	83 fa 01             	cmp    $0x1,%edx
 8049897:	89 4b 04             	mov    %ecx,0x4(%ebx)
 804989a:	74 73                	je     804990f <main+0x3ef>
      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
      explicit __shared_count(const __weak_count<_Lp>& __r);

      ~__shared_count() noexcept
      {
	if (_M_pi != 0)
 804989c:	8b 5c 24 44          	mov    0x44(%esp),%ebx
 80498a0:	85 db                	test   %ebx,%ebx
 80498a2:	0f 84 e2 fd ff ff    	je     804968a <main+0x16a>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 80498a8:	e8 93 03 00 00       	call   8049c40 <_ZL18__gthread_active_pv>
 80498ad:	85 c0                	test   %eax,%eax
 80498af:	0f 84 c3 fd ff ff    	je     8049678 <main+0x158>
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 80498b5:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 80498ba:	f0 0f c1 53 04       	lock xadd %edx,0x4(%ebx)
      void
      _M_release() noexcept
      {
        // Be race-detector-friendly.  For more info see bits/c++config.
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
 80498bf:	83 fa 01             	cmp    $0x1,%edx
 80498c2:	0f 85 c2 fd ff ff    	jne    804968a <main+0x16a>
	  {
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
	    _M_dispose();
 80498c8:	8b 13                	mov    (%ebx),%edx
 80498ca:	89 44 24 2c          	mov    %eax,0x2c(%esp)
 80498ce:	89 1c 24             	mov    %ebx,(%esp)
 80498d1:	ff 52 08             	call   *0x8(%edx)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 80498d4:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 80498d8:	85 c0                	test   %eax,%eax
 80498da:	0f 85 14 01 00 00    	jne    80499f4 <main+0x4d4>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 80498e0:	8b 43 08             	mov    0x8(%ebx),%eax
    *__mem += __val;
 80498e3:	8d 50 ff             	lea    -0x1(%eax),%edx
 80498e6:	89 53 08             	mov    %edx,0x8(%ebx)
	        _GLIBCXX_WRITE_MEM_BARRIER;
	      }

            // Be race-detector-friendly.  For more info see bits/c++config.
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
	    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
 80498e9:	83 f8 01             	cmp    $0x1,%eax
 80498ec:	0f 85 98 fd ff ff    	jne    804968a <main+0x16a>
						       -1) == 1)
              {
                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
	        _M_destroy();
 80498f2:	8b 03                	mov    (%ebx),%eax
 80498f4:	89 1c 24             	mov    %ebx,(%esp)
 80498f7:	ff 50 0c             	call   *0xc(%eax)
 80498fa:	e9 8b fd ff ff       	jmp    804968a <main+0x16a>
 80498ff:	90                   	nop
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 8049900:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 8049905:	f0 0f c1 53 04       	lock xadd %edx,0x4(%ebx)
      void
      _M_release() noexcept
      {
        // Be race-detector-friendly.  For more info see bits/c++config.
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
 804990a:	83 fa 01             	cmp    $0x1,%edx
 804990d:	75 8d                	jne    804989c <main+0x37c>
	  {
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
	    _M_dispose();
 804990f:	8b 13                	mov    (%ebx),%edx
 8049911:	89 44 24 2c          	mov    %eax,0x2c(%esp)
 8049915:	89 1c 24             	mov    %ebx,(%esp)
 8049918:	ff 52 08             	call   *0x8(%edx)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 804991b:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 804991f:	85 c0                	test   %eax,%eax
 8049921:	0f 85 dc 00 00 00    	jne    8049a03 <main+0x4e3>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 8049927:	8b 43 08             	mov    0x8(%ebx),%eax
    *__mem += __val;
 804992a:	8d 50 ff             	lea    -0x1(%eax),%edx
 804992d:	89 53 08             	mov    %edx,0x8(%ebx)
	        _GLIBCXX_WRITE_MEM_BARRIER;
	      }

            // Be race-detector-friendly.  For more info see bits/c++config.
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
	    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
 8049930:	83 f8 01             	cmp    $0x1,%eax
 8049933:	0f 85 63 ff ff ff    	jne    804989c <main+0x37c>
						       -1) == 1)
              {
                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
	        _M_destroy();
 8049939:	8b 03                	mov    (%ebx),%eax
 804993b:	89 1c 24             	mov    %ebx,(%esp)
 804993e:	ff 50 0c             	call   *0xc(%eax)
 8049941:	e9 56 ff ff ff       	jmp    804989c <main+0x37c>
 8049946:	66 90                	xchg   %ax,%ax
        threads[j] = thread(run, j);

    // all of the other threads should be waiting to run the benchmark, but
    // they can't until this thread starts the benchmark too...
    run(0);
 8049948:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804994f:	e8 0c 03 00 00       	call   8049c60 <_Z3runj>

    // everyone should be done.  Join all threads so we don't leave anything
    // hanging around
    for (uint32_t k = 1; k < Config::CFG.threads; k++)
 8049954:	83 3d c4 e4 04 08 01 	cmpl   $0x1,0x804e4c4
 804995b:	76 21                	jbe    804997e <main+0x45e>
 804995d:	8d 74 24 54          	lea    0x54(%esp),%esi
 8049961:	bb 01 00 00 00       	mov    $0x1,%ebx
 8049966:	66 90                	xchg   %ax,%ax
        threads[k].join();
 8049968:	89 34 24             	mov    %esi,(%esp)
 804996b:	e8 70 f9 ff ff       	call   80492e0 <_ZNSt6thread4joinEv@plt>
    // they can't until this thread starts the benchmark too...
    run(0);

    // everyone should be done.  Join all threads so we don't leave anything
    // hanging around
    for (uint32_t k = 1; k < Config::CFG.threads; k++)
 8049970:	83 c3 01             	add    $0x1,%ebx
 8049973:	83 c6 04             	add    $0x4,%esi
 8049976:	39 1d c4 e4 04 08    	cmp    %ebx,0x804e4c4
 804997c:	77 ea                	ja     8049968 <main+0x448>
        threads[k].join();

    // make sure the hash table is in a valid state
    bool v = bench_verify();
 804997e:	e8 3d 0e 00 00       	call   804a7c0 <_Z12bench_verifyv>
    std::cout << "Verification: " << (v ? "Passed" : "Failed") << "\n";
 8049983:	84 c0                	test   %al,%al
 8049985:	bb 43 cc 04 08       	mov    $0x804cc43,%ebx
 804998a:	b8 4a cc 04 08       	mov    $0x804cc4a,%eax
 804998f:	c7 44 24 04 51 cc 04 	movl   $0x804cc51,0x4(%esp)
 8049996:	08 
 8049997:	0f 44 d8             	cmove  %eax,%ebx
 804999a:	c7 04 24 c0 e3 04 08 	movl   $0x804e3c0,(%esp)
 80499a1:	e8 9a f8 ff ff       	call   8049240 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
 80499a6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 80499aa:	89 04 24             	mov    %eax,(%esp)
 80499ad:	e8 8e f8 ff ff       	call   8049240 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
 80499b2:	c7 44 24 04 35 cc 04 	movl   $0x804cc35,0x4(%esp)
 80499b9:	08 
 80499ba:	89 04 24             	mov    %eax,(%esp)
 80499bd:	e8 7e f8 ff ff       	call   8049240 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>

    // dump the results
    dump_csv();
 80499c2:	e8 89 04 00 00       	call   8049e50 <_Z8dump_csvv>
 80499c7:	8d 9c 24 4c 04 00 00 	lea    0x44c(%esp),%ebx
 80499ce:	8d 74 24 4c          	lea    0x4c(%esp),%esi
 80499d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80499d8:	8b 03                	mov    (%ebx),%eax
 80499da:	e8 61 04 00 00       	call   8049e40 <pthread_equal.constprop.28>
                std::forward<_Args>(__args)...)));
      }

    ~thread()
    {
      if (joinable())
 80499df:	85 c0                	test   %eax,%eax
 80499e1:	74 2d                	je     8049a10 <main+0x4f0>
 80499e3:	83 eb 04             	sub    $0x4,%ebx
 80499e6:	39 f3                	cmp    %esi,%ebx
 80499e8:	75 ee                	jne    80499d8 <main+0x4b8>
}
 80499ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80499ed:	31 c0                	xor    %eax,%eax
 80499ef:	5b                   	pop    %ebx
 80499f0:	5e                   	pop    %esi
 80499f1:	5f                   	pop    %edi
 80499f2:	5d                   	pop    %ebp
 80499f3:	c3                   	ret    
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 80499f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80499f9:	f0 0f c1 43 08       	lock xadd %eax,0x8(%ebx)
 80499fe:	e9 e6 fe ff ff       	jmp    80498e9 <main+0x3c9>
 8049a03:	83 c8 ff             	or     $0xffffffff,%eax
 8049a06:	f0 0f c1 43 08       	lock xadd %eax,0x8(%ebx)
 8049a0b:	e9 20 ff ff ff       	jmp    8049930 <main+0x410>
    thread& operator=(const thread&) = delete;

    thread& operator=(thread&& __t) noexcept
    {
      if (joinable())
	std::terminate();
 8049a10:	e8 db f8 ff ff       	call   80492f0 <_ZSt9terminatev@plt>
      // about what the return value is when __n == 0.
      pointer
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();
 8049a15:	e8 96 f9 ff ff       	call   80493b0 <_ZSt17__throw_bad_allocv@plt>
 8049a1a:	89 c6                	mov    %eax,%esi
 8049a1c:	c5 f8 77             	vzeroupper 
    // make sure the hash table is in a valid state
    bool v = bench_verify();
    std::cout << "Verification: " << (v ? "Passed" : "Failed") << "\n";

    // dump the results
    dump_csv();
 8049a1f:	8d 9c 24 50 04 00 00 	lea    0x450(%esp),%ebx
 8049a26:	83 eb 04             	sub    $0x4,%ebx
 8049a29:	8b 03                	mov    (%ebx),%eax
 8049a2b:	e8 10 04 00 00       	call   8049e40 <pthread_equal.constprop.28>
                std::forward<_Args>(__args)...)));
      }

    ~thread()
    {
      if (joinable())
 8049a30:	85 c0                	test   %eax,%eax
 8049a32:	74 dc                	je     8049a10 <main+0x4f0>
 8049a34:	8d 44 24 50          	lea    0x50(%esp),%eax
 8049a38:	39 c3                	cmp    %eax,%ebx
 8049a3a:	75 ea                	jne    8049a26 <main+0x506>
 8049a3c:	89 34 24             	mov    %esi,(%esp)
 8049a3f:	e8 ec f9 ff ff       	call   8049430 <_Unwind_Resume@plt>
 8049a44:	89 c6                	mov    %eax,%esi
      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
      explicit __shared_count(const __weak_count<_Lp>& __r);

      ~__shared_count() noexcept
      {
	if (_M_pi != 0)
 8049a46:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 8049a4a:	85 c0                	test   %eax,%eax
 8049a4c:	74 1d                	je     8049a6b <main+0x54b>
	  _M_pi->_M_release();
 8049a4e:	89 04 24             	mov    %eax,(%esp)
 8049a51:	c5 f8 77             	vzeroupper 
 8049a54:	e8 37 0b 00 00       	call   804a590 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE10_M_releaseEv>
      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
      explicit __shared_count(const __weak_count<_Lp>& __r);

      ~__shared_count() noexcept
      {
	if (_M_pi != 0)
 8049a59:	8b 54 24 44          	mov    0x44(%esp),%edx
 8049a5d:	85 d2                	test   %edx,%edx
 8049a5f:	74 be                	je     8049a1f <main+0x4ff>
	  _M_pi->_M_release();
 8049a61:	89 14 24             	mov    %edx,(%esp)
 8049a64:	e8 27 0b 00 00       	call   804a590 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE10_M_releaseEv>
 8049a69:	eb b4                	jmp    8049a1f <main+0x4ff>
 8049a6b:	c5 f8 77             	vzeroupper 
 8049a6e:	66 90                	xchg   %ax,%ax
 8049a70:	eb e7                	jmp    8049a59 <main+0x539>
 8049a72:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049a79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049a80 <_GLOBAL__sub_I__ZN6Config3CFGE>:
}
 8049a80:	83 ec 1c             	sub    $0x1c,%esp
  extern wostream wclog;	/// Linked to standard error (buffered)
#endif
  //@}

  // For construction of filebuffers for cout, cin, cerr, clog et. al.
  static ios_base::Init __ioinit;
 8049a83:	c7 04 24 e4 e4 04 08 	movl   $0x804e4e4,(%esp)
 8049a8a:	e8 31 f7 ff ff       	call   80491c0 <_ZNSt8ios_base4InitC1Ev@plt>
 8049a8f:	c7 44 24 08 24 e2 04 	movl   $0x804e224,0x8(%esp)
 8049a96:	08 
 8049a97:	c7 44 24 04 e4 e4 04 	movl   $0x804e4e4,0x4(%esp)
 8049a9e:	08 
 8049a9f:	c7 04 24 30 92 04 08 	movl   $0x8049230,(%esp)
 8049aa6:	e8 65 f6 ff ff       	call   8049110 <__cxa_atexit@plt>
     * single-thread, single-second test with a 256-element data structure
     * and an even lookup/insert/remove ratio
     */
    Config() :
        duration(1), threads(1), elements(256), lookpct(34), inspct(66),
        totaltime(0), running(true), opcount(0)
 8049aab:	c7 05 d4 e4 04 08 00 	movl   $0x0,0x804e4d4
 8049ab2:	00 00 00 
 8049ab5:	c7 05 c0 e4 04 08 01 	movl   $0x1,0x804e4c0
 8049abc:	00 00 00 
 8049abf:	c7 05 d8 e4 04 08 00 	movl   $0x0,0x804e4d8
 8049ac6:	00 00 00 
 8049ac9:	c7 05 c4 e4 04 08 01 	movl   $0x1,0x804e4c4
 8049ad0:	00 00 00 
 8049ad3:	c6 05 dc e4 04 08 01 	movb   $0x1,0x804e4dc
 8049ada:	c7 05 c8 e4 04 08 00 	movl   $0x100,0x804e4c8
 8049ae1:	01 00 00 
 8049ae4:	c7 05 cc e4 04 08 22 	movl   $0x22,0x804e4cc
 8049aeb:	00 00 00 
 8049aee:	c7 05 d0 e4 04 08 42 	movl   $0x42,0x804e4d0
 8049af5:	00 00 00 
 8049af8:	c7 05 e0 e4 04 08 00 	movl   $0x0,0x804e4e0
 8049aff:	00 00 00 
 8049b02:	83 c4 1c             	add    $0x1c,%esp
 8049b05:	c3                   	ret    
 8049b06:	66 90                	xchg   %ax,%ax
 8049b08:	66 90                	xchg   %ax,%ax
 8049b0a:	66 90                	xchg   %ax,%ax
 8049b0c:	66 90                	xchg   %ax,%ax
 8049b0e:	66 90                	xchg   %ax,%ax

08049b10 <_GLOBAL__sub_I_hash_table>:
 * Ensure the final state of the benchmark satisfies all invariants
 */
bool bench_verify()
{
    return hash_table->isSane();
}
 8049b10:	83 ec 1c             	sub    $0x1c,%esp
 8049b13:	c7 04 24 ec e4 04 08 	movl   $0x804e4ec,(%esp)
 8049b1a:	e8 a1 f6 ff ff       	call   80491c0 <_ZNSt8ios_base4InitC1Ev@plt>
 8049b1f:	c7 44 24 08 24 e2 04 	movl   $0x804e224,0x8(%esp)
 8049b26:	08 
 8049b27:	c7 44 24 04 ec e4 04 	movl   $0x804e4ec,0x4(%esp)
 8049b2e:	08 
 8049b2f:	c7 04 24 30 92 04 08 	movl   $0x8049230,(%esp)
 8049b36:	e8 d5 f5 ff ff       	call   8049110 <__cxa_atexit@plt>
 8049b3b:	83 c4 1c             	add    $0x1c,%esp
 8049b3e:	c3                   	ret    
 8049b3f:	90                   	nop

08049b40 <_start>:
 8049b40:	31 ed                	xor    %ebp,%ebp
 8049b42:	5e                   	pop    %esi
 8049b43:	89 e1                	mov    %esp,%ecx
 8049b45:	83 e4 f0             	and    $0xfffffff0,%esp
 8049b48:	50                   	push   %eax
 8049b49:	54                   	push   %esp
 8049b4a:	52                   	push   %edx
 8049b4b:	68 b0 cb 04 08       	push   $0x804cbb0
 8049b50:	68 40 cb 04 08       	push   $0x804cb40
 8049b55:	51                   	push   %ecx
 8049b56:	56                   	push   %esi
 8049b57:	68 20 95 04 08       	push   $0x8049520
 8049b5c:	e8 7f f6 ff ff       	call   80491e0 <__libc_start_main@plt>
 8049b61:	f4                   	hlt    
 8049b62:	66 90                	xchg   %ax,%ax
 8049b64:	66 90                	xchg   %ax,%ax
 8049b66:	66 90                	xchg   %ax,%ax
 8049b68:	66 90                	xchg   %ax,%ax
 8049b6a:	66 90                	xchg   %ax,%ax
 8049b6c:	66 90                	xchg   %ax,%ax
 8049b6e:	66 90                	xchg   %ax,%ax

08049b70 <__x86.get_pc_thunk.bx>:
 8049b70:	8b 1c 24             	mov    (%esp),%ebx
 8049b73:	c3                   	ret    
 8049b74:	66 90                	xchg   %ax,%ax
 8049b76:	66 90                	xchg   %ax,%ax
 8049b78:	66 90                	xchg   %ax,%ax
 8049b7a:	66 90                	xchg   %ax,%ax
 8049b7c:	66 90                	xchg   %ax,%ax
 8049b7e:	66 90                	xchg   %ax,%ax

08049b80 <deregister_tm_clones>:
 8049b80:	b8 db e2 04 08       	mov    $0x804e2db,%eax
 8049b85:	2d 28 e2 04 08       	sub    $0x804e228,%eax
 8049b8a:	83 f8 06             	cmp    $0x6,%eax
 8049b8d:	77 01                	ja     8049b90 <deregister_tm_clones+0x10>
 8049b8f:	c3                   	ret    
 8049b90:	b8 10 93 04 08       	mov    $0x8049310,%eax
 8049b95:	85 c0                	test   %eax,%eax
 8049b97:	74 f6                	je     8049b8f <deregister_tm_clones+0xf>
 8049b99:	55                   	push   %ebp
 8049b9a:	89 e5                	mov    %esp,%ebp
 8049b9c:	83 ec 18             	sub    $0x18,%esp
 8049b9f:	c7 04 24 28 e2 04 08 	movl   $0x804e228,(%esp)
 8049ba6:	ff d0                	call   *%eax
 8049ba8:	c9                   	leave  
 8049ba9:	c3                   	ret    
 8049baa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

08049bb0 <register_tm_clones>:
 8049bb0:	b8 d8 e2 04 08       	mov    $0x804e2d8,%eax
 8049bb5:	2d 28 e2 04 08       	sub    $0x804e228,%eax
 8049bba:	c1 f8 02             	sar    $0x2,%eax
 8049bbd:	89 c2                	mov    %eax,%edx
 8049bbf:	c1 ea 1f             	shr    $0x1f,%edx
 8049bc2:	01 d0                	add    %edx,%eax
 8049bc4:	d1 f8                	sar    %eax
 8049bc6:	75 01                	jne    8049bc9 <register_tm_clones+0x19>
 8049bc8:	c3                   	ret    
 8049bc9:	ba 20 94 04 08       	mov    $0x8049420,%edx
 8049bce:	85 d2                	test   %edx,%edx
 8049bd0:	74 f6                	je     8049bc8 <register_tm_clones+0x18>
 8049bd2:	55                   	push   %ebp
 8049bd3:	89 e5                	mov    %esp,%ebp
 8049bd5:	83 ec 18             	sub    $0x18,%esp
 8049bd8:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049bdc:	c7 04 24 28 e2 04 08 	movl   $0x804e228,(%esp)
 8049be3:	ff d2                	call   *%edx
 8049be5:	c9                   	leave  
 8049be6:	c3                   	ret    
 8049be7:	89 f6                	mov    %esi,%esi
 8049be9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049bf0 <__do_global_dtors_aux>:
 8049bf0:	80 3d 90 e4 04 08 00 	cmpb   $0x0,0x804e490
 8049bf7:	75 13                	jne    8049c0c <__do_global_dtors_aux+0x1c>
 8049bf9:	55                   	push   %ebp
 8049bfa:	89 e5                	mov    %esp,%ebp
 8049bfc:	83 ec 08             	sub    $0x8,%esp
 8049bff:	e8 7c ff ff ff       	call   8049b80 <deregister_tm_clones>
 8049c04:	c6 05 90 e4 04 08 01 	movb   $0x1,0x804e490
 8049c0b:	c9                   	leave  
 8049c0c:	f3 c3                	repz ret 
 8049c0e:	66 90                	xchg   %ax,%ax

08049c10 <frame_dummy>:
 8049c10:	a1 10 e0 04 08       	mov    0x804e010,%eax
 8049c15:	85 c0                	test   %eax,%eax
 8049c17:	74 1f                	je     8049c38 <frame_dummy+0x28>
 8049c19:	b8 00 00 00 00       	mov    $0x0,%eax
 8049c1e:	85 c0                	test   %eax,%eax
 8049c20:	74 16                	je     8049c38 <frame_dummy+0x28>
 8049c22:	55                   	push   %ebp
 8049c23:	89 e5                	mov    %esp,%ebp
 8049c25:	83 ec 18             	sub    $0x18,%esp
 8049c28:	c7 04 24 10 e0 04 08 	movl   $0x804e010,(%esp)
 8049c2f:	ff d0                	call   *%eax
 8049c31:	c9                   	leave  
 8049c32:	e9 79 ff ff ff       	jmp    8049bb0 <register_tm_clones>
 8049c37:	90                   	nop
 8049c38:	e9 73 ff ff ff       	jmp    8049bb0 <register_tm_clones>
 8049c3d:	66 90                	xchg   %ax,%ax
 8049c3f:	90                   	nop

08049c40 <_ZL18__gthread_active_pv>:
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &GTHR_ACTIVE_PROXY;
  return __gthread_active_ptr != 0;
 8049c40:	b8 f0 93 04 08       	mov    $0x80493f0,%eax
 8049c45:	85 c0                	test   %eax,%eax
 8049c47:	0f 95 c0             	setne  %al
 8049c4a:	0f b6 c0             	movzbl %al,%eax
}
 8049c4d:	c3                   	ret    
 8049c4e:	66 90                	xchg   %ax,%ax

08049c50 <catch_SIGALRM>:
/**
 * Signal handler to end a test
 */
extern "C" void catch_SIGALRM(int)
{
    Config::CFG.running = false;
 8049c50:	c6 05 dc e4 04 08 00 	movb   $0x0,0x804e4dc
 8049c57:	c3                   	ret    
 8049c58:	90                   	nop
 8049c59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08049c60 <_Z3runj>:

/**
 * Run a timed experiment
 */
void run(uintptr_t id)
{
 8049c60:	57                   	push   %edi
 8049c61:	56                   	push   %esi
 8049c62:	53                   	push   %ebx
 8049c63:	83 ec 20             	sub    $0x20,%esp
 8049c66:	8b 5c 24 30          	mov    0x30(%esp),%ebx
      }

      _GLIBCXX_ALWAYS_INLINE __int_type
      fetch_add(__int_type __i,
		memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_i, __i, __m); }
 8049c6a:	f0 83 05 a8 e4 04 08 	lock addl $0x1,0x804e4a8
 8049c71:	01 
    // wait until all threads created, then set alarm and read timer
    b0.fetch_add(1); while (b0 != Config::CFG.threads) { std::this_thread::yield(); }
 8049c72:	eb 09                	jmp    8049c7d <_Z3runj+0x1d>
 8049c74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

static inline int
__gthread_yield (void)
{
  return __gthrw_(sched_yield) ();
 8049c78:	e8 e3 f4 ff ff       	call   8049160 <sched_yield@plt>
      {
       memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_i, __m);
 8049c7d:	a1 a8 e4 04 08       	mov    0x804e4a8,%eax
 8049c82:	39 05 c4 e4 04 08    	cmp    %eax,0x804e4c4
 8049c88:	75 ee                	jne    8049c78 <_Z3runj+0x18>

    if (id == 0) {
 8049c8a:	85 db                	test   %ebx,%ebx
 8049c8c:	75 42                	jne    8049cd0 <_Z3runj+0x70>
    	    //we use timer
	    if (Config::CFG.opcount == 0){
 8049c8e:	a1 e0 e4 04 08       	mov    0x804e4e0,%eax
 8049c93:	85 c0                	test   %eax,%eax
 8049c95:	0f 84 4d 01 00 00    	je     8049de8 <_Z3runj+0x188>
 *  Helper function for computing time in a cross-platform way
 */
long long getElapsedTime()
{
    struct timespec t;
    clock_gettime(CLOCK_REALTIME, &t);
 8049c9b:	8d 44 24 18          	lea    0x18(%esp),%eax
 8049c9f:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049ca3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8049caa:	e8 a1 f6 ff ff       	call   8049350 <clock_gettime@plt>
    uint64_t tt = (((long long)t.tv_sec) * 1000000000L) + ((long long)t.tv_nsec);
 8049caf:	8b 74 24 1c          	mov    0x1c(%esp),%esi
 8049cb3:	b8 00 ca 9a 3b       	mov    $0x3b9aca00,%eax
 8049cb8:	f7 6c 24 18          	imull  0x18(%esp)
 8049cbc:	89 f7                	mov    %esi,%edi
 8049cbe:	c1 ff 1f             	sar    $0x1f,%edi
 8049cc1:	01 f0                	add    %esi,%eax
 8049cc3:	11 fa                	adc    %edi,%edx
    	    //we use timer
	    if (Config::CFG.opcount == 0){
		    signal(SIGALRM, catch_SIGALRM);
		    alarm(Config::CFG.duration);
	    }
	    Config::CFG.totaltime = getElapsedTime();
 8049cc5:	a3 d4 e4 04 08       	mov    %eax,0x804e4d4
 8049cca:	89 15 d8 e4 04 08    	mov    %edx,0x804e4d8
      }

      _GLIBCXX_ALWAYS_INLINE __int_type
      fetch_add(__int_type __i,
		memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_i, __i, __m); }
 8049cd0:	f0 83 05 a4 e4 04 08 	lock addl $0x1,0x804e4a4
 8049cd7:	01 
    }

    // wait until read of start timer finishes, then start transactions
    b1.fetch_add(1); while (b1 != Config::CFG.threads) { std::this_thread::yield(); }
 8049cd8:	eb 0b                	jmp    8049ce5 <_Z3runj+0x85>
 8049cda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8049ce0:	e8 7b f4 ff ff       	call   8049160 <sched_yield@plt>
      {
       memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_i, __m);
 8049ce5:	a1 a4 e4 04 08       	mov    0x804e4a4,%eax
 8049cea:	39 05 c4 e4 04 08    	cmp    %eax,0x804e4c4
 8049cf0:	75 ee                	jne    8049ce0 <_Z3runj+0x80>
    uint32_t count = 0;
    uint32_t seed = id;

    // we do constant number of operations
    if (Config::CFG.opcount > 0){
 8049cf2:	a1 e0 e4 04 08       	mov    0x804e4e0,%eax
    }

    // wait until read of start timer finishes, then start transactions
    b1.fetch_add(1); while (b1 != Config::CFG.threads) { std::this_thread::yield(); }
    uint32_t count = 0;
    uint32_t seed = id;
 8049cf7:	89 5c 24 14          	mov    %ebx,0x14(%esp)

    // we do constant number of operations
    if (Config::CFG.opcount > 0){
 8049cfb:	85 c0                	test   %eax,%eax
 8049cfd:	75 69                	jne    8049d68 <_Z3runj+0x108>
		bench_test(id, &seed);
		++count;
	}
    }else{
	    // run until alarm fires
	while (Config::CFG.running) {
 8049cff:	0f b6 05 dc e4 04 08 	movzbl 0x804e4dc,%eax
 8049d06:	31 f6                	xor    %esi,%esi
 8049d08:	8d 7c 24 14          	lea    0x14(%esp),%edi
 8049d0c:	84 c0                	test   %al,%al
 8049d0e:	74 1a                	je     8049d2a <_Z3runj+0xca>
		bench_test(id, &seed);
 8049d10:	89 7c 24 04          	mov    %edi,0x4(%esp)
        	++count;
 8049d14:	83 c6 01             	add    $0x1,%esi
		++count;
	}
    }else{
	    // run until alarm fires
	while (Config::CFG.running) {
		bench_test(id, &seed);
 8049d17:	89 1c 24             	mov    %ebx,(%esp)
 8049d1a:	e8 31 0e 00 00       	call   804ab50 <_Z10bench_testjPj>
		bench_test(id, &seed);
		++count;
	}
    }else{
	    // run until alarm fires
	while (Config::CFG.running) {
 8049d1f:	0f b6 05 dc e4 04 08 	movzbl 0x804e4dc,%eax
 8049d26:	84 c0                	test   %al,%al
 8049d28:	75 e6                	jne    8049d10 <_Z3runj+0xb0>
      }

      _GLIBCXX_ALWAYS_INLINE __int_type
      fetch_add(__int_type __i,
		memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_i, __i, __m); }
 8049d2a:	f0 83 05 a0 e4 04 08 	lock addl $0x1,0x804e4a0
 8049d31:	01 
        	++count;
	}
    }

    // wait until all operations finish, then get time
    b2.fetch_add(1); while (b2 != Config::CFG.threads) { std::this_thread::yield(); }
 8049d32:	eb 09                	jmp    8049d3d <_Z3runj+0xdd>
 8049d34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049d38:	e8 23 f4 ff ff       	call   8049160 <sched_yield@plt>
      {
       memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_i, __m);
 8049d3d:	a1 a0 e4 04 08       	mov    0x804e4a0,%eax
 8049d42:	39 05 c4 e4 04 08    	cmp    %eax,0x804e4c4
 8049d48:	75 ee                	jne    8049d38 <_Z3runj+0xd8>
    if (id == 0)
 8049d4a:	85 db                	test   %ebx,%ebx
 8049d4c:	74 4a                	je     8049d98 <_Z3runj+0x138>
        Config::CFG.totaltime = getElapsedTime() - Config::CFG.totaltime;

    // we use timer, so fix opcount
    if (Config::CFG.opcount == 0)
 8049d4e:	a1 e0 e4 04 08       	mov    0x804e4e0,%eax
 8049d53:	85 c0                	test   %eax,%eax
 8049d55:	75 07                	jne    8049d5e <_Z3runj+0xfe>
    	// add this thread's count to an accumulator
    	__sync_fetch_and_add(&Config::CFG.opcount, count);
 8049d57:	f0 01 35 e0 e4 04 08 	lock add %esi,0x804e4e0
}
 8049d5e:	83 c4 20             	add    $0x20,%esp
 8049d61:	5b                   	pop    %ebx
 8049d62:	5e                   	pop    %esi
 8049d63:	5f                   	pop    %edi
 8049d64:	c3                   	ret    
 8049d65:	8d 76 00             	lea    0x0(%esi),%esi
    uint32_t count = 0;
    uint32_t seed = id;

    // we do constant number of operations
    if (Config::CFG.opcount > 0){
    	while(count < Config::CFG.opcount){
 8049d68:	a1 e0 e4 04 08       	mov    0x804e4e0,%eax
 8049d6d:	31 f6                	xor    %esi,%esi
 8049d6f:	85 c0                	test   %eax,%eax
 8049d71:	74 b7                	je     8049d2a <_Z3runj+0xca>
 8049d73:	8d 7c 24 14          	lea    0x14(%esp),%edi
 8049d77:	90                   	nop
		bench_test(id, &seed);
 8049d78:	89 7c 24 04          	mov    %edi,0x4(%esp)
		++count;
 8049d7c:	83 c6 01             	add    $0x1,%esi
    uint32_t seed = id;

    // we do constant number of operations
    if (Config::CFG.opcount > 0){
    	while(count < Config::CFG.opcount){
		bench_test(id, &seed);
 8049d7f:	89 1c 24             	mov    %ebx,(%esp)
 8049d82:	e8 c9 0d 00 00       	call   804ab50 <_Z10bench_testjPj>
    uint32_t count = 0;
    uint32_t seed = id;

    // we do constant number of operations
    if (Config::CFG.opcount > 0){
    	while(count < Config::CFG.opcount){
 8049d87:	a1 e0 e4 04 08       	mov    0x804e4e0,%eax
 8049d8c:	39 f0                	cmp    %esi,%eax
 8049d8e:	77 e8                	ja     8049d78 <_Z3runj+0x118>
 8049d90:	eb 98                	jmp    8049d2a <_Z3runj+0xca>
 8049d92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 *  Helper function for computing time in a cross-platform way
 */
long long getElapsedTime()
{
    struct timespec t;
    clock_gettime(CLOCK_REALTIME, &t);
 8049d98:	8d 44 24 18          	lea    0x18(%esp),%eax
 8049d9c:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049da0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8049da7:	e8 a4 f5 ff ff       	call   8049350 <clock_gettime@plt>
    uint64_t tt = (((long long)t.tv_sec) * 1000000000L) + ((long long)t.tv_nsec);
 8049dac:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
 8049db0:	b8 00 ca 9a 3b       	mov    $0x3b9aca00,%eax
 8049db5:	f7 6c 24 18          	imull  0x18(%esp)
 8049db9:	89 cb                	mov    %ecx,%ebx
 8049dbb:	c1 fb 1f             	sar    $0x1f,%ebx
 8049dbe:	01 c8                	add    %ecx,%eax
    }

    // wait until all operations finish, then get time
    b2.fetch_add(1); while (b2 != Config::CFG.threads) { std::this_thread::yield(); }
    if (id == 0)
        Config::CFG.totaltime = getElapsedTime() - Config::CFG.totaltime;
 8049dc0:	8b 0d d4 e4 04 08    	mov    0x804e4d4,%ecx
 */
long long getElapsedTime()
{
    struct timespec t;
    clock_gettime(CLOCK_REALTIME, &t);
    uint64_t tt = (((long long)t.tv_sec) * 1000000000L) + ((long long)t.tv_nsec);
 8049dc6:	11 da                	adc    %ebx,%edx
    }

    // wait until all operations finish, then get time
    b2.fetch_add(1); while (b2 != Config::CFG.threads) { std::this_thread::yield(); }
    if (id == 0)
        Config::CFG.totaltime = getElapsedTime() - Config::CFG.totaltime;
 8049dc8:	8b 1d d8 e4 04 08    	mov    0x804e4d8,%ebx
 8049dce:	29 c8                	sub    %ecx,%eax
 8049dd0:	19 da                	sbb    %ebx,%edx
 8049dd2:	a3 d4 e4 04 08       	mov    %eax,0x804e4d4
 8049dd7:	89 15 d8 e4 04 08    	mov    %edx,0x804e4d8
 8049ddd:	e9 6c ff ff ff       	jmp    8049d4e <_Z3runj+0xee>
 8049de2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    b0.fetch_add(1); while (b0 != Config::CFG.threads) { std::this_thread::yield(); }

    if (id == 0) {
    	    //we use timer
	    if (Config::CFG.opcount == 0){
		    signal(SIGALRM, catch_SIGALRM);
 8049de8:	c7 44 24 04 50 9c 04 	movl   $0x8049c50,0x4(%esp)
 8049def:	08 
 8049df0:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
 8049df7:	e8 44 f3 ff ff       	call   8049140 <signal@plt>
		    alarm(Config::CFG.duration);
 8049dfc:	a1 c0 e4 04 08       	mov    0x804e4c0,%eax
 8049e01:	89 04 24             	mov    %eax,(%esp)
 8049e04:	e8 b7 f4 ff ff       	call   80492c0 <alarm@plt>
 8049e09:	e9 8d fe ff ff       	jmp    8049c9b <_Z3runj+0x3b>
 8049e0e:	66 90                	xchg   %ax,%ax

08049e10 <_ZNKSt9basic_iosIcSt11char_traitsIcEE7rdstateEv.isra.1>:
       *  See std::ios_base::iostate for the possible bit values.  Most
       *  users will call one of the interpreting wrappers, e.g., good().
      */
      iostate
      rdstate() const
      { return _M_streambuf_state; }
 8049e10:	f3 c3                	repz ret 
 8049e12:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049e19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049e20 <_ZnwjPv.isra.3>:
void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
  __attribute__((__externally_visible__));

// Default placement versions of operator new.
inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
{ return __p; }
 8049e20:	f3 c3                	repz ret 
 8049e22:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049e29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049e30 <_ZNK9__gnu_cxx13new_allocatorISt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS9_ELNS_12_Lock_policyE2EEE8max_sizeEv.isra.10>:
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const _GLIBCXX_USE_NOEXCEPT
      { return size_t(-1) / sizeof(_Tp); }
 8049e30:	b8 ff ff ff 07       	mov    $0x7ffffff,%eax
 8049e35:	c3                   	ret    
 8049e36:	8d 76 00             	lea    0x0(%esi),%esi
 8049e39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049e40 <pthread_equal.constprop.28>:
#ifdef __USE_EXTERN_INLINES
/* Optimizations.  */
__extern_inline int
__NTH (pthread_equal (pthread_t __thread1, pthread_t __thread2))
{
  return __thread1 == __thread2;
 8049e40:	85 c0                	test   %eax,%eax
 8049e42:	0f 94 c0             	sete   %al
 8049e45:	0f b6 c0             	movzbl %al,%eax
}
 8049e48:	c3                   	ret    
 8049e49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08049e50 <_Z8dump_csvv>:

/**
 * Print benchmark configuration and results (throughput)
 */
void dump_csv()
{
 8049e50:	55                   	push   %ebp
              << ", R=" << Config::CFG.lookpct
              << ", d=" << Config::CFG.duration   << ", p=" << Config::CFG.threads
              << ", m=" << Config::CFG.elements
              << ", ops=" << Config::CFG.opcount << ", time=" << Config::CFG.totaltime
              << ", throughput="
              << (1000000000LL * Config::CFG.opcount) / (Config::CFG.totaltime)
 8049e51:	b8 00 ca 9a 3b       	mov    $0x3b9aca00,%eax

/**
 * Print benchmark configuration and results (throughput)
 */
void dump_csv()
{
 8049e56:	57                   	push   %edi
 8049e57:	56                   	push   %esi
 8049e58:	53                   	push   %ebx
 8049e59:	83 ec 3c             	sub    $0x3c,%esp
              << ", R=" << Config::CFG.lookpct
              << ", d=" << Config::CFG.duration   << ", p=" << Config::CFG.threads
              << ", m=" << Config::CFG.elements
              << ", ops=" << Config::CFG.opcount << ", time=" << Config::CFG.totaltime
              << ", throughput="
              << (1000000000LL * Config::CFG.opcount) / (Config::CFG.totaltime)
 8049e5c:	8b 15 e0 e4 04 08    	mov    0x804e4e0,%edx
 8049e62:	8b 0d d4 e4 04 08    	mov    0x804e4d4,%ecx
 8049e68:	8b 1d d8 e4 04 08    	mov    0x804e4d8,%ebx
 8049e6e:	c4 e2 7b f6 d0       	mulx   %eax,%eax,%edx
 8049e73:	89 04 24             	mov    %eax,(%esp)
 8049e76:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 8049e7a:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 8049e7e:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049e82:	e8 49 f5 ff ff       	call   80493d0 <__udivdi3@plt>
    // csv output
    std::cout << "csv"
              << ", R=" << Config::CFG.lookpct
              << ", d=" << Config::CFG.duration   << ", p=" << Config::CFG.threads
              << ", m=" << Config::CFG.elements
              << ", ops=" << Config::CFG.opcount << ", time=" << Config::CFG.totaltime
 8049e87:	8b 0d d4 e4 04 08    	mov    0x804e4d4,%ecx
 8049e8d:	8b 1d d8 e4 04 08    	mov    0x804e4d8,%ebx
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049e93:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 8049e9a:	00 
 8049e9b:	8b 35 e0 e4 04 08    	mov    0x804e4e0,%esi
 8049ea1:	c7 44 24 04 e8 cb 04 	movl   $0x804cbe8,0x4(%esp)
 8049ea8:	08 
{
    // csv output
    std::cout << "csv"
              << ", R=" << Config::CFG.lookpct
              << ", d=" << Config::CFG.duration   << ", p=" << Config::CFG.threads
              << ", m=" << Config::CFG.elements
 8049ea9:	8b 3d c8 e4 04 08    	mov    0x804e4c8,%edi
 8049eaf:	c7 04 24 c0 e3 04 08 	movl   $0x804e3c0,(%esp)
void dump_csv()
{
    // csv output
    std::cout << "csv"
              << ", R=" << Config::CFG.lookpct
              << ", d=" << Config::CFG.duration   << ", p=" << Config::CFG.threads
 8049eb6:	8b 2d c4 e4 04 08    	mov    0x804e4c4,%ebp
              << ", m=" << Config::CFG.elements
              << ", ops=" << Config::CFG.opcount << ", time=" << Config::CFG.totaltime
 8049ebc:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
 */
void dump_csv()
{
    // csv output
    std::cout << "csv"
              << ", R=" << Config::CFG.lookpct
 8049ec0:	8b 1d cc e4 04 08    	mov    0x804e4cc,%ebx
              << ", d=" << Config::CFG.duration   << ", p=" << Config::CFG.threads
              << ", m=" << Config::CFG.elements
              << ", ops=" << Config::CFG.opcount << ", time=" << Config::CFG.totaltime
              << ", throughput="
              << (1000000000LL * Config::CFG.opcount) / (Config::CFG.totaltime)
 8049ec6:	89 54 24 24          	mov    %edx,0x24(%esp)
void dump_csv()
{
    // csv output
    std::cout << "csv"
              << ", R=" << Config::CFG.lookpct
              << ", d=" << Config::CFG.duration   << ", p=" << Config::CFG.threads
 8049eca:	8b 15 c0 e4 04 08    	mov    0x804e4c0,%edx
              << ", m=" << Config::CFG.elements
              << ", ops=" << Config::CFG.opcount << ", time=" << Config::CFG.totaltime
 8049ed0:	89 4c 24 18          	mov    %ecx,0x18(%esp)
              << ", throughput="
              << (1000000000LL * Config::CFG.opcount) / (Config::CFG.totaltime)
 8049ed4:	89 44 24 20          	mov    %eax,0x20(%esp)
void dump_csv()
{
    // csv output
    std::cout << "csv"
              << ", R=" << Config::CFG.lookpct
              << ", d=" << Config::CFG.duration   << ", p=" << Config::CFG.threads
 8049ed8:	89 54 24 2c          	mov    %edx,0x2c(%esp)
 8049edc:	e8 8f f5 ff ff       	call   8049470 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i@plt>
 8049ee1:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
 8049ee8:	00 
 8049ee9:	c7 44 24 04 ec cb 04 	movl   $0x804cbec,0x4(%esp)
 8049ef0:	08 
 8049ef1:	c7 04 24 c0 e3 04 08 	movl   $0x804e3c0,(%esp)
 8049ef8:	e8 73 f5 ff ff       	call   8049470 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i@plt>
      __ostream_type&
      operator<<(unsigned int __n)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<unsigned long>(__n));
 8049efd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8049f01:	c7 04 24 c0 e3 04 08 	movl   $0x804e3c0,(%esp)
 8049f08:	e8 93 f4 ff ff       	call   80493a0 <_ZNSo9_M_insertImEERSoT_@plt>
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049f0d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
 8049f14:	00 
 8049f15:	c7 44 24 04 f1 cb 04 	movl   $0x804cbf1,0x4(%esp)
 8049f1c:	08 
 8049f1d:	89 04 24             	mov    %eax,(%esp)
      __ostream_type&
      operator<<(unsigned int __n)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<unsigned long>(__n));
 8049f20:	89 c3                	mov    %eax,%ebx
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049f22:	e8 49 f5 ff ff       	call   8049470 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i@plt>
      __ostream_type&
      operator<<(unsigned int __n)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<unsigned long>(__n));
 8049f27:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 8049f2b:	89 1c 24             	mov    %ebx,(%esp)
 8049f2e:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049f32:	e8 69 f4 ff ff       	call   80493a0 <_ZNSo9_M_insertImEERSoT_@plt>
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049f37:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
 8049f3e:	00 
 8049f3f:	c7 44 24 04 f6 cb 04 	movl   $0x804cbf6,0x4(%esp)
 8049f46:	08 
      __ostream_type&
      operator<<(unsigned int __n)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<unsigned long>(__n));
 8049f47:	89 c3                	mov    %eax,%ebx
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049f49:	89 04 24             	mov    %eax,(%esp)
 8049f4c:	e8 1f f5 ff ff       	call   8049470 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i@plt>
      __ostream_type&
      operator<<(unsigned int __n)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<unsigned long>(__n));
 8049f51:	89 6c 24 04          	mov    %ebp,0x4(%esp)
 8049f55:	89 1c 24             	mov    %ebx,(%esp)
 8049f58:	e8 43 f4 ff ff       	call   80493a0 <_ZNSo9_M_insertImEERSoT_@plt>
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049f5d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
 8049f64:	00 
 8049f65:	c7 44 24 04 fb cb 04 	movl   $0x804cbfb,0x4(%esp)
 8049f6c:	08 
      __ostream_type&
      operator<<(unsigned int __n)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<unsigned long>(__n));
 8049f6d:	89 c3                	mov    %eax,%ebx
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049f6f:	89 04 24             	mov    %eax,(%esp)
 8049f72:	e8 f9 f4 ff ff       	call   8049470 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i@plt>
      __ostream_type&
      operator<<(unsigned int __n)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<unsigned long>(__n));
 8049f77:	89 7c 24 04          	mov    %edi,0x4(%esp)
 8049f7b:	89 1c 24             	mov    %ebx,(%esp)
 8049f7e:	e8 1d f4 ff ff       	call   80493a0 <_ZNSo9_M_insertImEERSoT_@plt>
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049f83:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
 8049f8a:	00 
 8049f8b:	c7 44 24 04 00 cc 04 	movl   $0x804cc00,0x4(%esp)
 8049f92:	08 
      __ostream_type&
      operator<<(unsigned int __n)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<unsigned long>(__n));
 8049f93:	89 c3                	mov    %eax,%ebx
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049f95:	89 04 24             	mov    %eax,(%esp)
 8049f98:	e8 d3 f4 ff ff       	call   8049470 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i@plt>
      __ostream_type&
      operator<<(unsigned int __n)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<unsigned long>(__n));
 8049f9d:	89 74 24 04          	mov    %esi,0x4(%esp)
 8049fa1:	89 1c 24             	mov    %ebx,(%esp)
 8049fa4:	e8 f7 f3 ff ff       	call   80493a0 <_ZNSo9_M_insertImEERSoT_@plt>
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049fa9:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
 8049fb0:	00 
 8049fb1:	c7 44 24 04 07 cc 04 	movl   $0x804cc07,0x4(%esp)
 8049fb8:	08 
 8049fb9:	89 04 24             	mov    %eax,(%esp)
      __ostream_type&
      operator<<(unsigned int __n)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<unsigned long>(__n));
 8049fbc:	89 c3                	mov    %eax,%ebx
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049fbe:	e8 ad f4 ff ff       	call   8049470 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i@plt>
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
 8049fc3:	8b 7c 24 18          	mov    0x18(%esp),%edi
 8049fc7:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
 8049fcb:	89 1c 24             	mov    %ebx,(%esp)
 8049fce:	89 7c 24 04          	mov    %edi,0x4(%esp)
 8049fd2:	89 6c 24 08          	mov    %ebp,0x8(%esp)
 8049fd6:	e8 85 f3 ff ff       	call   8049360 <_ZNSo9_M_insertIyEERSoT_@plt>
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049fdb:	c7 44 24 08 0d 00 00 	movl   $0xd,0x8(%esp)
 8049fe2:	00 
 8049fe3:	c7 44 24 04 0f cc 04 	movl   $0x804cc0f,0x4(%esp)
 8049fea:	08 
 8049feb:	89 04 24             	mov    %eax,(%esp)
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
 8049fee:	89 c3                	mov    %eax,%ebx
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
 8049ff0:	e8 7b f4 ff ff       	call   8049470 <_ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_i@plt>
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
 8049ff5:	8b 44 24 20          	mov    0x20(%esp),%eax
 8049ff9:	8b 54 24 24          	mov    0x24(%esp),%edx
 8049ffd:	89 1c 24             	mov    %ebx,(%esp)
 804a000:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a004:	89 54 24 08          	mov    %edx,0x8(%esp)
 804a008:	e8 53 f3 ff ff       	call   8049360 <_ZNSo9_M_insertIyEERSoT_@plt>
 804a00d:	89 c6                	mov    %eax,%esi
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
 804a00f:	8b 00                	mov    (%eax),%eax
 804a011:	8b 40 f4             	mov    -0xc(%eax),%eax
 804a014:	8b 5c 06 7c          	mov    0x7c(%esi,%eax,1),%ebx

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 804a018:	85 db                	test   %ebx,%ebx
 804a01a:	74 46                	je     804a062 <_Z8dump_csvv+0x212>
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
 804a01c:	80 7b 1c 00          	cmpb   $0x0,0x1c(%ebx)
 804a020:	74 26                	je     804a048 <_Z8dump_csvv+0x1f8>
	  return _M_widen[static_cast<unsigned char>(__c)];
 804a022:	0f b6 43 27          	movzbl 0x27(%ebx),%eax
 804a026:	0f be c0             	movsbl %al,%eax
 804a029:	89 34 24             	mov    %esi,(%esp)
 804a02c:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a030:	e8 1b f4 ff ff       	call   8049450 <_ZNSo3putEc@plt>
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
 804a035:	89 04 24             	mov    %eax,(%esp)
 804a038:	e8 43 f3 ff ff       	call   8049380 <_ZNSo5flushEv@plt>
              << ", m=" << Config::CFG.elements
              << ", ops=" << Config::CFG.opcount << ", time=" << Config::CFG.totaltime
              << ", throughput="
              << (1000000000LL * Config::CFG.opcount) / (Config::CFG.totaltime)
              << std::endl;
}
 804a03d:	83 c4 3c             	add    $0x3c,%esp
 804a040:	5b                   	pop    %ebx
 804a041:	5e                   	pop    %esi
 804a042:	5f                   	pop    %edi
 804a043:	5d                   	pop    %ebp
 804a044:	c3                   	ret    
 804a045:	8d 76 00             	lea    0x0(%esi),%esi
	this->_M_widen_init();
 804a048:	89 1c 24             	mov    %ebx,(%esp)
 804a04b:	e8 30 f1 ff ff       	call   8049180 <_ZNKSt5ctypeIcE13_M_widen_initEv@plt>
	return this->do_widen(__c);
 804a050:	8b 03                	mov    (%ebx),%eax
 804a052:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
 804a059:	00 
 804a05a:	89 1c 24             	mov    %ebx,(%esp)
 804a05d:	ff 50 18             	call   *0x18(%eax)
 804a060:	eb c4                	jmp    804a026 <_Z8dump_csvv+0x1d6>
	__throw_bad_cast();
 804a062:	e8 c9 f0 ff ff       	call   8049130 <_ZSt16__throw_bad_castv@plt>
 804a067:	89 f6                	mov    %esi,%esi
 804a069:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804a070 <_Z5usagev>:

/**
 *  Print usage
 */
void usage()
{
 804a070:	83 ec 1c             	sub    $0x1c,%esp
    std::cerr << "Usage: project5a [flags]\n";
 804a073:	c7 44 24 04 1d cc 04 	movl   $0x804cc1d,0x4(%esp)
 804a07a:	08 
 804a07b:	c7 04 24 e0 e2 04 08 	movl   $0x804e2e0,(%esp)
 804a082:	e8 b9 f1 ff ff       	call   8049240 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
    std::cerr << "    -d: number of seconds to time (default 1)\n";
 804a087:	c7 44 24 04 60 cc 04 	movl   $0x804cc60,0x4(%esp)
 804a08e:	08 
 804a08f:	c7 04 24 e0 e2 04 08 	movl   $0x804e2e0,(%esp)
 804a096:	e8 a5 f1 ff ff       	call   8049240 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
    std::cerr << "    -c: number of operations to perform\n";
 804a09b:	c7 44 24 04 90 cc 04 	movl   $0x804cc90,0x4(%esp)
 804a0a2:	08 
 804a0a3:	c7 04 24 e0 e2 04 08 	movl   $0x804e2e0,(%esp)
 804a0aa:	e8 91 f1 ff ff       	call   8049240 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
    std::cerr << "    -p: number of threads (default 1)\n";
 804a0af:	c7 44 24 04 bc cc 04 	movl   $0x804ccbc,0x4(%esp)
 804a0b6:	08 
 804a0b7:	c7 04 24 e0 e2 04 08 	movl   $0x804e2e0,(%esp)
 804a0be:	e8 7d f1 ff ff       	call   8049240 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
    std::cerr << "    -r: % lookup operations (remainder split ins/rmv)\n";
 804a0c3:	c7 44 24 04 e4 cc 04 	movl   $0x804cce4,0x4(%esp)
 804a0ca:	08 
 804a0cb:	c7 04 24 e0 e2 04 08 	movl   $0x804e2e0,(%esp)
 804a0d2:	e8 69 f1 ff ff       	call   8049240 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
    std::cerr << "    -m: range of keys in data set\n";
 804a0d7:	c7 44 24 04 1c cd 04 	movl   $0x804cd1c,0x4(%esp)
 804a0de:	08 
 804a0df:	c7 04 24 e0 e2 04 08 	movl   $0x804e2e0,(%esp)
 804a0e6:	e8 55 f1 ff ff       	call   8049240 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
    std::cerr << "    -h: print help (this message)\n\n";
 804a0eb:	c7 44 24 04 40 cd 04 	movl   $0x804cd40,0x4(%esp)
 804a0f2:	08 
 804a0f3:	c7 04 24 e0 e2 04 08 	movl   $0x804e2e0,(%esp)
 804a0fa:	e8 41 f1 ff ff       	call   8049240 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
    exit(1);
 804a0ff:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a106:	e8 55 f3 ff ff       	call   8049460 <exit@plt>
 804a10b:	90                   	nop
 804a10c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a110 <_Z9parseargsiPPc>:

/**
 *  Parse command line arguments
 */
void parseargs(int argc, char** argv)
{
 804a110:	55                   	push   %ebp
 804a111:	57                   	push   %edi
          case 'p': Config::CFG.threads       = strtol(optarg, NULL, 10); break;
          case 'm': Config::CFG.elements      = strtol(optarg, NULL, 10); break;
	  case 'c': Config::CFG.opcount	      = strtol(optarg, NULL, 10); break;
          case 'r':
            Config::CFG.lookpct = strtol(optarg, NULL, 10);
            Config::CFG.inspct = (100 - Config::CFG.lookpct)/2 + strtol(optarg, NULL, 10);
 804a112:	bf 64 00 00 00       	mov    $0x64,%edi

/**
 *  Parse command line arguments
 */
void parseargs(int argc, char** argv)
{
 804a117:	56                   	push   %esi
 804a118:	53                   	push   %ebx
 804a119:	83 ec 1c             	sub    $0x1c,%esp
 804a11c:	8b 74 24 30          	mov    0x30(%esp),%esi
 804a120:	8b 5c 24 34          	mov    0x34(%esp),%ebx
 804a124:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    // parse the command-line options
    int opt;
    while ((opt = getopt(argc, argv, "d:p:hm:c:r:")) != -1) {
 804a128:	c7 44 24 08 37 cc 04 	movl   $0x804cc37,0x8(%esp)
 804a12f:	08 
 804a130:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804a134:	89 34 24             	mov    %esi,(%esp)
 804a137:	e8 64 f1 ff ff       	call   80492a0 <getopt@plt>
 804a13c:	83 f8 ff             	cmp    $0xffffffff,%eax
 804a13f:	0f 84 13 01 00 00    	je     804a258 <_Z9parseargsiPPc+0x148>
        switch(opt) {
 804a145:	83 e8 63             	sub    $0x63,%eax
 804a148:	83 f8 0f             	cmp    $0xf,%eax
 804a14b:	77 db                	ja     804a128 <_Z9parseargsiPPc+0x18>
 804a14d:	ff 24 85 64 cd 04 08 	jmp    *0x804cd64(,%eax,4)
 804a154:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
          case 'd': Config::CFG.duration      = strtol(optarg, NULL, 10); break;
          case 'p': Config::CFG.threads       = strtol(optarg, NULL, 10); break;
          case 'm': Config::CFG.elements      = strtol(optarg, NULL, 10); break;
	  case 'c': Config::CFG.opcount	      = strtol(optarg, NULL, 10); break;
          case 'r':
            Config::CFG.lookpct = strtol(optarg, NULL, 10);
 804a158:	a1 8c e4 04 08       	mov    0x804e48c,%eax
 804a15d:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
 804a164:	00 
 804a165:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a16c:	00 
 804a16d:	89 04 24             	mov    %eax,(%esp)
 804a170:	e8 db f0 ff ff       	call   8049250 <strtol@plt>
            Config::CFG.inspct = (100 - Config::CFG.lookpct)/2 + strtol(optarg, NULL, 10);
 804a175:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
 804a17c:	00 
 804a17d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a184:	00 
          case 'd': Config::CFG.duration      = strtol(optarg, NULL, 10); break;
          case 'p': Config::CFG.threads       = strtol(optarg, NULL, 10); break;
          case 'm': Config::CFG.elements      = strtol(optarg, NULL, 10); break;
	  case 'c': Config::CFG.opcount	      = strtol(optarg, NULL, 10); break;
          case 'r':
            Config::CFG.lookpct = strtol(optarg, NULL, 10);
 804a185:	89 c5                	mov    %eax,%ebp
 804a187:	a3 cc e4 04 08       	mov    %eax,0x804e4cc
            Config::CFG.inspct = (100 - Config::CFG.lookpct)/2 + strtol(optarg, NULL, 10);
 804a18c:	a1 8c e4 04 08       	mov    0x804e48c,%eax
 804a191:	89 04 24             	mov    %eax,(%esp)
 804a194:	e8 b7 f0 ff ff       	call   8049250 <strtol@plt>
 804a199:	89 fa                	mov    %edi,%edx
 804a19b:	29 ea                	sub    %ebp,%edx
 804a19d:	d1 ea                	shr    %edx
 804a19f:	01 c2                	add    %eax,%edx
 804a1a1:	89 15 d0 e4 04 08    	mov    %edx,0x804e4d0
            break;
 804a1a7:	e9 7c ff ff ff       	jmp    804a128 <_Z9parseargsiPPc+0x18>
 804a1ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    // parse the command-line options
    int opt;
    while ((opt = getopt(argc, argv, "d:p:hm:c:r:")) != -1) {
        switch(opt) {
          case 'd': Config::CFG.duration      = strtol(optarg, NULL, 10); break;
          case 'p': Config::CFG.threads       = strtol(optarg, NULL, 10); break;
 804a1b0:	a1 8c e4 04 08       	mov    0x804e48c,%eax
 804a1b5:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
 804a1bc:	00 
 804a1bd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a1c4:	00 
 804a1c5:	89 04 24             	mov    %eax,(%esp)
 804a1c8:	e8 83 f0 ff ff       	call   8049250 <strtol@plt>
 804a1cd:	a3 c4 e4 04 08       	mov    %eax,0x804e4c4
 804a1d2:	e9 51 ff ff ff       	jmp    804a128 <_Z9parseargsiPPc+0x18>
 804a1d7:	90                   	nop
          case 'm': Config::CFG.elements      = strtol(optarg, NULL, 10); break;
 804a1d8:	a1 8c e4 04 08       	mov    0x804e48c,%eax
 804a1dd:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
 804a1e4:	00 
 804a1e5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a1ec:	00 
 804a1ed:	89 04 24             	mov    %eax,(%esp)
 804a1f0:	e8 5b f0 ff ff       	call   8049250 <strtol@plt>
 804a1f5:	a3 c8 e4 04 08       	mov    %eax,0x804e4c8
 804a1fa:	e9 29 ff ff ff       	jmp    804a128 <_Z9parseargsiPPc+0x18>
 804a1ff:	90                   	nop
          case 'r':
            Config::CFG.lookpct = strtol(optarg, NULL, 10);
            Config::CFG.inspct = (100 - Config::CFG.lookpct)/2 + strtol(optarg, NULL, 10);
            break;
          case 'h':
            usage();
 804a200:	e8 6b fe ff ff       	call   804a070 <_Z5usagev>
 804a205:	8d 76 00             	lea    0x0(%esi),%esi
{
    // parse the command-line options
    int opt;
    while ((opt = getopt(argc, argv, "d:p:hm:c:r:")) != -1) {
        switch(opt) {
          case 'd': Config::CFG.duration      = strtol(optarg, NULL, 10); break;
 804a208:	a1 8c e4 04 08       	mov    0x804e48c,%eax
 804a20d:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
 804a214:	00 
 804a215:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a21c:	00 
 804a21d:	89 04 24             	mov    %eax,(%esp)
 804a220:	e8 2b f0 ff ff       	call   8049250 <strtol@plt>
 804a225:	a3 c0 e4 04 08       	mov    %eax,0x804e4c0
 804a22a:	e9 f9 fe ff ff       	jmp    804a128 <_Z9parseargsiPPc+0x18>
 804a22f:	90                   	nop
          case 'p': Config::CFG.threads       = strtol(optarg, NULL, 10); break;
          case 'm': Config::CFG.elements      = strtol(optarg, NULL, 10); break;
	  case 'c': Config::CFG.opcount	      = strtol(optarg, NULL, 10); break;
 804a230:	a1 8c e4 04 08       	mov    0x804e48c,%eax
 804a235:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
 804a23c:	00 
 804a23d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a244:	00 
 804a245:	89 04 24             	mov    %eax,(%esp)
 804a248:	e8 03 f0 ff ff       	call   8049250 <strtol@plt>
 804a24d:	a3 e0 e4 04 08       	mov    %eax,0x804e4e0
 804a252:	e9 d1 fe ff ff       	jmp    804a128 <_Z9parseargsiPPc+0x18>
 804a257:	90                   	nop
            break;
          case 'h':
            usage();
        }
    }
}
 804a258:	83 c4 1c             	add    $0x1c,%esp
 804a25b:	5b                   	pop    %ebx
 804a25c:	5e                   	pop    %esi
 804a25d:	5f                   	pop    %edi
 804a25e:	5d                   	pop    %ebp
 804a25f:	c3                   	ret    

0804a260 <_Z14getElapsedTimev>:

/**
 *  Helper function for computing time in a cross-platform way
 */
long long getElapsedTime()
{
 804a260:	53                   	push   %ebx
 804a261:	83 ec 28             	sub    $0x28,%esp
    struct timespec t;
    clock_gettime(CLOCK_REALTIME, &t);
 804a264:	8d 44 24 18          	lea    0x18(%esp),%eax
 804a268:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a26c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a273:	e8 d8 f0 ff ff       	call   8049350 <clock_gettime@plt>
    uint64_t tt = (((long long)t.tv_sec) * 1000000000L) + ((long long)t.tv_nsec);
 804a278:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
 804a27c:	b8 00 ca 9a 3b       	mov    $0x3b9aca00,%eax
 804a281:	f7 6c 24 18          	imull  0x18(%esp)
 804a285:	89 cb                	mov    %ecx,%ebx
 804a287:	c1 fb 1f             	sar    $0x1f,%ebx
 804a28a:	01 c8                	add    %ecx,%eax
 804a28c:	11 da                	adc    %ebx,%edx
    return tt;
}
 804a28e:	83 c4 28             	add    $0x28,%esp
 804a291:	5b                   	pop    %ebx
 804a292:	c3                   	ret    
 804a293:	66 90                	xchg   %ax,%ax
 804a295:	66 90                	xchg   %ax,%ax
 804a297:	66 90                	xchg   %ax,%ax
 804a299:	66 90                	xchg   %ax,%ax
 804a29b:	66 90                	xchg   %ax,%ax
 804a29d:	66 90                	xchg   %ax,%ax
 804a29f:	90                   	nop

0804a2a0 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE10_M_destroyEv>:
      virtual void
      _M_dispose() noexcept = 0;
      
      // Called when _M_weak_count drops to zero.
      virtual void
      _M_destroy() noexcept
 804a2a0:	8b 44 24 04          	mov    0x4(%esp),%eax
      { delete this; }
 804a2a4:	85 c0                	test   %eax,%eax
 804a2a6:	74 08                	je     804a2b0 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE10_M_destroyEv+0x10>
 804a2a8:	8b 10                	mov    (%eax),%edx
 804a2aa:	8b 42 04             	mov    0x4(%edx),%eax
 804a2ad:	ff e0                	jmp    *%eax
 804a2af:	90                   	nop
 804a2b0:	f3 c3                	repz ret 
 804a2b2:	66 90                	xchg   %ax,%ax
 804a2b4:	66 90                	xchg   %ax,%ax
 804a2b6:	66 90                	xchg   %ax,%ax
 804a2b8:	66 90                	xchg   %ax,%ax
 804a2ba:	66 90                	xchg   %ax,%ax
 804a2bc:	66 90                	xchg   %ax,%ax
 804a2be:	66 90                	xchg   %ax,%ax

0804a2c0 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EED1Ev>:
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
      
      virtual
      ~_Sp_counted_base() noexcept
 804a2c0:	f3 c3                	repz ret 
 804a2c2:	66 90                	xchg   %ax,%ax
 804a2c4:	66 90                	xchg   %ax,%ax
 804a2c6:	66 90                	xchg   %ax,%ax
 804a2c8:	66 90                	xchg   %ax,%ax
 804a2ca:	66 90                	xchg   %ax,%ax
 804a2cc:	66 90                	xchg   %ax,%ax
 804a2ce:	66 90                	xchg   %ax,%ax

0804a2d0 <_ZNSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS7_ELN9__gnu_cxx12_Lock_policyE2EED1Ev>:
	  // 2070.  allocate_shared should use allocator_traits<A>::construct
	  allocator_traits<_Alloc>::construct(__a, _M_ptr(),
	      std::forward<_Args>(__args)...); // might throw
	}

      ~_Sp_counted_ptr_inplace() noexcept { }
 804a2d0:	f3 c3                	repz ret 
 804a2d2:	66 90                	xchg   %ax,%ax
 804a2d4:	66 90                	xchg   %ax,%ax
 804a2d6:	66 90                	xchg   %ax,%ax
 804a2d8:	66 90                	xchg   %ax,%ax
 804a2da:	66 90                	xchg   %ax,%ax
 804a2dc:	66 90                	xchg   %ax,%ax
 804a2de:	66 90                	xchg   %ax,%ax

0804a2e0 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EED0Ev>:
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
      
      virtual
      ~_Sp_counted_base() noexcept
      { }
 804a2e0:	e9 8b ee ff ff       	jmp    8049170 <_ZdlPv@plt>
 804a2e5:	66 90                	xchg   %ax,%ax
 804a2e7:	66 90                	xchg   %ax,%ax
 804a2e9:	66 90                	xchg   %ax,%ax
 804a2eb:	66 90                	xchg   %ax,%ax
 804a2ed:	66 90                	xchg   %ax,%ax
 804a2ef:	90                   	nop

0804a2f0 <_ZNSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS7_ELN9__gnu_cxx12_Lock_policyE2EED0Ev>:
	  // 2070.  allocate_shared should use allocator_traits<A>::construct
	  allocator_traits<_Alloc>::construct(__a, _M_ptr(),
	      std::forward<_Args>(__args)...); // might throw
	}

      ~_Sp_counted_ptr_inplace() noexcept { }
 804a2f0:	e9 7b ee ff ff       	jmp    8049170 <_ZdlPv@plt>
 804a2f5:	66 90                	xchg   %ax,%ax
 804a2f7:	66 90                	xchg   %ax,%ax
 804a2f9:	66 90                	xchg   %ax,%ax
 804a2fb:	66 90                	xchg   %ax,%ax
 804a2fd:	66 90                	xchg   %ax,%ax
 804a2ff:	90                   	nop

0804a300 <_ZNSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS7_ELN9__gnu_cxx12_Lock_policyE2EE10_M_destroyEv>:
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
 804a300:	e9 6b ee ff ff       	jmp    8049170 <_ZdlPv@plt>
 804a305:	66 90                	xchg   %ax,%ax
 804a307:	66 90                	xchg   %ax,%ax
 804a309:	66 90                	xchg   %ax,%ax
 804a30b:	66 90                	xchg   %ax,%ax
 804a30d:	66 90                	xchg   %ax,%ax
 804a30f:	90                   	nop

0804a310 <_ZNSt6thread10_Impl_baseD1Ev>:
	operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id);
    };

    // Simple base type that the templatized, derived class containing
    // an arbitrary functor can be converted to and called.
    struct _Impl_base
 804a310:	53                   	push   %ebx
 804a311:	83 ec 28             	sub    $0x28,%esp
 804a314:	8b 44 24 30          	mov    0x30(%esp),%eax
      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
      explicit __shared_count(const __weak_count<_Lp>& __r);

      ~__shared_count() noexcept
      {
	if (_M_pi != 0)
 804a318:	8b 58 08             	mov    0x8(%eax),%ebx
 804a31b:	c7 00 38 cf 04 08    	movl   $0x804cf38,(%eax)
 804a321:	85 db                	test   %ebx,%ebx
 804a323:	74 17                	je     804a33c <_ZNSt6thread10_Impl_baseD1Ev+0x2c>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 804a325:	e8 16 f9 ff ff       	call   8049c40 <_ZL18__gthread_active_pv>
 804a32a:	85 c0                	test   %eax,%eax
 804a32c:	75 1a                	jne    804a348 <_ZNSt6thread10_Impl_baseD1Ev+0x38>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 804a32e:	8b 53 04             	mov    0x4(%ebx),%edx
    *__mem += __val;
 804a331:	8d 4a ff             	lea    -0x1(%edx),%ecx
      void
      _M_release() noexcept
      {
        // Be race-detector-friendly.  For more info see bits/c++config.
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
 804a334:	83 fa 01             	cmp    $0x1,%edx
 804a337:	89 4b 04             	mov    %ecx,0x4(%ebx)
 804a33a:	74 1b                	je     804a357 <_ZNSt6thread10_Impl_baseD1Ev+0x47>
 804a33c:	83 c4 28             	add    $0x28,%esp
 804a33f:	5b                   	pop    %ebx
 804a340:	c3                   	ret    
 804a341:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 804a348:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 804a34d:	f0 0f c1 53 04       	lock xadd %edx,0x4(%ebx)
 804a352:	83 fa 01             	cmp    $0x1,%edx
 804a355:	75 e5                	jne    804a33c <_ZNSt6thread10_Impl_baseD1Ev+0x2c>
	  {
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
	    _M_dispose();
 804a357:	8b 13                	mov    (%ebx),%edx
 804a359:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 804a35d:	89 1c 24             	mov    %ebx,(%esp)
 804a360:	ff 52 08             	call   *0x8(%edx)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 804a363:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804a367:	85 c0                	test   %eax,%eax
 804a369:	75 1d                	jne    804a388 <_ZNSt6thread10_Impl_baseD1Ev+0x78>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 804a36b:	8b 43 08             	mov    0x8(%ebx),%eax
    *__mem += __val;
 804a36e:	8d 50 ff             	lea    -0x1(%eax),%edx
 804a371:	89 53 08             	mov    %edx,0x8(%ebx)
	        _GLIBCXX_WRITE_MEM_BARRIER;
	      }

            // Be race-detector-friendly.  For more info see bits/c++config.
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
	    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
 804a374:	83 f8 01             	cmp    $0x1,%eax
 804a377:	75 c3                	jne    804a33c <_ZNSt6thread10_Impl_baseD1Ev+0x2c>
						       -1) == 1)
              {
                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
	        _M_destroy();
 804a379:	8b 03                	mov    (%ebx),%eax
 804a37b:	89 5c 24 30          	mov    %ebx,0x30(%esp)
 804a37f:	8b 40 0c             	mov    0xc(%eax),%eax
 804a382:	83 c4 28             	add    $0x28,%esp
 804a385:	5b                   	pop    %ebx
 804a386:	ff e0                	jmp    *%eax
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 804a388:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804a38d:	f0 0f c1 43 08       	lock xadd %eax,0x8(%ebx)
 804a392:	eb e0                	jmp    804a374 <_ZNSt6thread10_Impl_baseD1Ev+0x64>
 804a394:	66 90                	xchg   %ax,%ax
 804a396:	66 90                	xchg   %ax,%ax
 804a398:	66 90                	xchg   %ax,%ax
 804a39a:	66 90                	xchg   %ax,%ax
 804a39c:	66 90                	xchg   %ax,%ax
 804a39e:	66 90                	xchg   %ax,%ax

0804a3a0 <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED1Ev>:

      virtual void _M_run() = 0;
    };

    template<typename _Callable>
      struct _Impl : public _Impl_base
 804a3a0:	53                   	push   %ebx
 804a3a1:	83 ec 28             	sub    $0x28,%esp
 804a3a4:	8b 44 24 30          	mov    0x30(%esp),%eax
      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
      explicit __shared_count(const __weak_count<_Lp>& __r);

      ~__shared_count() noexcept
      {
	if (_M_pi != 0)
 804a3a8:	8b 58 08             	mov    0x8(%eax),%ebx
	operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id);
    };

    // Simple base type that the templatized, derived class containing
    // an arbitrary functor can be converted to and called.
    struct _Impl_base
 804a3ab:	c7 00 38 cf 04 08    	movl   $0x804cf38,(%eax)
 804a3b1:	85 db                	test   %ebx,%ebx
 804a3b3:	74 17                	je     804a3cc <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED1Ev+0x2c>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 804a3b5:	e8 86 f8 ff ff       	call   8049c40 <_ZL18__gthread_active_pv>
 804a3ba:	85 c0                	test   %eax,%eax
 804a3bc:	75 1a                	jne    804a3d8 <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED1Ev+0x38>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 804a3be:	8b 53 04             	mov    0x4(%ebx),%edx
    *__mem += __val;
 804a3c1:	8d 4a ff             	lea    -0x1(%edx),%ecx
      void
      _M_release() noexcept
      {
        // Be race-detector-friendly.  For more info see bits/c++config.
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
 804a3c4:	83 fa 01             	cmp    $0x1,%edx
 804a3c7:	89 4b 04             	mov    %ecx,0x4(%ebx)
 804a3ca:	74 1b                	je     804a3e7 <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED1Ev+0x47>

      virtual void _M_run() = 0;
    };

    template<typename _Callable>
      struct _Impl : public _Impl_base
 804a3cc:	83 c4 28             	add    $0x28,%esp
 804a3cf:	5b                   	pop    %ebx
 804a3d0:	c3                   	ret    
 804a3d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 804a3d8:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 804a3dd:	f0 0f c1 53 04       	lock xadd %edx,0x4(%ebx)
 804a3e2:	83 fa 01             	cmp    $0x1,%edx
 804a3e5:	75 e5                	jne    804a3cc <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED1Ev+0x2c>
	  {
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
	    _M_dispose();
 804a3e7:	8b 13                	mov    (%ebx),%edx
 804a3e9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 804a3ed:	89 1c 24             	mov    %ebx,(%esp)
 804a3f0:	ff 52 08             	call   *0x8(%edx)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 804a3f3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804a3f7:	85 c0                	test   %eax,%eax
 804a3f9:	75 1d                	jne    804a418 <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED1Ev+0x78>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 804a3fb:	8b 43 08             	mov    0x8(%ebx),%eax
    *__mem += __val;
 804a3fe:	8d 50 ff             	lea    -0x1(%eax),%edx
 804a401:	89 53 08             	mov    %edx,0x8(%ebx)
	        _GLIBCXX_WRITE_MEM_BARRIER;
	      }

            // Be race-detector-friendly.  For more info see bits/c++config.
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
	    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
 804a404:	83 f8 01             	cmp    $0x1,%eax
 804a407:	75 c3                	jne    804a3cc <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED1Ev+0x2c>
						       -1) == 1)
              {
                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
	        _M_destroy();
 804a409:	8b 03                	mov    (%ebx),%eax
 804a40b:	89 5c 24 30          	mov    %ebx,0x30(%esp)
 804a40f:	8b 40 0c             	mov    0xc(%eax),%eax
 804a412:	83 c4 28             	add    $0x28,%esp
 804a415:	5b                   	pop    %ebx
 804a416:	ff e0                	jmp    *%eax
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 804a418:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804a41d:	f0 0f c1 43 08       	lock xadd %eax,0x8(%ebx)
 804a422:	eb e0                	jmp    804a404 <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED1Ev+0x64>
 804a424:	66 90                	xchg   %ax,%ax
 804a426:	66 90                	xchg   %ax,%ax
 804a428:	66 90                	xchg   %ax,%ax
 804a42a:	66 90                	xchg   %ax,%ax
 804a42c:	66 90                	xchg   %ax,%ax
 804a42e:	66 90                	xchg   %ax,%ax

0804a430 <_ZNSt6thread10_Impl_baseD0Ev>:
	operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id);
    };

    // Simple base type that the templatized, derived class containing
    // an arbitrary functor can be converted to and called.
    struct _Impl_base
 804a430:	56                   	push   %esi
 804a431:	53                   	push   %ebx
 804a432:	83 ec 24             	sub    $0x24,%esp
 804a435:	8b 74 24 30          	mov    0x30(%esp),%esi
      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
      explicit __shared_count(const __weak_count<_Lp>& __r);

      ~__shared_count() noexcept
      {
	if (_M_pi != 0)
 804a439:	8b 5e 08             	mov    0x8(%esi),%ebx
 804a43c:	c7 06 38 cf 04 08    	movl   $0x804cf38,(%esi)
 804a442:	85 db                	test   %ebx,%ebx
 804a444:	74 17                	je     804a45d <_ZNSt6thread10_Impl_baseD0Ev+0x2d>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 804a446:	e8 f5 f7 ff ff       	call   8049c40 <_ZL18__gthread_active_pv>
 804a44b:	85 c0                	test   %eax,%eax
 804a44d:	75 21                	jne    804a470 <_ZNSt6thread10_Impl_baseD0Ev+0x40>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 804a44f:	8b 53 04             	mov    0x4(%ebx),%edx
    *__mem += __val;
 804a452:	8d 4a ff             	lea    -0x1(%edx),%ecx
      void
      _M_release() noexcept
      {
        // Be race-detector-friendly.  For more info see bits/c++config.
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
 804a455:	83 fa 01             	cmp    $0x1,%edx
 804a458:	89 4b 04             	mov    %ecx,0x4(%ebx)
 804a45b:	74 22                	je     804a47f <_ZNSt6thread10_Impl_baseD0Ev+0x4f>
 804a45d:	89 74 24 30          	mov    %esi,0x30(%esp)
 804a461:	83 c4 24             	add    $0x24,%esp
 804a464:	5b                   	pop    %ebx
 804a465:	5e                   	pop    %esi
 804a466:	e9 05 ed ff ff       	jmp    8049170 <_ZdlPv@plt>
 804a46b:	90                   	nop
 804a46c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 804a470:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 804a475:	f0 0f c1 53 04       	lock xadd %edx,0x4(%ebx)
 804a47a:	83 fa 01             	cmp    $0x1,%edx
 804a47d:	75 de                	jne    804a45d <_ZNSt6thread10_Impl_baseD0Ev+0x2d>
	  {
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
	    _M_dispose();
 804a47f:	8b 13                	mov    (%ebx),%edx
 804a481:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 804a485:	89 1c 24             	mov    %ebx,(%esp)
 804a488:	ff 52 08             	call   *0x8(%edx)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 804a48b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804a48f:	85 c0                	test   %eax,%eax
 804a491:	75 1d                	jne    804a4b0 <_ZNSt6thread10_Impl_baseD0Ev+0x80>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 804a493:	8b 43 08             	mov    0x8(%ebx),%eax
    *__mem += __val;
 804a496:	8d 50 ff             	lea    -0x1(%eax),%edx
 804a499:	89 53 08             	mov    %edx,0x8(%ebx)
	        _GLIBCXX_WRITE_MEM_BARRIER;
	      }

            // Be race-detector-friendly.  For more info see bits/c++config.
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
	    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
 804a49c:	83 f8 01             	cmp    $0x1,%eax
 804a49f:	75 bc                	jne    804a45d <_ZNSt6thread10_Impl_baseD0Ev+0x2d>
						       -1) == 1)
              {
                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
	        _M_destroy();
 804a4a1:	8b 03                	mov    (%ebx),%eax
 804a4a3:	89 1c 24             	mov    %ebx,(%esp)
 804a4a6:	ff 50 0c             	call   *0xc(%eax)
 804a4a9:	eb b2                	jmp    804a45d <_ZNSt6thread10_Impl_baseD0Ev+0x2d>
 804a4ab:	90                   	nop
 804a4ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 804a4b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804a4b5:	f0 0f c1 43 08       	lock xadd %eax,0x8(%ebx)
 804a4ba:	eb e0                	jmp    804a49c <_ZNSt6thread10_Impl_baseD0Ev+0x6c>
 804a4bc:	66 90                	xchg   %ax,%ax
 804a4be:	66 90                	xchg   %ax,%ax

0804a4c0 <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED0Ev>:

      virtual void _M_run() = 0;
    };

    template<typename _Callable>
      struct _Impl : public _Impl_base
 804a4c0:	56                   	push   %esi
 804a4c1:	53                   	push   %ebx
 804a4c2:	83 ec 24             	sub    $0x24,%esp
 804a4c5:	8b 74 24 30          	mov    0x30(%esp),%esi
      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.
      explicit __shared_count(const __weak_count<_Lp>& __r);

      ~__shared_count() noexcept
      {
	if (_M_pi != 0)
 804a4c9:	8b 5e 08             	mov    0x8(%esi),%ebx
	operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id);
    };

    // Simple base type that the templatized, derived class containing
    // an arbitrary functor can be converted to and called.
    struct _Impl_base
 804a4cc:	c7 06 38 cf 04 08    	movl   $0x804cf38,(%esi)
 804a4d2:	85 db                	test   %ebx,%ebx
 804a4d4:	74 17                	je     804a4ed <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED0Ev+0x2d>
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 804a4d6:	e8 65 f7 ff ff       	call   8049c40 <_ZL18__gthread_active_pv>
 804a4db:	85 c0                	test   %eax,%eax
 804a4dd:	75 21                	jne    804a500 <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED0Ev+0x40>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 804a4df:	8b 53 04             	mov    0x4(%ebx),%edx
    *__mem += __val;
 804a4e2:	8d 4a ff             	lea    -0x1(%edx),%ecx
      void
      _M_release() noexcept
      {
        // Be race-detector-friendly.  For more info see bits/c++config.
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
 804a4e5:	83 fa 01             	cmp    $0x1,%edx
 804a4e8:	89 4b 04             	mov    %ecx,0x4(%ebx)
 804a4eb:	74 22                	je     804a50f <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED0Ev+0x4f>

      virtual void _M_run() = 0;
    };

    template<typename _Callable>
      struct _Impl : public _Impl_base
 804a4ed:	89 74 24 30          	mov    %esi,0x30(%esp)
 804a4f1:	83 c4 24             	add    $0x24,%esp
 804a4f4:	5b                   	pop    %ebx
 804a4f5:	5e                   	pop    %esi
 804a4f6:	e9 75 ec ff ff       	jmp    8049170 <_ZdlPv@plt>
 804a4fb:	90                   	nop
 804a4fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 804a500:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 804a505:	f0 0f c1 53 04       	lock xadd %edx,0x4(%ebx)
 804a50a:	83 fa 01             	cmp    $0x1,%edx
 804a50d:	75 de                	jne    804a4ed <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED0Ev+0x2d>
	  {
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
	    _M_dispose();
 804a50f:	8b 13                	mov    (%ebx),%edx
 804a511:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 804a515:	89 1c 24             	mov    %ebx,(%esp)
 804a518:	ff 52 08             	call   *0x8(%edx)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 804a51b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804a51f:	85 c0                	test   %eax,%eax
 804a521:	75 1d                	jne    804a540 <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED0Ev+0x80>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 804a523:	8b 43 08             	mov    0x8(%ebx),%eax
    *__mem += __val;
 804a526:	8d 50 ff             	lea    -0x1(%eax),%edx
 804a529:	89 53 08             	mov    %edx,0x8(%ebx)
	        _GLIBCXX_WRITE_MEM_BARRIER;
	      }

            // Be race-detector-friendly.  For more info see bits/c++config.
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
	    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
 804a52c:	83 f8 01             	cmp    $0x1,%eax
 804a52f:	75 bc                	jne    804a4ed <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED0Ev+0x2d>
						       -1) == 1)
              {
                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
	        _M_destroy();
 804a531:	8b 03                	mov    (%ebx),%eax
 804a533:	89 1c 24             	mov    %ebx,(%esp)
 804a536:	ff 50 0c             	call   *0xc(%eax)
 804a539:	eb b2                	jmp    804a4ed <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED0Ev+0x2d>
 804a53b:	90                   	nop
 804a53c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 804a540:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804a545:	f0 0f c1 43 08       	lock xadd %eax,0x8(%ebx)
 804a54a:	eb e0                	jmp    804a52c <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEED0Ev+0x6c>
 804a54c:	66 90                	xchg   %ax,%ax
 804a54e:	66 90                	xchg   %ax,%ax

0804a550 <_ZStorSt12_Ios_IostateS_>:
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _GLIBCXX_CONSTEXPR _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }
 804a550:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a554:	0b 44 24 04          	or     0x4(%esp),%eax
 804a558:	c3                   	ret    
 804a559:	66 90                	xchg   %ax,%ax
 804a55b:	66 90                	xchg   %ax,%ax
 804a55d:	66 90                	xchg   %ax,%ax
 804a55f:	90                   	nop

0804a560 <_ZSt4moveIRNSt6thread2idEEONSt16remove_referenceIT_E4typeEOS4_>:
   *  @return The parameter cast to an rvalue-reference to allow moving it.
  */
  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 804a560:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a564:	c3                   	ret    
 804a565:	66 90                	xchg   %ax,%ax
 804a567:	66 90                	xchg   %ax,%ax
 804a569:	66 90                	xchg   %ax,%ax
 804a56b:	66 90                	xchg   %ax,%ax
 804a56d:	66 90                	xchg   %ax,%ax
 804a56f:	90                   	nop

0804a570 <_ZSt7forwardIRFvjEEOT_RNSt16remove_referenceIS2_E4typeE>:
   *  This function is used to implement "perfect forwarding".
   */
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }
 804a570:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a574:	c3                   	ret    
 804a575:	66 90                	xchg   %ax,%ax
 804a577:	66 90                	xchg   %ax,%ax
 804a579:	66 90                	xchg   %ax,%ax
 804a57b:	66 90                	xchg   %ax,%ax
 804a57d:	66 90                	xchg   %ax,%ax
 804a57f:	90                   	nop

0804a580 <_ZSt7forwardIRjEOT_RNSt16remove_referenceIS1_E4typeE>:
 804a580:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a584:	c3                   	ret    
 804a585:	66 90                	xchg   %ax,%ax
 804a587:	66 90                	xchg   %ax,%ax
 804a589:	66 90                	xchg   %ax,%ax
 804a58b:	66 90                	xchg   %ax,%ax
 804a58d:	66 90                	xchg   %ax,%ax
 804a58f:	90                   	nop

0804a590 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE10_M_releaseEv>:
  
      void
      _M_add_ref_lock();
      
      void
      _M_release() noexcept
 804a590:	53                   	push   %ebx
 804a591:	83 ec 28             	sub    $0x28,%esp
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 804a594:	e8 a7 f6 ff ff       	call   8049c40 <_ZL18__gthread_active_pv>
 804a599:	8b 5c 24 30          	mov    0x30(%esp),%ebx
 804a59d:	85 c0                	test   %eax,%eax
 804a59f:	75 17                	jne    804a5b8 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE10_M_releaseEv+0x28>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 804a5a1:	8b 53 04             	mov    0x4(%ebx),%edx
    *__mem += __val;
 804a5a4:	8d 4a ff             	lea    -0x1(%edx),%ecx
      {
        // Be race-detector-friendly.  For more info see bits/c++config.
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
 804a5a7:	83 fa 01             	cmp    $0x1,%edx
 804a5aa:	89 4b 04             	mov    %ecx,0x4(%ebx)
 804a5ad:	74 18                	je     804a5c7 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE10_M_releaseEv+0x37>
              {
                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
	        _M_destroy();
              }
	  }
      }
 804a5af:	83 c4 28             	add    $0x28,%esp
 804a5b2:	5b                   	pop    %ebx
 804a5b3:	c3                   	ret    
 804a5b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 804a5b8:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 804a5bd:	f0 0f c1 53 04       	lock xadd %edx,0x4(%ebx)
      void
      _M_release() noexcept
      {
        // Be race-detector-friendly.  For more info see bits/c++config.
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
 804a5c2:	83 fa 01             	cmp    $0x1,%edx
 804a5c5:	75 e8                	jne    804a5af <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE10_M_releaseEv+0x1f>
	  {
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
	    _M_dispose();
 804a5c7:	8b 13                	mov    (%ebx),%edx
 804a5c9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 804a5cd:	89 1c 24             	mov    %ebx,(%esp)
 804a5d0:	ff 52 08             	call   *0x8(%edx)
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
 804a5d3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804a5d7:	85 c0                	test   %eax,%eax
 804a5d9:	75 1d                	jne    804a5f8 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE10_M_releaseEv+0x68>
#endif

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
 804a5db:	8b 43 08             	mov    0x8(%ebx),%eax
    *__mem += __val;
 804a5de:	8d 50 ff             	lea    -0x1(%eax),%edx
 804a5e1:	89 53 08             	mov    %edx,0x8(%ebx)
	        _GLIBCXX_WRITE_MEM_BARRIER;
	      }

            // Be race-detector-friendly.  For more info see bits/c++config.
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
	    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
 804a5e4:	83 f8 01             	cmp    $0x1,%eax
 804a5e7:	75 c6                	jne    804a5af <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE10_M_releaseEv+0x1f>
						       -1) == 1)
              {
                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
	        _M_destroy();
 804a5e9:	8b 03                	mov    (%ebx),%eax
 804a5eb:	89 5c 24 30          	mov    %ebx,0x30(%esp)
 804a5ef:	8b 40 0c             	mov    0xc(%eax),%eax
              }
	  }
      }
 804a5f2:	83 c4 28             	add    $0x28,%esp
 804a5f5:	5b                   	pop    %ebx
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
	    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
						       -1) == 1)
              {
                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
	        _M_destroy();
 804a5f6:	ff e0                	jmp    *%eax
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
 804a5f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804a5fd:	f0 0f c1 43 08       	lock xadd %eax,0x8(%ebx)
 804a602:	eb e0                	jmp    804a5e4 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE10_M_releaseEv+0x54>
 804a604:	66 90                	xchg   %ax,%ax
 804a606:	66 90                	xchg   %ax,%ax
 804a608:	66 90                	xchg   %ax,%ax
 804a60a:	66 90                	xchg   %ax,%ax
 804a60c:	66 90                	xchg   %ax,%ax
 804a60e:	66 90                	xchg   %ax,%ax

0804a610 <_ZNSt11_Tuple_implILj1EIjEE7_M_headERS0_>:

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&  
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
 804a610:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a614:	c3                   	ret    
 804a615:	66 90                	xchg   %ax,%ax
 804a617:	66 90                	xchg   %ax,%ax
 804a619:	66 90                	xchg   %ax,%ax
 804a61b:	66 90                	xchg   %ax,%ax
 804a61d:	66 90                	xchg   %ax,%ax
 804a61f:	90                   	nop

0804a620 <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>:
 804a620:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a624:	c3                   	ret    
 804a625:	66 90                	xchg   %ax,%ax
 804a627:	66 90                	xchg   %ax,%ax
 804a629:	66 90                	xchg   %ax,%ax
 804a62b:	66 90                	xchg   %ax,%ax
 804a62d:	66 90                	xchg   %ax,%ax
 804a62f:	90                   	nop

0804a630 <_ZNSt11_Tuple_implILj0EIPFvjEjEE7_M_tailERS2_>:

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }
 804a630:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a634:	c3                   	ret    
 804a635:	66 90                	xchg   %ax,%ax
 804a637:	66 90                	xchg   %ax,%ax
 804a639:	66 90                	xchg   %ax,%ax
 804a63b:	66 90                	xchg   %ax,%ax
 804a63d:	66 90                	xchg   %ax,%ax
 804a63f:	90                   	nop

0804a640 <_ZSt4moveIRSt11_Tuple_implILj1EIjEEEONSt16remove_referenceIT_E4typeEOS4_>:
   *  @return The parameter cast to an rvalue-reference to allow moving it.
  */
  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 804a640:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a644:	c3                   	ret    
 804a645:	66 90                	xchg   %ax,%ax
 804a647:	66 90                	xchg   %ax,%ax
 804a649:	66 90                	xchg   %ax,%ax
 804a64b:	66 90                	xchg   %ax,%ax
 804a64d:	66 90                	xchg   %ax,%ax
 804a64f:	90                   	nop

0804a650 <_ZNSt11_Tuple_implILj0EIPFvjEjEE7_M_headERS2_>:
      template<typename _Alloc, typename _UHead>
	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
	: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
 804a650:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a654:	83 c0 04             	add    $0x4,%eax

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&  
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
 804a657:	c3                   	ret    
 804a658:	66 90                	xchg   %ax,%ax
 804a65a:	66 90                	xchg   %ax,%ax
 804a65c:	66 90                	xchg   %ax,%ax
 804a65e:	66 90                	xchg   %ax,%ax

0804a660 <_ZSt7forwardIPFvjEEOT_RNSt16remove_referenceIS2_E4typeE>:
   *  This function is used to implement "perfect forwarding".
   */
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }
 804a660:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a664:	c3                   	ret    
 804a665:	66 90                	xchg   %ax,%ax
 804a667:	66 90                	xchg   %ax,%ax
 804a669:	66 90                	xchg   %ax,%ax
 804a66b:	66 90                	xchg   %ax,%ax
 804a66d:	66 90                	xchg   %ax,%ax
 804a66f:	90                   	nop

0804a670 <_ZSt7forwardISt12_Bind_simpleIFPFvjEjEEEOT_RNSt16remove_referenceIS5_E4typeE>:
 804a670:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a674:	c3                   	ret    
 804a675:	66 90                	xchg   %ax,%ax
 804a677:	66 90                	xchg   %ax,%ax
 804a679:	66 90                	xchg   %ax,%ax
 804a67b:	66 90                	xchg   %ax,%ax
 804a67d:	66 90                	xchg   %ax,%ax
 804a67f:	90                   	nop

0804a680 <_ZSt4moveIRSt10shared_ptrINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEEEEONSt16remove_referenceIT_E4typeEOSC_>:
   *  @return The parameter cast to an rvalue-reference to allow moving it.
  */
  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
 804a680:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a684:	c3                   	ret    
 804a685:	66 90                	xchg   %ax,%ax
 804a687:	66 90                	xchg   %ax,%ax
 804a689:	66 90                	xchg   %ax,%ax
 804a68b:	66 90                	xchg   %ax,%ax
 804a68d:	66 90                	xchg   %ax,%ax
 804a68f:	90                   	nop

0804a690 <_ZNSt26_Maybe_wrap_member_pointerIPFvjEE9__do_wrapEOS1_>:
      __do_wrap(const _Tp& __x)
      { return __x; }

      static _Tp&&
      __do_wrap(_Tp&& __x)
      { return static_cast<_Tp&&>(__x); }
 804a690:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a694:	c3                   	ret    
 804a695:	66 90                	xchg   %ax,%ax
 804a697:	66 90                	xchg   %ax,%ax
 804a699:	66 90                	xchg   %ax,%ax
 804a69b:	66 90                	xchg   %ax,%ax
 804a69d:	66 90                	xchg   %ax,%ax
 804a69f:	90                   	nop

0804a6a0 <_ZSt4moveIRPFvjEEONSt16remove_referenceIT_E4typeEOS4_>:
 804a6a0:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a6a4:	c3                   	ret    
 804a6a5:	66 90                	xchg   %ax,%ax
 804a6a7:	66 90                	xchg   %ax,%ax
 804a6a9:	66 90                	xchg   %ax,%ax
 804a6ab:	66 90                	xchg   %ax,%ax
 804a6ad:	66 90                	xchg   %ax,%ax
 804a6af:	90                   	nop

0804a6b0 <_ZSt4moveIRKSaINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEEEEONSt16remove_referenceIT_E4typeEOSC_>:
 804a6b0:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a6b4:	c3                   	ret    
 804a6b5:	66 90                	xchg   %ax,%ax
 804a6b7:	66 90                	xchg   %ax,%ax
 804a6b9:	66 90                	xchg   %ax,%ax
 804a6bb:	66 90                	xchg   %ax,%ax
 804a6bd:	66 90                	xchg   %ax,%ax
 804a6bf:	90                   	nop

0804a6c0 <_ZSt7forwardIKSaINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEEEEOT_RNSt16remove_referenceISA_E4typeE>:
   *  This function is used to implement "perfect forwarding".
   */
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }
 804a6c0:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a6c4:	c3                   	ret    
 804a6c5:	66 90                	xchg   %ax,%ax
 804a6c7:	66 90                	xchg   %ax,%ax
 804a6c9:	66 90                	xchg   %ax,%ax
 804a6cb:	66 90                	xchg   %ax,%ax
 804a6cd:	66 90                	xchg   %ax,%ax
 804a6cf:	90                   	nop

0804a6d0 <_ZNSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS7_ELN9__gnu_cxx12_Lock_policyE2EE6_M_ptrEv>:
	_M_storage;

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
 804a6d0:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a6d4:	83 c0 0c             	add    $0xc,%eax
        return nullptr;
#endif
      }

    private:
      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }
 804a6d7:	c3                   	ret    
 804a6d8:	66 90                	xchg   %ax,%ax
 804a6da:	66 90                	xchg   %ax,%ax
 804a6dc:	66 90                	xchg   %ax,%ax
 804a6de:	66 90                	xchg   %ax,%ax

0804a6e0 <_ZNSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS7_ELN9__gnu_cxx12_Lock_policyE2EE14_M_get_deleterERKSt9type_info>:
	_Alloc_traits::deallocate(__a, this, 1);
      }

      // Sneaky trick so __shared_ptr can get the managed pointer
      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
 804a6e0:	57                   	push   %edi
 804a6e1:	56                   	push   %esi
 804a6e2:	8b 44 24 10          	mov    0x10(%esp),%eax
 804a6e6:	8b 54 24 0c          	mov    0xc(%esp),%edx
 804a6ea:	8b 70 04             	mov    0x4(%eax),%esi
	: __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT
    {
      return ((__name == __arg.__name)
	      || (__name[0] != '*' &&
 804a6ed:	81 fe 3c ce 04 08    	cmp    $0x804ce3c,%esi
 804a6f3:	74 1b                	je     804a710 <_ZNSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS7_ELN9__gnu_cxx12_Lock_policyE2EE14_M_get_deleterERKSt9type_info+0x30>
 804a6f5:	80 3e 2a             	cmpb   $0x2a,(%esi)
 804a6f8:	74 0e                	je     804a708 <_ZNSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS7_ELN9__gnu_cxx12_Lock_policyE2EE14_M_get_deleterERKSt9type_info+0x28>
		  __builtin_strcmp (__name, __arg.__name) == 0));
 804a6fa:	bf 3c ce 04 08       	mov    $0x804ce3c,%edi
 804a6ff:	b9 18 00 00 00       	mov    $0x18,%ecx
	: __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT
    {
      return ((__name == __arg.__name)
	      || (__name[0] != '*' &&
 804a704:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
 804a706:	74 08                	je     804a710 <_ZNSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS7_ELN9__gnu_cxx12_Lock_policyE2EE14_M_get_deleterERKSt9type_info+0x30>
#ifdef __GXX_RTTI
	return __ti == typeid(_Sp_make_shared_tag) ? _M_ptr() : nullptr;
#else
        return nullptr;
#endif
      }
 804a708:	31 c0                	xor    %eax,%eax
 804a70a:	5e                   	pop    %esi
 804a70b:	5f                   	pop    %edi
 804a70c:	c3                   	ret    
 804a70d:	8d 76 00             	lea    0x0(%esi),%esi
      // Sneaky trick so __shared_ptr can get the managed pointer
      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {
#ifdef __GXX_RTTI
	return __ti == typeid(_Sp_make_shared_tag) ? _M_ptr() : nullptr;
 804a710:	89 54 24 0c          	mov    %edx,0xc(%esp)
#else
        return nullptr;
#endif
      }
 804a714:	5e                   	pop    %esi
 804a715:	5f                   	pop    %edi
      // Sneaky trick so __shared_ptr can get the managed pointer
      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {
#ifdef __GXX_RTTI
	return __ti == typeid(_Sp_make_shared_tag) ? _M_ptr() : nullptr;
 804a716:	e9 b5 ff ff ff       	jmp    804a6d0 <_ZNSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS7_ELN9__gnu_cxx12_Lock_policyE2EE6_M_ptrEv>
 804a71b:	66 90                	xchg   %ax,%ax
 804a71d:	66 90                	xchg   %ax,%ax
 804a71f:	90                   	nop

0804a720 <_ZNSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS7_ELN9__gnu_cxx12_Lock_policyE2EE10_M_disposeEv>:
	}

      ~_Sp_counted_ptr_inplace() noexcept { }

      virtual void
      _M_dispose() noexcept
 804a720:	83 ec 1c             	sub    $0x1c,%esp
      {
	allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
 804a723:	8b 44 24 20          	mov    0x20(%esp),%eax
 804a727:	89 04 24             	mov    %eax,(%esp)
 804a72a:	e8 a1 ff ff ff       	call   804a6d0 <_ZNSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEEESaIS7_ELN9__gnu_cxx12_Lock_policyE2EE6_M_ptrEv>
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void 
        destroy(_Up* __p) { __p->~_Up(); }
 804a72f:	8b 10                	mov    (%eax),%edx
 804a731:	89 44 24 20          	mov    %eax,0x20(%esp)
 804a735:	8b 02                	mov    (%edx),%eax
      }
 804a737:	83 c4 1c             	add    $0x1c,%esp
 804a73a:	ff e0                	jmp    *%eax
 804a73c:	66 90                	xchg   %ax,%ax
 804a73e:	66 90                	xchg   %ax,%ax

0804a740 <_ZSt3getILj0EIPFvjEjEENSt9__add_refINSt13tuple_elementIXT_ESt5tupleIIDpT0_EEE4typeEE4typeERS7_>:
      template<typename _Alloc, typename _UHead>
	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
	: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
 804a740:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a744:	83 c0 04             	add    $0x4,%eax
  template<std::size_t __i, typename... _Elements>
    constexpr typename __add_ref<
                      typename tuple_element<__i, tuple<_Elements...>>::type
                    >::type
    get(tuple<_Elements...>& __t) noexcept
    { return __get_helper<__i>(__t); }
 804a747:	c3                   	ret    
 804a748:	66 90                	xchg   %ax,%ax
 804a74a:	66 90                	xchg   %ax,%ax
 804a74c:	66 90                	xchg   %ax,%ax
 804a74e:	66 90                	xchg   %ax,%ax

0804a750 <_ZSt3getILj1EIPFvjEjEENSt9__add_refINSt13tuple_elementIXT_ESt5tupleIIDpT0_EEE4typeEE4typeERS7_>:
 804a750:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a754:	c3                   	ret    
 804a755:	66 90                	xchg   %ax,%ax
 804a757:	66 90                	xchg   %ax,%ax
 804a759:	66 90                	xchg   %ax,%ax
 804a75b:	66 90                	xchg   %ax,%ax
 804a75d:	66 90                	xchg   %ax,%ax
 804a75f:	90                   	nop

0804a760 <_ZNSt6thread5_ImplISt12_Bind_simpleIFPFvjEjEEE6_M_runEv>:

	_Impl(_Callable&& __f) : _M_func(std::forward<_Callable>(__f))
	{ }

	void
	_M_run() { _M_func(); }
 804a760:	56                   	push   %esi
 804a761:	53                   	push   %ebx
 804a762:	83 ec 14             	sub    $0x14,%esp
        typename result_of<_Callable(_Args...)>::type
        _M_invoke(_Index_tuple<_Indices...>)
        {
	  // std::bind always forwards bound arguments as lvalues,
	  // but this type can call functions which only accept rvalues.
          return std::forward<_Callable>(std::get<0>(_M_bound))(
 804a765:	8b 44 24 20          	mov    0x20(%esp),%eax
 804a769:	8d 58 0c             	lea    0xc(%eax),%ebx
 804a76c:	89 1c 24             	mov    %ebx,(%esp)
 804a76f:	e8 cc ff ff ff       	call   804a740 <_ZSt3getILj0EIPFvjEjEENSt9__add_refINSt13tuple_elementIXT_ESt5tupleIIDpT0_EEE4typeEE4typeERS7_>
 804a774:	89 04 24             	mov    %eax,(%esp)
 804a777:	e8 e4 fe ff ff       	call   804a660 <_ZSt7forwardIPFvjEEOT_RNSt16remove_referenceIS2_E4typeE>
              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);
 804a77c:	89 1c 24             	mov    %ebx,(%esp)
        typename result_of<_Callable(_Args...)>::type
        _M_invoke(_Index_tuple<_Indices...>)
        {
	  // std::bind always forwards bound arguments as lvalues,
	  // but this type can call functions which only accept rvalues.
          return std::forward<_Callable>(std::get<0>(_M_bound))(
 804a77f:	89 c6                	mov    %eax,%esi
              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);
 804a781:	e8 ca ff ff ff       	call   804a750 <_ZSt3getILj1EIPFvjEjEENSt9__add_refINSt13tuple_elementIXT_ESt5tupleIIDpT0_EEE4typeEE4typeERS7_>
 804a786:	89 04 24             	mov    %eax,(%esp)
 804a789:	e8 92 fe ff ff       	call   804a620 <_ZSt7forwardIjEOT_RNSt16remove_referenceIS0_E4typeE>
 804a78e:	8b 00                	mov    (%eax),%eax
 804a790:	89 44 24 20          	mov    %eax,0x20(%esp)
 804a794:	8b 06                	mov    (%esi),%eax
 804a796:	83 c4 14             	add    $0x14,%esp
 804a799:	5b                   	pop    %ebx
 804a79a:	5e                   	pop    %esi
 804a79b:	ff e0                	jmp    *%eax
 804a79d:	66 90                	xchg   %ax,%ax
 804a79f:	90                   	nop

0804a7a0 <_ZNKSs4_Rep12_M_is_sharedEv.isra.0>:
	_M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
	_M_is_shared() const
        { return this->_M_refcount > 0; }
 804a7a0:	85 c0                	test   %eax,%eax
 804a7a2:	0f 9f c0             	setg   %al
 804a7a5:	c3                   	ret    
 804a7a6:	8d 76 00             	lea    0x0(%esi),%esi
 804a7a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804a7b0 <_ZNKSs13get_allocatorEv.isra.7>:
      /**
       *  @brief  Return copy of allocator used to construct this string.
      */
      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return _M_dataplus; }
 804a7b0:	f3 c3                	repz ret 
 804a7b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804a7b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804a7c0 <_Z12bench_verifyv>:
 804a7c0:	b8 01 00 00 00       	mov    $0x1,%eax
 804a7c5:	c3                   	ret    
 804a7c6:	8d 76 00             	lea    0x0(%esi),%esi
 804a7c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804a7d0 <_Z10bench_initv>:

/**
 * Initialize the data structure and warm it up
 */
void bench_init()
{
 804a7d0:	55                   	push   %ebp
 804a7d1:	57                   	push   %edi
 804a7d2:	56                   	push   %esi
 804a7d3:	53                   	push   %ebx
 804a7d4:	83 ec 4c             	sub    $0x4c,%esp
    hash_table = new HashTable<string, string>();
 804a7d7:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
 804a7de:	e8 5d eb ff ff       	call   8049340 <_Znwj@plt>
	int TableSize;
	int BucketCapacity;
	
	int * buckets_size;

	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
 804a7e3:	c7 40 04 00 04 00 00 	movl   $0x400,0x4(%eax)
 804a7ea:	89 c3                	mov    %eax,%ebx
 804a7ec:	c7 40 08 08 00 00 00 	movl   $0x8,0x8(%eax)
		assert(BucketCapacity > 0);
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
 804a7f3:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 804a7fa:	e8 71 eb ff ff       	call   8049370 <_Znaj@plt>
 804a7ff:	89 03                	mov    %eax,(%ebx)
		buckets_size = new int[TableSize];
 804a801:	8b 43 04             	mov    0x4(%ebx),%eax
 804a804:	3d 00 00 c0 1f       	cmp    $0x1fc00000,%eax
 804a809:	0f 87 d3 02 00 00    	ja     804aae2 <_Z10bench_initv+0x312>
 804a80f:	c1 e0 02             	shl    $0x2,%eax
 804a812:	89 04 24             	mov    %eax,(%esp)
 804a815:	e8 56 eb ff ff       	call   8049370 <_Znaj@plt>

		for(int i = 0 ; i < TableSize ; i ++ ){
 804a81a:	8b 6b 04             	mov    0x4(%ebx),%ebp
 804a81d:	31 d2                	xor    %edx,%edx
	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];
 804a81f:	89 43 0c             	mov    %eax,0xc(%ebx)

		for(int i = 0 ; i < TableSize ; i ++ ){
 804a822:	85 ed                	test   %ebp,%ebp
 804a824:	7e 1d                	jle    804a843 <_Z10bench_initv+0x73>
 804a826:	66 90                	xchg   %ax,%ax
			table[i] = NULL;
 804a828:	8b 03                	mov    (%ebx),%eax
 804a82a:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
			buckets_size[i] = 0;
 804a831:	8b 43 0c             	mov    0xc(%ebx),%eax
 804a834:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];

		for(int i = 0 ; i < TableSize ; i ++ ){
 804a83b:	83 c2 01             	add    $0x1,%edx
 804a83e:	3b 53 04             	cmp    0x4(%ebx),%edx
 804a841:	7c e5                	jl     804a828 <_Z10bench_initv+0x58>

    // warm up the datastructure by filling it half full
    for (uint32_t w = 0; w < Config::CFG.elements; w+=2) {
 804a843:	8b 3d c8 e4 04 08    	mov    0x804e4c8,%edi
/**
 * Initialize the data structure and warm it up
 */
void bench_init()
{
    hash_table = new HashTable<string, string>();
 804a849:	89 1d e8 e4 04 08    	mov    %ebx,0x804e4e8

    // warm up the datastructure by filling it half full
    for (uint32_t w = 0; w < Config::CFG.elements; w+=2) {
 804a84f:	85 ff                	test   %edi,%edi
 804a851:	0f 84 b9 01 00 00    	je     804aa10 <_Z10bench_initv+0x240>
 804a857:	e8 e4 eb ff ff       	call   8049440 <_ZNSs12_S_empty_repEv@plt>
 804a85c:	89 04 24             	mov    %eax,(%esp)
 804a85f:	e8 6c e9 ff ff       	call   80491d0 <_ZNSs4_Rep10_M_refdataEv@plt>
 804a864:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804a86b:	00 
 804a86c:	89 c3                	mov    %eax,%ebx
 804a86e:	8b 44 24 14          	mov    0x14(%esp),%eax
 804a872:	e9 23 01 00 00       	jmp    804a99a <_Z10bench_initv+0x1ca>
 804a877:	90                   	nop
       */
      void
      push_back(_CharT __c)
      { 
	const size_type __len = 1 + this->size();
	if (__len > this->capacity() || _M_rep()->_M_is_shared())
 804a878:	8b 43 fc             	mov    -0x4(%ebx),%eax
 804a87b:	e8 20 ff ff ff       	call   804a7a0 <_ZNKSs4_Rep12_M_is_sharedEv.isra.0>
 804a880:	84 c0                	test   %al,%al
 804a882:	0f 85 49 01 00 00    	jne    804a9d1 <_Z10bench_initv+0x201>
 804a888:	89 d8                	mov    %ebx,%eax
      typedef streamoff         off_type;
      typedef mbstate_t         state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
      { __c1 = __c2; }
 804a88a:	0f b6 4c 24 1b       	movzbl 0x1b(%esp),%ecx
 804a88f:	88 0c 30             	mov    %cl,(%eax,%esi,1)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804a892:	8b 6c 24 30          	mov    0x30(%esp),%ebp
      { 
	const size_type __len = 1 + this->size();
	if (__len > this->capacity() || _M_rep()->_M_is_shared())
	  this->reserve(__len);
	traits_type::assign(_M_data()[this->size()], __c);
	_M_rep()->_M_set_length_and_sharable(__len);
 804a896:	8d 45 f4             	lea    -0xc(%ebp),%eax
 804a899:	89 44 24 1c          	mov    %eax,0x1c(%esp)

	void
	_M_set_length_and_sharable(size_type __n)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804a89d:	e8 6e eb ff ff       	call   8049410 <_ZNSs4_Rep12_S_empty_repEv@plt>
 804a8a2:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
 804a8a6:	89 c6                	mov    %eax,%esi
 804a8a8:	0f 85 6a 01 00 00    	jne    804aa18 <_Z10bench_initv+0x248>
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804a8ae:	8b 6b f4             	mov    -0xc(%ebx),%ebp

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a)
	: _Alloc(__a), _M_p(__dat) { }
 804a8b1:	89 5c 24 34          	mov    %ebx,0x34(%esp)
       *  @param __c  Character to append.
       */
      void
      push_back(_CharT __c)
      { 
	const size_type __len = 1 + this->size();
 804a8b5:	8d 7d 01             	lea    0x1(%ebp),%edi
	if (__len > this->capacity() || _M_rep()->_M_is_shared())
 804a8b8:	3b 7b f8             	cmp    -0x8(%ebx),%edi
 804a8bb:	0f 87 2f 01 00 00    	ja     804a9f0 <_Z10bench_initv+0x220>
 804a8c1:	8b 43 fc             	mov    -0x4(%ebx),%eax
 804a8c4:	e8 d7 fe ff ff       	call   804a7a0 <_ZNKSs4_Rep12_M_is_sharedEv.isra.0>
 804a8c9:	84 c0                	test   %al,%al
 804a8cb:	0f 85 1f 01 00 00    	jne    804a9f0 <_Z10bench_initv+0x220>
 804a8d1:	89 d8                	mov    %ebx,%eax
 804a8d3:	0f b6 4c 24 1b       	movzbl 0x1b(%esp),%ecx
 804a8d8:	88 0c 28             	mov    %cl,(%eax,%ebp,1)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804a8db:	8b 44 24 34          	mov    0x34(%esp),%eax
      { 
	const size_type __len = 1 + this->size();
	if (__len > this->capacity() || _M_rep()->_M_is_shared())
	  this->reserve(__len);
	traits_type::assign(_M_data()[this->size()], __c);
	_M_rep()->_M_set_length_and_sharable(__len);
 804a8df:	8d 50 f4             	lea    -0xc(%eax),%edx

	void
	_M_set_length_and_sharable(size_type __n)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804a8e2:	39 d6                	cmp    %edx,%esi
 804a8e4:	0f 85 dd 01 00 00    	jne    804aac7 <_Z10bench_initv+0x2f7>
	 string skey; skey += (char)(32 + w%95);
	 string sval; sval += (char)(32 + w%95);
         hash_table->insert(skey, sval);
 804a8ea:	8d 44 24 34          	lea    0x34(%esp),%eax
 804a8ee:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a8f2:	8d 44 24 3c          	lea    0x3c(%esp),%eax
 804a8f6:	89 04 24             	mov    %eax,(%esp)
 804a8f9:	e8 f2 e8 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804a8fe:	8d 44 24 30          	lea    0x30(%esp),%eax
 804a902:	8d 7c 24 38          	lea    0x38(%esp),%edi
 804a906:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a90a:	89 3c 24             	mov    %edi,(%esp)
 804a90d:	e8 de e8 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804a912:	8d 44 24 3c          	lea    0x3c(%esp),%eax
 804a916:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a91a:	a1 e8 e4 04 08       	mov    0x804e4e8,%eax
 804a91f:	89 7c 24 04          	mov    %edi,0x4(%esp)
 804a923:	89 04 24             	mov    %eax,(%esp)
 804a926:	e8 65 0d 00 00       	call   804b690 <_ZN9HashTableISsSsE6insertESsSs>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804a92b:	8d 44 24 2f          	lea    0x2f(%esp),%eax
 804a92f:	e8 7c fe ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804a934:	8b 44 24 38          	mov    0x38(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804a938:	8d 68 f4             	lea    -0xc(%eax),%ebp

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804a93b:	39 ee                	cmp    %ebp,%esi
 804a93d:	0f 85 5f 01 00 00    	jne    804aaa2 <_Z10bench_initv+0x2d2>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804a943:	89 f8                	mov    %edi,%eax
 804a945:	e8 66 fe ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804a94a:	8b 44 24 3c          	mov    0x3c(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804a94e:	8d 68 f4             	lea    -0xc(%eax),%ebp

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804a951:	39 ee                	cmp    %ebp,%esi
 804a953:	0f 85 28 01 00 00    	jne    804aa81 <_Z10bench_initv+0x2b1>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804a959:	8d 44 24 3c          	lea    0x3c(%esp),%eax
 804a95d:	e8 4e fe ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804a962:	8b 44 24 34          	mov    0x34(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804a966:	8d 78 f4             	lea    -0xc(%eax),%edi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804a969:	39 fe                	cmp    %edi,%esi
 804a96b:	0f 85 eb 00 00 00    	jne    804aa5c <_Z10bench_initv+0x28c>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804a971:	8d 44 24 3c          	lea    0x3c(%esp),%eax
 804a975:	e8 36 fe ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804a97a:	8b 44 24 30          	mov    0x30(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804a97e:	8d 78 f4             	lea    -0xc(%eax),%edi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804a981:	39 fe                	cmp    %edi,%esi
 804a983:	0f 85 ae 00 00 00    	jne    804aa37 <_Z10bench_initv+0x267>
void bench_init()
{
    hash_table = new HashTable<string, string>();

    // warm up the datastructure by filling it half full
    for (uint32_t w = 0; w < Config::CFG.elements; w+=2) {
 804a989:	83 44 24 14 02       	addl   $0x2,0x14(%esp)
 804a98e:	8b 44 24 14          	mov    0x14(%esp),%eax
 804a992:	39 05 c8 e4 04 08    	cmp    %eax,0x804e4c8
 804a998:	76 76                	jbe    804aa10 <_Z10bench_initv+0x240>
	 string skey; skey += (char)(32 + w%95);
 804a99a:	8b 4c 24 14          	mov    0x14(%esp),%ecx
 804a99e:	ba 09 23 ed 58       	mov    $0x58ed2309,%edx
 804a9a3:	f7 e2                	mul    %edx
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804a9a5:	8b 73 f4             	mov    -0xc(%ebx),%esi

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a)
	: _Alloc(__a), _M_p(__dat) { }
 804a9a8:	89 5c 24 30          	mov    %ebx,0x30(%esp)
 804a9ac:	89 c8                	mov    %ecx,%eax
 804a9ae:	29 d0                	sub    %edx,%eax
 804a9b0:	d1 e8                	shr    %eax
 804a9b2:	01 c2                	add    %eax,%edx
 804a9b4:	89 c8                	mov    %ecx,%eax
 804a9b6:	c1 ea 06             	shr    $0x6,%edx
 804a9b9:	6b d2 5f             	imul   $0x5f,%edx,%edx
       *  @param __c  Character to append.
       */
      void
      push_back(_CharT __c)
      { 
	const size_type __len = 1 + this->size();
 804a9bc:	8d 7e 01             	lea    0x1(%esi),%edi
 804a9bf:	29 d0                	sub    %edx,%eax
 804a9c1:	83 c0 20             	add    $0x20,%eax
	if (__len > this->capacity() || _M_rep()->_M_is_shared())
 804a9c4:	3b 7b f8             	cmp    -0x8(%ebx),%edi
 804a9c7:	88 44 24 1b          	mov    %al,0x1b(%esp)
 804a9cb:	0f 86 a7 fe ff ff    	jbe    804a878 <_Z10bench_initv+0xa8>
	  this->reserve(__len);
 804a9d1:	8d 44 24 30          	lea    0x30(%esp),%eax
 804a9d5:	89 7c 24 04          	mov    %edi,0x4(%esp)
 804a9d9:	89 04 24             	mov    %eax,(%esp)
 804a9dc:	e8 9f ea ff ff       	call   8049480 <_ZNSs7reserveEj@plt>
 804a9e1:	8b 44 24 30          	mov    0x30(%esp),%eax
 804a9e5:	8b 70 f4             	mov    -0xc(%eax),%esi
 804a9e8:	e9 9d fe ff ff       	jmp    804a88a <_Z10bench_initv+0xba>
 804a9ed:	8d 76 00             	lea    0x0(%esi),%esi
 804a9f0:	8d 44 24 34          	lea    0x34(%esp),%eax
 804a9f4:	89 7c 24 04          	mov    %edi,0x4(%esp)
 804a9f8:	89 04 24             	mov    %eax,(%esp)
 804a9fb:	e8 80 ea ff ff       	call   8049480 <_ZNSs7reserveEj@plt>
 804aa00:	8b 44 24 34          	mov    0x34(%esp),%eax
 804aa04:	8b 68 f4             	mov    -0xc(%eax),%ebp
 804aa07:	e9 c7 fe ff ff       	jmp    804a8d3 <_Z10bench_initv+0x103>
 804aa0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	 string sval; sval += (char)(32 + w%95);
         hash_table->insert(skey, sval);
    }
}
 804aa10:	83 c4 4c             	add    $0x4c,%esp
 804aa13:	5b                   	pop    %ebx
 804aa14:	5e                   	pop    %esi
 804aa15:	5f                   	pop    %edi
 804aa16:	5d                   	pop    %ebp
 804aa17:	c3                   	ret    
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      this->_M_set_sharable();  // One reference.
	      this->_M_length = __n;
	      traits_type::assign(this->_M_refdata()[__n], _S_terminal);
 804aa18:	8b 44 24 1c          	mov    0x1c(%esp),%eax
	_M_set_leaked()
        { this->_M_refcount = -1; }

        void
	_M_set_sharable()
        { this->_M_refcount = 0; }
 804aa1c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      this->_M_set_sharable();  // One reference.
	      this->_M_length = __n;
 804aa23:	89 7d f4             	mov    %edi,-0xc(%ebp)
	      traits_type::assign(this->_M_refdata()[__n], _S_terminal);
 804aa26:	89 04 24             	mov    %eax,(%esp)
 804aa29:	e8 a2 e7 ff ff       	call   80491d0 <_ZNSs4_Rep10_M_refdataEv@plt>
 804aa2e:	c6 04 38 00          	movb   $0x0,(%eax,%edi,1)
 804aa32:	e9 77 fe ff ff       	jmp    804a8ae <_Z10bench_initv+0xde>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804aa37:	83 e8 04             	sub    $0x4,%eax
 804aa3a:	e8 be ea ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804aa3f:	85 c0                	test   %eax,%eax
 804aa41:	0f 8f 42 ff ff ff    	jg     804a989 <_Z10bench_initv+0x1b9>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804aa47:	8d 44 24 3c          	lea    0x3c(%esp),%eax
 804aa4b:	89 44 24 04          	mov    %eax,0x4(%esp)
 804aa4f:	89 3c 24             	mov    %edi,(%esp)
 804aa52:	e8 29 e8 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804aa57:	e9 2d ff ff ff       	jmp    804a989 <_Z10bench_initv+0x1b9>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804aa5c:	83 e8 04             	sub    $0x4,%eax
 804aa5f:	e8 99 ea ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804aa64:	85 c0                	test   %eax,%eax
 804aa66:	0f 8f 05 ff ff ff    	jg     804a971 <_Z10bench_initv+0x1a1>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804aa6c:	8d 44 24 3c          	lea    0x3c(%esp),%eax
 804aa70:	89 44 24 04          	mov    %eax,0x4(%esp)
 804aa74:	89 3c 24             	mov    %edi,(%esp)
 804aa77:	e8 04 e8 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804aa7c:	e9 f0 fe ff ff       	jmp    804a971 <_Z10bench_initv+0x1a1>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804aa81:	83 e8 04             	sub    $0x4,%eax
 804aa84:	e8 74 ea ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804aa89:	85 c0                	test   %eax,%eax
 804aa8b:	0f 8f c8 fe ff ff    	jg     804a959 <_Z10bench_initv+0x189>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804aa91:	89 7c 24 04          	mov    %edi,0x4(%esp)
 804aa95:	89 2c 24             	mov    %ebp,(%esp)
 804aa98:	e8 e3 e7 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804aa9d:	e9 b7 fe ff ff       	jmp    804a959 <_Z10bench_initv+0x189>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804aaa2:	83 e8 04             	sub    $0x4,%eax
 804aaa5:	e8 53 ea ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804aaaa:	85 c0                	test   %eax,%eax
 804aaac:	0f 8f 91 fe ff ff    	jg     804a943 <_Z10bench_initv+0x173>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804aab2:	8d 44 24 2f          	lea    0x2f(%esp),%eax
 804aab6:	89 44 24 04          	mov    %eax,0x4(%esp)
 804aaba:	89 2c 24             	mov    %ebp,(%esp)
 804aabd:	e8 be e7 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804aac2:	e9 7c fe ff ff       	jmp    804a943 <_Z10bench_initv+0x173>
	_M_set_leaked()
        { this->_M_refcount = -1; }

        void
	_M_set_sharable()
        { this->_M_refcount = 0; }
 804aac7:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      this->_M_set_sharable();  // One reference.
	      this->_M_length = __n;
 804aace:	89 78 f4             	mov    %edi,-0xc(%eax)
	      traits_type::assign(this->_M_refdata()[__n], _S_terminal);
 804aad1:	89 14 24             	mov    %edx,(%esp)
 804aad4:	e8 f7 e6 ff ff       	call   80491d0 <_ZNSs4_Rep10_M_refdataEv@plt>
 804aad9:	c6 04 38 00          	movb   $0x0,(%eax,%edi,1)
 804aadd:	e9 08 fe ff ff       	jmp    804a8ea <_Z10bench_initv+0x11a>
	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];
 804aae2:	e8 c9 e6 ff ff       	call   80491b0 <__cxa_throw_bad_array_new_length@plt>
 804aae7:	89 c6                	mov    %eax,%esi
/**
 * Initialize the data structure and warm it up
 */
void bench_init()
{
    hash_table = new HashTable<string, string>();
 804aae9:	89 1c 24             	mov    %ebx,(%esp)
 804aaec:	c5 f8 77             	vzeroupper 
 804aaef:	e8 7c e6 ff ff       	call   8049170 <_ZdlPv@plt>
 804aaf4:	89 34 24             	mov    %esi,(%esp)
 804aaf7:	e8 34 e9 ff ff       	call   8049430 <_Unwind_Resume@plt>
 804aafc:	89 c3                	mov    %eax,%ebx
 804aafe:	c5 f8 77             	vzeroupper 
    // warm up the datastructure by filling it half full
    for (uint32_t w = 0; w < Config::CFG.elements; w+=2) {
	 string skey; skey += (char)(32 + w%95);
	 string sval; sval += (char)(32 + w%95);
         hash_table->insert(skey, sval);
    }
 804ab01:	8d 44 24 30          	lea    0x30(%esp),%eax
 804ab05:	89 04 24             	mov    %eax,(%esp)
 804ab08:	e8 53 e7 ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804ab0d:	89 1c 24             	mov    %ebx,(%esp)
 804ab10:	e8 1b e9 ff ff       	call   8049430 <_Unwind_Resume@plt>
 804ab15:	89 c3                	mov    %eax,%ebx

    // warm up the datastructure by filling it half full
    for (uint32_t w = 0; w < Config::CFG.elements; w+=2) {
	 string skey; skey += (char)(32 + w%95);
	 string sval; sval += (char)(32 + w%95);
         hash_table->insert(skey, sval);
 804ab17:	89 3c 24             	mov    %edi,(%esp)
 804ab1a:	c5 f8 77             	vzeroupper 
 804ab1d:	e8 3e e7 ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804ab22:	8d 44 24 3c          	lea    0x3c(%esp),%eax
 804ab26:	89 04 24             	mov    %eax,(%esp)
 804ab29:	e8 32 e7 ff ff       	call   8049260 <_ZNSsD1Ev@plt>
    hash_table = new HashTable<string, string>();

    // warm up the datastructure by filling it half full
    for (uint32_t w = 0; w < Config::CFG.elements; w+=2) {
	 string skey; skey += (char)(32 + w%95);
	 string sval; sval += (char)(32 + w%95);
 804ab2e:	8d 44 24 34          	lea    0x34(%esp),%eax
 804ab32:	89 04 24             	mov    %eax,(%esp)
 804ab35:	e8 26 e7 ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804ab3a:	eb c5                	jmp    804ab01 <_Z10bench_initv+0x331>
 804ab3c:	89 c3                	mov    %eax,%ebx
 804ab3e:	c5 f8 77             	vzeroupper 
 804ab41:	eb df                	jmp    804ab22 <_Z10bench_initv+0x352>
 804ab43:	89 c3                	mov    %eax,%ebx
 804ab45:	c5 f8 77             	vzeroupper 
 804ab48:	eb e4                	jmp    804ab2e <_Z10bench_initv+0x35e>
 804ab4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804ab50 <_Z10bench_testjPj>:

/**
 * Run a bunch of random operations
 */
void bench_test(uintptr_t, uint32_t* seed)
{
 804ab50:	55                   	push   %ebp
 804ab51:	57                   	push   %edi
 804ab52:	56                   	push   %esi
 804ab53:	53                   	push   %ebx
 804ab54:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
      /**
       *  @brief  Default constructor creates an empty string.
       */
      basic_string()
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
 804ab5a:	e8 e1 e8 ff ff       	call   8049440 <_ZNSs12_S_empty_repEv@plt>
 804ab5f:	8b ac 24 b4 00 00 00 	mov    0xb4(%esp),%ebp
 804ab66:	89 04 24             	mov    %eax,(%esp)
 804ab69:	e8 62 e6 ff ff       	call   80491d0 <_ZNSs4_Rep10_M_refdataEv@plt>

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a)
	: _Alloc(__a), _M_p(__dat) { }
 804ab6e:	c7 44 24 20 05 00 00 	movl   $0x5,0x20(%esp)
 804ab75:	00 
      /**
       *  @brief  Default constructor creates an empty string.
       */
      basic_string()
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
 804ab76:	89 44 24 34          	mov    %eax,0x34(%esp)

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a)
	: _Alloc(__a), _M_p(__dat) { }
 804ab7a:	89 44 24 64          	mov    %eax,0x64(%esp)
 804ab7e:	89 44 24 68          	mov    %eax,0x68(%esp)
    uint32_t key, val;
    string skey, sval;
    // select a random key
    for(int i = 0; i < 5; ++i) {
	    key = rand_r(seed) % Config::CFG.elements;
 804ab82:	89 2c 24             	mov    %ebp,(%esp)
 804ab85:	e8 76 e7 ff ff       	call   8049300 <rand_r@plt>
 804ab8a:	31 d2                	xor    %edx,%edx
 804ab8c:	f7 35 c8 e4 04 08    	divl   0x804e4c8
	    skey += (char)(32 + key%95);
 804ab92:	b8 09 23 ed 58       	mov    $0x58ed2309,%eax
{
    uint32_t key, val;
    string skey, sval;
    // select a random key
    for(int i = 0; i < 5; ++i) {
	    key = rand_r(seed) % Config::CFG.elements;
 804ab97:	89 d7                	mov    %edx,%edi
	    skey += (char)(32 + key%95);
 804ab99:	f7 e2                	mul    %edx
 804ab9b:	89 f8                	mov    %edi,%eax
 804ab9d:	29 d0                	sub    %edx,%eax
 804ab9f:	d1 e8                	shr    %eax
 804aba1:	01 c2                	add    %eax,%edx
 804aba3:	c1 ea 06             	shr    $0x6,%edx
 804aba6:	6b d2 5f             	imul   $0x5f,%edx,%edx
 804aba9:	29 d7                	sub    %edx,%edi
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804abab:	8b 54 24 64          	mov    0x64(%esp),%edx
 804abaf:	83 c7 20             	add    $0x20,%edi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804abb2:	8b 4a f4             	mov    -0xc(%edx),%ecx
       *  @param __c  Character to append.
       */
      void
      push_back(_CharT __c)
      { 
	const size_type __len = 1 + this->size();
 804abb5:	8d 71 01             	lea    0x1(%ecx),%esi
	if (__len > this->capacity() || _M_rep()->_M_is_shared())
 804abb8:	3b 72 f8             	cmp    -0x8(%edx),%esi
 804abbb:	77 1c                	ja     804abd9 <_Z10bench_testjPj+0x89>
 804abbd:	8b 42 fc             	mov    -0x4(%edx),%eax
 804abc0:	89 4c 24 28          	mov    %ecx,0x28(%esp)
 804abc4:	89 54 24 24          	mov    %edx,0x24(%esp)
 804abc8:	e8 d3 fb ff ff       	call   804a7a0 <_ZNKSs4_Rep12_M_is_sharedEv.isra.0>
 804abcd:	8b 54 24 24          	mov    0x24(%esp),%edx
 804abd1:	8b 4c 24 28          	mov    0x28(%esp),%ecx
 804abd5:	84 c0                	test   %al,%al
 804abd7:	74 17                	je     804abf0 <_Z10bench_testjPj+0xa0>
	  this->reserve(__len);
 804abd9:	8d 44 24 64          	lea    0x64(%esp),%eax
 804abdd:	89 74 24 04          	mov    %esi,0x4(%esp)
 804abe1:	89 04 24             	mov    %eax,(%esp)
 804abe4:	e8 97 e8 ff ff       	call   8049480 <_ZNSs7reserveEj@plt>
 804abe9:	8b 54 24 64          	mov    0x64(%esp),%edx
 804abed:	8b 4a f4             	mov    -0xc(%edx),%ecx
 804abf0:	89 f8                	mov    %edi,%eax
 804abf2:	88 04 0a             	mov    %al,(%edx,%ecx,1)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804abf5:	8b 5c 24 64          	mov    0x64(%esp),%ebx

	void
	_M_set_length_and_sharable(size_type __n)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804abf9:	e8 12 e8 ff ff       	call   8049410 <_ZNSs4_Rep12_S_empty_repEv@plt>
      { 
	const size_type __len = 1 + this->size();
	if (__len > this->capacity() || _M_rep()->_M_is_shared())
	  this->reserve(__len);
	traits_type::assign(_M_data()[this->size()], __c);
	_M_rep()->_M_set_length_and_sharable(__len);
 804abfe:	8d 7b f4             	lea    -0xc(%ebx),%edi

	void
	_M_set_length_and_sharable(size_type __n)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804ac01:	39 c7                	cmp    %eax,%edi
 804ac03:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 804ac07:	0f 85 f3 06 00 00    	jne    804b300 <_Z10bench_testjPj+0x7b0>
void bench_test(uintptr_t, uint32_t* seed)
{
    uint32_t key, val;
    string skey, sval;
    // select a random key
    for(int i = 0; i < 5; ++i) {
 804ac0d:	83 6c 24 20 01       	subl   $0x1,0x20(%esp)
 804ac12:	0f 85 6a ff ff ff    	jne    804ab82 <_Z10bench_testjPj+0x32>
 804ac18:	bb 05 00 00 00       	mov    $0x5,%ebx
	    skey += (char)(32 + key%95);
    }

    // select a random value
    for(int i = 0; i < 5; ++i) {
	    val = rand_r(seed) % Config::CFG.elements;
 804ac1d:	89 2c 24             	mov    %ebp,(%esp)
 804ac20:	e8 db e6 ff ff       	call   8049300 <rand_r@plt>
 804ac25:	31 d2                	xor    %edx,%edx
 804ac27:	f7 35 c8 e4 04 08    	divl   0x804e4c8
	    sval += (char)(32 + val%95);
 804ac2d:	b8 09 23 ed 58       	mov    $0x58ed2309,%eax
	    skey += (char)(32 + key%95);
    }

    // select a random value
    for(int i = 0; i < 5; ++i) {
	    val = rand_r(seed) % Config::CFG.elements;
 804ac32:	89 d7                	mov    %edx,%edi
	    sval += (char)(32 + val%95);
 804ac34:	f7 e2                	mul    %edx
 804ac36:	89 f8                	mov    %edi,%eax
 804ac38:	29 d0                	sub    %edx,%eax
 804ac3a:	d1 e8                	shr    %eax
 804ac3c:	01 c2                	add    %eax,%edx
 804ac3e:	c1 ea 06             	shr    $0x6,%edx
 804ac41:	6b d2 5f             	imul   $0x5f,%edx,%edx
 804ac44:	29 d7                	sub    %edx,%edi
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804ac46:	8b 54 24 68          	mov    0x68(%esp),%edx
 804ac4a:	83 c7 20             	add    $0x20,%edi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804ac4d:	8b 4a f4             	mov    -0xc(%edx),%ecx
       *  @param __c  Character to append.
       */
      void
      push_back(_CharT __c)
      { 
	const size_type __len = 1 + this->size();
 804ac50:	8d 71 01             	lea    0x1(%ecx),%esi
	if (__len > this->capacity() || _M_rep()->_M_is_shared())
 804ac53:	3b 72 f8             	cmp    -0x8(%edx),%esi
 804ac56:	77 1c                	ja     804ac74 <_Z10bench_testjPj+0x124>
 804ac58:	8b 42 fc             	mov    -0x4(%edx),%eax
 804ac5b:	89 4c 24 30          	mov    %ecx,0x30(%esp)
 804ac5f:	89 54 24 2c          	mov    %edx,0x2c(%esp)
 804ac63:	e8 38 fb ff ff       	call   804a7a0 <_ZNKSs4_Rep12_M_is_sharedEv.isra.0>
 804ac68:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 804ac6c:	8b 4c 24 30          	mov    0x30(%esp),%ecx
 804ac70:	84 c0                	test   %al,%al
 804ac72:	74 17                	je     804ac8b <_Z10bench_testjPj+0x13b>
	  this->reserve(__len);
 804ac74:	8d 44 24 68          	lea    0x68(%esp),%eax
 804ac78:	89 74 24 04          	mov    %esi,0x4(%esp)
 804ac7c:	89 04 24             	mov    %eax,(%esp)
 804ac7f:	e8 fc e7 ff ff       	call   8049480 <_ZNSs7reserveEj@plt>
 804ac84:	8b 54 24 68          	mov    0x68(%esp),%edx
 804ac88:	8b 4a f4             	mov    -0xc(%edx),%ecx
 804ac8b:	89 f8                	mov    %edi,%eax
 804ac8d:	88 04 0a             	mov    %al,(%edx,%ecx,1)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804ac90:	8b 44 24 68          	mov    0x68(%esp),%eax
      { 
	const size_type __len = 1 + this->size();
	if (__len > this->capacity() || _M_rep()->_M_is_shared())
	  this->reserve(__len);
	traits_type::assign(_M_data()[this->size()], __c);
	_M_rep()->_M_set_length_and_sharable(__len);
 804ac94:	8d 50 f4             	lea    -0xc(%eax),%edx

	void
	_M_set_length_and_sharable(size_type __n)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804ac97:	39 54 24 1c          	cmp    %edx,0x1c(%esp)
 804ac9b:	0f 85 aa 06 00 00    	jne    804b34b <_Z10bench_testjPj+0x7fb>
	    key = rand_r(seed) % Config::CFG.elements;
	    skey += (char)(32 + key%95);
    }

    // select a random value
    for(int i = 0; i < 5; ++i) {
 804aca1:	83 eb 01             	sub    $0x1,%ebx
 804aca4:	0f 85 73 ff ff ff    	jne    804ac1d <_Z10bench_testjPj+0xcd>
	    val = rand_r(seed) % Config::CFG.elements;
	    sval += (char)(32 + val%95);
    }
    // select a random number to guide what operation to perform
    uint32_t act = rand_r(seed) % 100;
 804acaa:	89 2c 24             	mov    %ebp,(%esp)
 804acad:	e8 4e e6 ff ff       	call   8049300 <rand_r@plt>
 804acb2:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
 804acb7:	89 c1                	mov    %eax,%ecx
 804acb9:	f7 ea                	imul   %edx
 804acbb:	89 c8                	mov    %ecx,%eax
 804acbd:	c1 f8 1f             	sar    $0x1f,%eax
 804acc0:	c1 fa 05             	sar    $0x5,%edx
 804acc3:	29 c2                	sub    %eax,%edx
 804acc5:	6b d2 64             	imul   $0x64,%edx,%edx
 804acc8:	29 d1                	sub    %edx,%ecx

    // do an operation using the values we just created
    if (act < Config::CFG.lookpct)
 804acca:	3b 0d cc e4 04 08    	cmp    0x804e4cc,%ecx
 804acd0:	0f 82 5a 03 00 00    	jb     804b030 <_Z10bench_testjPj+0x4e0>
        hash_table->lookup(skey);
    else if (act < Config::CFG.inspct){
 804acd6:	3b 0d d0 e4 04 08    	cmp    0x804e4d0,%ecx
 804acdc:	0f 83 c6 00 00 00    	jae    804ada8 <_Z10bench_testjPj+0x258>
//    	cout << "To insert element (" << key << ", " << val << ")" << endl;
        hash_table->insert(skey, sval);
 804ace2:	8d 44 24 68          	lea    0x68(%esp),%eax
 804ace6:	89 44 24 04          	mov    %eax,0x4(%esp)
 804acea:	8d 44 24 78          	lea    0x78(%esp),%eax
 804acee:	89 04 24             	mov    %eax,(%esp)
 804acf1:	e8 fa e4 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804acf6:	8d 44 24 64          	lea    0x64(%esp),%eax
 804acfa:	89 44 24 04          	mov    %eax,0x4(%esp)
 804acfe:	8d 44 24 74          	lea    0x74(%esp),%eax
 804ad02:	89 04 24             	mov    %eax,(%esp)
 804ad05:	e8 e6 e4 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804ad0a:	8d 44 24 78          	lea    0x78(%esp),%eax
 804ad0e:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ad12:	8d 44 24 74          	lea    0x74(%esp),%eax
 804ad16:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ad1a:	a1 e8 e4 04 08       	mov    0x804e4e8,%eax
 804ad1f:	89 04 24             	mov    %eax,(%esp)
 804ad22:	e8 69 09 00 00       	call   804b690 <_ZN9HashTableISsSsE6insertESsSs>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804ad27:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804ad2e:	e8 7d fa ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804ad33:	8b 44 24 74          	mov    0x74(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804ad37:	8d 58 f4             	lea    -0xc(%eax),%ebx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804ad3a:	3b 5c 24 1c          	cmp    0x1c(%esp),%ebx
 804ad3e:	0f 85 1d 07 00 00    	jne    804b461 <_Z10bench_testjPj+0x911>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804ad44:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804ad4b:	e8 60 fa ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804ad50:	8b 44 24 78          	mov    0x78(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804ad54:	8d 58 f4             	lea    -0xc(%eax),%ebx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804ad57:	3b 5c 24 1c          	cmp    0x1c(%esp),%ebx
 804ad5b:	0f 85 a1 02 00 00    	jne    804b002 <_Z10bench_testjPj+0x4b2>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804ad61:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804ad68:	e8 43 fa ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804ad6d:	8b 44 24 68          	mov    0x68(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804ad71:	8d 58 f4             	lea    -0xc(%eax),%ebx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804ad74:	3b 5c 24 1c          	cmp    0x1c(%esp),%ebx
 804ad78:	0f 85 e8 05 00 00    	jne    804b366 <_Z10bench_testjPj+0x816>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804ad7e:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804ad85:	e8 26 fa ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804ad8a:	8b 44 24 64          	mov    0x64(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804ad8e:	8d 58 f4             	lea    -0xc(%eax),%ebx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804ad91:	3b 5c 24 1c          	cmp    0x1c(%esp),%ebx
 804ad95:	0f 85 f5 05 00 00    	jne    804b390 <_Z10bench_testjPj+0x840>
    else {
//    	cout << "To remove an element with key = " << key << endl;
        hash_table->remove(skey);
//	hash_table->print();
    }
}
 804ad9b:	81 c4 9c 00 00 00    	add    $0x9c,%esp
 804ada1:	5b                   	pop    %ebx
 804ada2:	5e                   	pop    %esi
 804ada3:	5f                   	pop    %edi
 804ada4:	5d                   	pop    %ebp
 804ada5:	c3                   	ret    
 804ada6:	66 90                	xchg   %ax,%ax
        hash_table->insert(skey, sval);
//	hash_table->print();
    }
    else {
//    	cout << "To remove an element with key = " << key << endl;
        hash_table->remove(skey);
 804ada8:	8d 44 24 64          	lea    0x64(%esp),%eax
 804adac:	89 44 24 04          	mov    %eax,0x4(%esp)
 804adb0:	8d 44 24 7c          	lea    0x7c(%esp),%eax
 804adb4:	89 04 24             	mov    %eax,(%esp)
 804adb7:	e8 34 e4 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804adbc:	a1 e8 e4 04 08       	mov    0x804e4e8,%eax
 804adc1:	89 c6                	mov    %eax,%esi
 804adc3:	89 44 24 38          	mov    %eax,0x38(%esp)
			return true;
		}
	}

	bool remove(K key) {
		int num = hash(key);
 804adc7:	8d 44 24 7c          	lea    0x7c(%esp),%eax
 804adcb:	89 44 24 04          	mov    %eax,0x4(%esp)
 804adcf:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804add6:	89 04 24             	mov    %eax,(%esp)
 804add9:	e8 12 e4 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804adde:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
	 size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }
 804ade5:	c7 44 24 08 07 69 0f 	movl   $0xc70f6907,0x8(%esp)
 804adec:	c7 
 804aded:	8b 50 f4             	mov    -0xc(%eax),%edx
 804adf0:	89 04 24             	mov    %eax,(%esp)
 804adf3:	89 54 24 04          	mov    %edx,0x4(%esp)
 804adf7:	e8 94 e3 ff ff       	call   8049190 <_ZSt11_Hash_bytesPKvjj@plt>
		}
	}

	int hash(K key) {
		std::hash<K> k_hash;
		return k_hash(key) % TableSize;
 804adfc:	31 d2                	xor    %edx,%edx
 804adfe:	f7 76 04             	divl   0x4(%esi)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804ae01:	8d 84 24 88 00 00 00 	lea    0x88(%esp),%eax
 804ae08:	89 54 24 3c          	mov    %edx,0x3c(%esp)
 804ae0c:	e8 9f f9 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804ae11:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804ae18:	8d 58 f4             	lea    -0xc(%eax),%ebx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804ae1b:	3b 5c 24 1c          	cmp    0x1c(%esp),%ebx
 804ae1f:	0f 85 6e 06 00 00    	jne    804b493 <_Z10bench_testjPj+0x943>
 804ae25:	c7 04 24 2b 40 00 00 	movl   $0x402b,(%esp)
 804ae2c:	e8 7f e4 ff ff       	call   80492b0 <_ITM_beginTransaction@plt>
 804ae31:	a8 02                	test   $0x2,%al
 804ae33:	0f 84 9f 00 00 00    	je     804aed8 <_Z10bench_testjPj+0x388>

	bool remove(K key) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
 804ae39:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
				return false;
			}
			else{
				HashEntry<K,V>* entry = table[num];
				HashEntry<K,V>* pre_entry = NULL;
 804ae3d:	31 f6                	xor    %esi,%esi

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804ae3f:	8d bc 24 8c 00 00 00 	lea    0x8c(%esp),%edi

	bool remove(K key) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
 804ae46:	89 d8                	mov    %ebx,%eax
 804ae48:	c1 e0 02             	shl    $0x2,%eax
 804ae4b:	89 44 24 50          	mov    %eax,0x50(%esp)
 804ae4f:	8b 44 24 38          	mov    0x38(%esp),%eax
 804ae53:	8b 00                	mov    (%eax),%eax
 804ae55:	8b 1c 98             	mov    (%eax,%ebx,4),%ebx
 804ae58:	85 db                	test   %ebx,%ebx
 804ae5a:	0f 84 80 01 00 00    	je     804afe0 <_Z10bench_testjPj+0x490>
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804ae60:	8d 84 24 88 00 00 00 	lea    0x88(%esp),%eax
 804ae67:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804ae6b:	89 04 24             	mov    %eax,(%esp)
 804ae6e:	e8 7d e3 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804ae73:	8b ac 24 88 00 00 00 	mov    0x88(%esp),%ebp
 804ae7a:	8b 44 24 7c          	mov    0x7c(%esp),%eax
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
 804ae7e:	c6 44 24 4f 00       	movb   $0x0,0x4f(%esp)
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804ae83:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
 804ae86:	3b 48 f4             	cmp    -0xc(%eax),%ecx
 804ae89:	75 17                	jne    804aea2 <_Z10bench_testjPj+0x352>
		< static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }
 804ae8b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804ae8f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ae93:	89 2c 24             	mov    %ebp,(%esp)
 804ae96:	e8 85 e2 ff ff       	call   8049120 <memcmp@plt>
 804ae9b:	85 c0                	test   %eax,%eax
 804ae9d:	0f 94 44 24 4f       	sete   0x4f(%esp)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804aea2:	89 f8                	mov    %edi,%eax
 804aea4:	e8 07 f9 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
 804aea9:	8d 4d f4             	lea    -0xc(%ebp),%ecx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804aeac:	3b 4c 24 1c          	cmp    0x1c(%esp),%ecx
 804aeb0:	0f 85 d6 06 00 00    	jne    804b58c <_Z10bench_testjPj+0xa3c>
			else{
				HashEntry<K,V>* entry = table[num];
				HashEntry<K,V>* pre_entry = NULL;

				while(entry != NULL) {
					if(entry->key() == key)
 804aeb6:	80 7c 24 4f 00       	cmpb   $0x0,0x4f(%esp)
 804aebb:	0f 85 b9 00 00 00    	jne    804af7a <_Z10bench_testjPj+0x42a>
						break;
					pre_entry = entry;
					entry = entry->next;
 804aec1:	8b 43 08             	mov    0x8(%ebx),%eax
			}
			else{
				HashEntry<K,V>* entry = table[num];
				HashEntry<K,V>* pre_entry = NULL;

				while(entry != NULL) {
 804aec4:	85 c0                	test   %eax,%eax
 804aec6:	0f 84 14 01 00 00    	je     804afe0 <_Z10bench_testjPj+0x490>
 804aecc:	89 de                	mov    %ebx,%esi
					if(entry->key() == key)
						break;
					pre_entry = entry;
					entry = entry->next;
 804aece:	89 c3                	mov    %eax,%ebx
 804aed0:	eb 8e                	jmp    804ae60 <_Z10bench_testjPj+0x310>
 804aed2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	bool remove(K key) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
 804aed8:	8b 44 24 38          	mov    0x38(%esp),%eax
				return false;
			}
			else{
				HashEntry<K,V>* entry = table[num];
				HashEntry<K,V>* pre_entry = NULL;
 804aedc:	31 ff                	xor    %edi,%edi

	bool remove(K key) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
 804aede:	e8 fd e4 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804aee3:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
 804aee7:	c1 e3 02             	shl    $0x2,%ebx
 804aeea:	89 5c 24 48          	mov    %ebx,0x48(%esp)
 804aeee:	01 d8                	add    %ebx,%eax
 804aef0:	e8 eb e4 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804aef5:	85 c0                	test   %eax,%eax
 804aef7:	89 c3                	mov    %eax,%ebx
 804aef9:	75 37                	jne    804af32 <_Z10bench_testjPj+0x3e2>
 804aefb:	e9 e0 00 00 00       	jmp    804afe0 <_Z10bench_testjPj+0x490>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804af00:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804af07:	e8 a4 f8 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
 804af0c:	8d 4e f4             	lea    -0xc(%esi),%ecx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804af0f:	3b 4c 24 1c          	cmp    0x1c(%esp),%ecx
 804af13:	0f 85 b7 03 00 00    	jne    804b2d0 <_Z10bench_testjPj+0x780>
			else{
				HashEntry<K,V>* entry = table[num];
				HashEntry<K,V>* pre_entry = NULL;

				while(entry != NULL) {
					if(entry->key() == key)
 804af19:	89 e8                	mov    %ebp,%eax
 804af1b:	84 c0                	test   %al,%al
 804af1d:	0f 85 0d 03 00 00    	jne    804b230 <_Z10bench_testjPj+0x6e0>
						break;
					pre_entry = entry;
					entry = entry->next;
 804af23:	8b 43 08             	mov    0x8(%ebx),%eax
			}
			else{
				HashEntry<K,V>* entry = table[num];
				HashEntry<K,V>* pre_entry = NULL;

				while(entry != NULL) {
 804af26:	85 c0                	test   %eax,%eax
 804af28:	0f 84 b2 00 00 00    	je     804afe0 <_Z10bench_testjPj+0x490>
 804af2e:	89 df                	mov    %ebx,%edi
					if(entry->key() == key)
						break;
					pre_entry = entry;
					entry = entry->next;
 804af30:	89 c3                	mov    %eax,%ebx
 804af32:	31 c0                	xor    %eax,%eax
 804af34:	e8 87 e4 ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804af39:	8d 84 24 88 00 00 00 	lea    0x88(%esp),%eax
 804af40:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804af44:	89 04 24             	mov    %eax,(%esp)
 804af47:	e8 a4 e2 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804af4c:	8b b4 24 88 00 00 00 	mov    0x88(%esp),%esi
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
 804af53:	31 ed                	xor    %ebp,%ebp
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804af55:	8b 44 24 7c          	mov    0x7c(%esp),%eax
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804af59:	8b 4e f4             	mov    -0xc(%esi),%ecx
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
 804af5c:	3b 48 f4             	cmp    -0xc(%eax),%ecx
 804af5f:	75 9f                	jne    804af00 <_Z10bench_testjPj+0x3b0>
 804af61:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804af65:	89 44 24 04          	mov    %eax,0x4(%esp)
 804af69:	89 34 24             	mov    %esi,(%esp)
 804af6c:	e8 af e1 ff ff       	call   8049120 <memcmp@plt>
 804af71:	85 c0                	test   %eax,%eax
 804af73:	0f 94 c0             	sete   %al
 804af76:	89 c5                	mov    %eax,%ebp
 804af78:	eb 86                	jmp    804af00 <_Z10bench_testjPj+0x3b0>
					pre_entry = entry;
					entry = entry->next;
				}

				if(entry != NULL) {	//found the key
					if(pre_entry == NULL)
 804af7a:	85 f6                	test   %esi,%esi
 804af7c:	0f 84 76 06 00 00    	je     804b5f8 <_Z10bench_testjPj+0xaa8>
						table[num] = NULL;
					else
						pre_entry->next = entry->next;
 804af82:	8b 43 08             	mov    0x8(%ebx),%eax
 804af85:	89 46 08             	mov    %eax,0x8(%esi)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804af88:	8d b4 24 8c 00 00 00 	lea    0x8c(%esp),%esi
 804af8f:	89 f0                	mov    %esi,%eax
 804af91:	e8 1a f8 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804af96:	8b 43 04             	mov    0x4(%ebx),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804af99:	8d 78 f4             	lea    -0xc(%eax),%edi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804af9c:	3b 7c 24 1c          	cmp    0x1c(%esp),%edi
 804afa0:	0f 85 31 06 00 00    	jne    804b5d7 <_Z10bench_testjPj+0xa87>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804afa6:	8d b4 24 8c 00 00 00 	lea    0x8c(%esp),%esi
 804afad:	89 f0                	mov    %esi,%eax
 804afaf:	e8 fc f7 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804afb4:	8b 03                	mov    (%ebx),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804afb6:	8d 78 f4             	lea    -0xc(%eax),%edi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804afb9:	3b 7c 24 1c          	cmp    0x1c(%esp),%edi
 804afbd:	0f 85 f2 05 00 00    	jne    804b5b5 <_Z10bench_testjPj+0xa65>

					delete entry;
 804afc3:	89 1c 24             	mov    %ebx,(%esp)
 804afc6:	e8 a5 e1 ff ff       	call   8049170 <_ZdlPv@plt>
					buckets_size[num]--;
 804afcb:	8b 5c 24 38          	mov    0x38(%esp),%ebx
 804afcf:	8b 44 24 50          	mov    0x50(%esp),%eax
 804afd3:	03 43 0c             	add    0xc(%ebx),%eax
 804afd6:	83 28 01             	subl   $0x1,(%eax)
 804afd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804afe0:	e8 bb e1 ff ff       	call   80491a0 <_ITM_commitTransaction@plt>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804afe5:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804afec:	e8 bf f7 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804aff1:	8b 44 24 7c          	mov    0x7c(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804aff5:	8d 58 f4             	lea    -0xc(%eax),%ebx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804aff8:	3b 5c 24 1c          	cmp    0x1c(%esp),%ebx
 804affc:	0f 84 5f fd ff ff    	je     804ad61 <_Z10bench_testjPj+0x211>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b002:	83 e8 04             	sub    $0x4,%eax
 804b005:	e8 f3 e4 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b00a:	85 c0                	test   %eax,%eax
 804b00c:	0f 8f 4f fd ff ff    	jg     804ad61 <_Z10bench_testjPj+0x211>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b012:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b019:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b01d:	89 1c 24             	mov    %ebx,(%esp)
 804b020:	e8 5b e2 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b025:	e9 37 fd ff ff       	jmp    804ad61 <_Z10bench_testjPj+0x211>
 804b02a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    // select a random number to guide what operation to perform
    uint32_t act = rand_r(seed) % 100;

    // do an operation using the values we just created
    if (act < Config::CFG.lookpct)
        hash_table->lookup(skey);
 804b030:	8d 44 24 64          	lea    0x64(%esp),%eax
 804b034:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b038:	8d 44 24 6c          	lea    0x6c(%esp),%eax
 804b03c:	89 04 24             	mov    %eax,(%esp)
 804b03f:	e8 ac e1 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804b044:	a1 e8 e4 04 08       	mov    0x804e4e8,%eax
 804b049:	89 c6                	mov    %eax,%esi
 804b04b:	89 44 24 40          	mov    %eax,0x40(%esp)
			}
		}
	}

	V lookup(K key) {
		int num = hash(key);
 804b04f:	8d 44 24 6c          	lea    0x6c(%esp),%eax
 804b053:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b057:	8d 84 24 84 00 00 00 	lea    0x84(%esp),%eax
 804b05e:	89 04 24             	mov    %eax,(%esp)
 804b061:	e8 8a e1 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b066:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
 804b06d:	c7 44 24 08 07 69 0f 	movl   $0xc70f6907,0x8(%esp)
 804b074:	c7 
 804b075:	8b 50 f4             	mov    -0xc(%eax),%edx
 804b078:	89 04 24             	mov    %eax,(%esp)
 804b07b:	89 54 24 04          	mov    %edx,0x4(%esp)
 804b07f:	e8 0c e1 ff ff       	call   8049190 <_ZSt11_Hash_bytesPKvjj@plt>
		}
	}

	int hash(K key) {
		std::hash<K> k_hash;
		return k_hash(key) % TableSize;
 804b084:	31 d2                	xor    %edx,%edx
 804b086:	f7 76 04             	divl   0x4(%esi)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b089:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b090:	89 54 24 44          	mov    %edx,0x44(%esp)
 804b094:	e8 17 f7 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b099:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b0a0:	8d 58 f4             	lea    -0xc(%eax),%ebx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b0a3:	3b 5c 24 1c          	cmp    0x1c(%esp),%ebx
 804b0a7:	0f 85 0b 03 00 00    	jne    804b3b8 <_Z10bench_testjPj+0x868>
 804b0ad:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)
 804b0b4:	e8 f7 e1 ff ff       	call   80492b0 <_ITM_beginTransaction@plt>
 804b0b9:	a8 02                	test   $0x2,%al

	V lookup(K key) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
 804b0bb:	8b 44 24 40          	mov    0x40(%esp),%eax
 804b0bf:	0f 84 d3 00 00 00    	je     804b198 <_Z10bench_testjPj+0x648>
 804b0c5:	8b 00                	mov    (%eax),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b0c7:	8d b4 24 8c 00 00 00 	lea    0x8c(%esp),%esi
 804b0ce:	8b 5c 24 44          	mov    0x44(%esp),%ebx
 804b0d2:	8b 1c 98             	mov    (%eax,%ebx,4),%ebx
 804b0d5:	85 db                	test   %ebx,%ebx
 804b0d7:	74 6f                	je     804b148 <_Z10bench_testjPj+0x5f8>
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804b0d9:	8d 84 24 80 00 00 00 	lea    0x80(%esp),%eax
 804b0e0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804b0e4:	89 04 24             	mov    %eax,(%esp)
 804b0e7:	e8 04 e1 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b0ec:	8b ac 24 80 00 00 00 	mov    0x80(%esp),%ebp
 804b0f3:	8b 44 24 6c          	mov    0x6c(%esp),%eax
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
 804b0f7:	c6 44 24 4e 00       	movb   $0x0,0x4e(%esp)
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804b0fc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
 804b0ff:	3b 48 f4             	cmp    -0xc(%eax),%ecx
 804b102:	75 17                	jne    804b11b <_Z10bench_testjPj+0x5cb>
 804b104:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804b108:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b10c:	89 2c 24             	mov    %ebp,(%esp)
 804b10f:	e8 0c e0 ff ff       	call   8049120 <memcmp@plt>
 804b114:	85 c0                	test   %eax,%eax
 804b116:	0f 94 44 24 4e       	sete   0x4e(%esp)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b11b:	89 f0                	mov    %esi,%eax
 804b11d:	e8 8e f6 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
 804b122:	8d 7d f4             	lea    -0xc(%ebp),%edi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b125:	3b 7c 24 1c          	cmp    0x1c(%esp),%edi
 804b129:	0f 85 ae 03 00 00    	jne    804b4dd <_Z10bench_testjPj+0x98d>
				return V();
			}
			else{
				HashEntry<K,V>* entry = table[num];
				while(entry != NULL) {
					if(entry->key() == key){
 804b12f:	80 7c 24 4e 00       	cmpb   $0x0,0x4e(%esp)
 804b134:	0f 85 8b 03 00 00    	jne    804b4c5 <_Z10bench_testjPj+0x975>
						return entry->value();
					}
					entry = entry->next;
 804b13a:	8b 5b 08             	mov    0x8(%ebx),%ebx
			if(table[num] == NULL){
				return V();
			}
			else{
				HashEntry<K,V>* entry = table[num];
				while(entry != NULL) {
 804b13d:	85 db                	test   %ebx,%ebx
 804b13f:	75 98                	jne    804b0d9 <_Z10bench_testjPj+0x589>
 804b141:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a)
	: _Alloc(__a), _M_p(__dat) { }
 804b148:	8b 44 24 34          	mov    0x34(%esp),%eax
 804b14c:	89 44 24 70          	mov    %eax,0x70(%esp)
 804b150:	e8 4b e0 ff ff       	call   80491a0 <_ITM_commitTransaction@plt>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b155:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b15c:	e8 4f f6 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b161:	8b 44 24 70          	mov    0x70(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b165:	8d 58 f4             	lea    -0xc(%eax),%ebx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b168:	3b 5c 24 1c          	cmp    0x1c(%esp),%ebx
 804b16c:	0f 85 91 03 00 00    	jne    804b503 <_Z10bench_testjPj+0x9b3>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b172:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b179:	e8 32 f6 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b17e:	8b 44 24 6c          	mov    0x6c(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b182:	8d 58 f4             	lea    -0xc(%eax),%ebx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b185:	3b 5c 24 1c          	cmp    0x1c(%esp),%ebx
 804b189:	0f 84 d2 fb ff ff    	je     804ad61 <_Z10bench_testjPj+0x211>
 804b18f:	e9 6e fe ff ff       	jmp    804b002 <_Z10bench_testjPj+0x4b2>
 804b194:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	V lookup(K key) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
 804b198:	e8 43 e2 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804b19d:	8b 5c 24 44          	mov    0x44(%esp),%ebx
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804b1a1:	8d ac 24 80 00 00 00 	lea    0x80(%esp),%ebp

	V lookup(K key) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
 804b1a8:	8d 04 98             	lea    (%eax,%ebx,4),%eax
 804b1ab:	e8 30 e2 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804b1b0:	85 c0                	test   %eax,%eax
 804b1b2:	89 c3                	mov    %eax,%ebx
 804b1b4:	75 38                	jne    804b1ee <_Z10bench_testjPj+0x69e>
 804b1b6:	e9 03 01 00 00       	jmp    804b2be <_Z10bench_testjPj+0x76e>
 804b1bb:	90                   	nop
 804b1bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b1c0:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b1c7:	e8 e4 f5 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
 804b1cc:	8d 56 f4             	lea    -0xc(%esi),%edx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b1cf:	3b 54 24 1c          	cmp    0x1c(%esp),%edx
 804b1d3:	0f 85 42 01 00 00    	jne    804b31b <_Z10bench_testjPj+0x7cb>
				return V();
			}
			else{
				HashEntry<K,V>* entry = table[num];
				while(entry != NULL) {
					if(entry->key() == key){
 804b1d9:	89 f8                	mov    %edi,%eax
 804b1db:	84 c0                	test   %al,%al
 804b1dd:	0f 85 ad 00 00 00    	jne    804b290 <_Z10bench_testjPj+0x740>
						return entry->value();
					}
					entry = entry->next;
 804b1e3:	8b 5b 08             	mov    0x8(%ebx),%ebx
			if(table[num] == NULL){
				return V();
			}
			else{
				HashEntry<K,V>* entry = table[num];
				while(entry != NULL) {
 804b1e6:	85 db                	test   %ebx,%ebx
 804b1e8:	0f 84 5a ff ff ff    	je     804b148 <_Z10bench_testjPj+0x5f8>
 804b1ee:	31 c0                	xor    %eax,%eax
 804b1f0:	e8 cb e1 ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804b1f5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804b1f9:	89 2c 24             	mov    %ebp,(%esp)
 804b1fc:	e8 ef df ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b201:	8b b4 24 80 00 00 00 	mov    0x80(%esp),%esi
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
 804b208:	31 ff                	xor    %edi,%edi
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b20a:	8b 44 24 6c          	mov    0x6c(%esp),%eax
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804b20e:	8b 56 f4             	mov    -0xc(%esi),%edx
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
 804b211:	3b 50 f4             	cmp    -0xc(%eax),%edx
 804b214:	75 aa                	jne    804b1c0 <_Z10bench_testjPj+0x670>
 804b216:	89 54 24 08          	mov    %edx,0x8(%esp)
 804b21a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b21e:	89 34 24             	mov    %esi,(%esp)
 804b221:	e8 fa de ff ff       	call   8049120 <memcmp@plt>
 804b226:	85 c0                	test   %eax,%eax
 804b228:	0f 94 c0             	sete   %al
 804b22b:	89 c7                	mov    %eax,%edi
 804b22d:	eb 91                	jmp    804b1c0 <_Z10bench_testjPj+0x670>
 804b22f:	90                   	nop
					pre_entry = entry;
					entry = entry->next;
				}

				if(entry != NULL) {	//found the key
					if(pre_entry == NULL)
 804b230:	85 ff                	test   %edi,%edi
 804b232:	74 74                	je     804b2a8 <_Z10bench_testjPj+0x758>
						table[num] = NULL;
					else
						pre_entry->next = entry->next;
 804b234:	8b 43 08             	mov    0x8(%ebx),%eax
 804b237:	89 47 08             	mov    %eax,0x8(%edi)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b23a:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b241:	e8 6a f5 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b246:	8b 43 04             	mov    0x4(%ebx),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b249:	8d 70 f4             	lea    -0xc(%eax),%esi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b24c:	3b 74 24 1c          	cmp    0x1c(%esp),%esi
 804b250:	0f 85 07 03 00 00    	jne    804b55d <_Z10bench_testjPj+0xa0d>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b256:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b25d:	e8 4e f5 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b262:	8b 03                	mov    (%ebx),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b264:	8d 70 f4             	lea    -0xc(%eax),%esi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b267:	3b 74 24 1c          	cmp    0x1c(%esp),%esi
 804b26b:	0f 85 bd 02 00 00    	jne    804b52e <_Z10bench_testjPj+0x9de>

					delete entry;
 804b271:	89 1c 24             	mov    %ebx,(%esp)
 804b274:	e8 87 de ff ff       	call   8049100 <_ZGTtdlPv@plt>
					buckets_size[num]--;
 804b279:	8b 74 24 38          	mov    0x38(%esp),%esi
 804b27d:	8b 44 24 48          	mov    0x48(%esp),%eax
 804b281:	03 46 0c             	add    0xc(%esi),%eax
 804b284:	83 28 01             	subl   $0x1,(%eax)
 804b287:	e9 54 fd ff ff       	jmp    804afe0 <_Z10bench_testjPj+0x490>
 804b28c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	K key(){
		return kvpair.first;
	}
	V value(){
		return kvpair.second;
 804b290:	83 c3 04             	add    $0x4,%ebx
 804b293:	8d 44 24 70          	lea    0x70(%esp),%eax
 804b297:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804b29b:	89 04 24             	mov    %eax,(%esp)
 804b29e:	e8 4d df ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804b2a3:	e9 a8 fe ff ff       	jmp    804b150 <_Z10bench_testjPj+0x600>
					entry = entry->next;
				}

				if(entry != NULL) {	//found the key
					if(pre_entry == NULL)
						table[num] = NULL;
 804b2a8:	8b 44 24 38          	mov    0x38(%esp),%eax
 804b2ac:	8b 74 24 3c          	mov    0x3c(%esp),%esi
 804b2b0:	8b 00                	mov    (%eax),%eax
 804b2b2:	c7 04 b0 00 00 00 00 	movl   $0x0,(%eax,%esi,4)
 804b2b9:	e9 7c ff ff ff       	jmp    804b23a <_Z10bench_testjPj+0x6ea>

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a)
	: _Alloc(__a), _M_p(__dat) { }
 804b2be:	8b 54 24 34          	mov    0x34(%esp),%edx
 804b2c2:	8d 44 24 70          	lea    0x70(%esp),%eax
 804b2c6:	e8 05 e0 ff ff       	call   80492d0 <_ITM_WU4@plt>
 804b2cb:	e9 80 fe ff ff       	jmp    804b150 <_Z10bench_testjPj+0x600>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b2d0:	8d 46 fc             	lea    -0x4(%esi),%eax
 804b2d3:	89 4c 24 5c          	mov    %ecx,0x5c(%esp)
 804b2d7:	e8 21 e2 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b2dc:	8b 4c 24 5c          	mov    0x5c(%esp),%ecx
 804b2e0:	85 c0                	test   %eax,%eax
 804b2e2:	0f 8f 31 fc ff ff    	jg     804af19 <_Z10bench_testjPj+0x3c9>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b2e8:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b2ef:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b2f3:	89 0c 24             	mov    %ecx,(%esp)
 804b2f6:	e8 85 df ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b2fb:	e9 19 fc ff ff       	jmp    804af19 <_Z10bench_testjPj+0x3c9>
	_M_set_leaked()
        { this->_M_refcount = -1; }

        void
	_M_set_sharable()
        { this->_M_refcount = 0; }
 804b300:	c7 43 fc 00 00 00 00 	movl   $0x0,-0x4(%ebx)
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      this->_M_set_sharable();  // One reference.
	      this->_M_length = __n;
 804b307:	89 73 f4             	mov    %esi,-0xc(%ebx)
	      traits_type::assign(this->_M_refdata()[__n], _S_terminal);
 804b30a:	89 3c 24             	mov    %edi,(%esp)
 804b30d:	e8 be de ff ff       	call   80491d0 <_ZNSs4_Rep10_M_refdataEv@plt>
      typedef streamoff         off_type;
      typedef mbstate_t         state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
      { __c1 = __c2; }
 804b312:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
 804b316:	e9 f2 f8 ff ff       	jmp    804ac0d <_Z10bench_testjPj+0xbd>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b31b:	8d 46 fc             	lea    -0x4(%esi),%eax
 804b31e:	89 54 24 54          	mov    %edx,0x54(%esp)
 804b322:	e8 d6 e1 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b327:	8b 54 24 54          	mov    0x54(%esp),%edx
 804b32b:	85 c0                	test   %eax,%eax
 804b32d:	0f 8f a6 fe ff ff    	jg     804b1d9 <_Z10bench_testjPj+0x689>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b333:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b33a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b33e:	89 14 24             	mov    %edx,(%esp)
 804b341:	e8 3a df ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b346:	e9 8e fe ff ff       	jmp    804b1d9 <_Z10bench_testjPj+0x689>
	_M_set_leaked()
        { this->_M_refcount = -1; }

        void
	_M_set_sharable()
        { this->_M_refcount = 0; }
 804b34b:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      this->_M_set_sharable();  // One reference.
	      this->_M_length = __n;
 804b352:	89 70 f4             	mov    %esi,-0xc(%eax)
	      traits_type::assign(this->_M_refdata()[__n], _S_terminal);
 804b355:	89 14 24             	mov    %edx,(%esp)
 804b358:	e8 73 de ff ff       	call   80491d0 <_ZNSs4_Rep10_M_refdataEv@plt>
 804b35d:	c6 04 30 00          	movb   $0x0,(%eax,%esi,1)
 804b361:	e9 3b f9 ff ff       	jmp    804aca1 <_Z10bench_testjPj+0x151>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b366:	83 e8 04             	sub    $0x4,%eax
 804b369:	e8 8f e1 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b36e:	85 c0                	test   %eax,%eax
 804b370:	0f 8f 08 fa ff ff    	jg     804ad7e <_Z10bench_testjPj+0x22e>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b376:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b37d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b381:	89 1c 24             	mov    %ebx,(%esp)
 804b384:	e8 f7 de ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b389:	e9 f0 f9 ff ff       	jmp    804ad7e <_Z10bench_testjPj+0x22e>
 804b38e:	66 90                	xchg   %ax,%ax
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b390:	83 e8 04             	sub    $0x4,%eax
 804b393:	e8 65 e1 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b398:	85 c0                	test   %eax,%eax
 804b39a:	0f 8f fb f9 ff ff    	jg     804ad9b <_Z10bench_testjPj+0x24b>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b3a0:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b3a7:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b3ab:	89 1c 24             	mov    %ebx,(%esp)
 804b3ae:	e8 cd de ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b3b3:	e9 e3 f9 ff ff       	jmp    804ad9b <_Z10bench_testjPj+0x24b>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b3b8:	83 e8 04             	sub    $0x4,%eax
 804b3bb:	e8 3d e1 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b3c0:	85 c0                	test   %eax,%eax
 804b3c2:	0f 8f e5 fc ff ff    	jg     804b0ad <_Z10bench_testjPj+0x55d>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b3c8:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b3cf:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b3d3:	89 1c 24             	mov    %ebx,(%esp)
 804b3d6:	e8 a5 de ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b3db:	e9 cd fc ff ff       	jmp    804b0ad <_Z10bench_testjPj+0x55d>
 804b3e0:	89 c3                	mov    %eax,%ebx
 804b3e2:	31 c0                	xor    %eax,%eax
 804b3e4:	c5 f8 77             	vzeroupper 
 804b3e7:	e8 34 de ff ff       	call   8049220 <_ITM_commitTransactionEH@plt>
        hash_table->insert(skey, sval);
//	hash_table->print();
    }
    else {
//    	cout << "To remove an element with key = " << key << endl;
        hash_table->remove(skey);
 804b3ec:	8d 44 24 7c          	lea    0x7c(%esp),%eax
 804b3f0:	89 04 24             	mov    %eax,(%esp)
 804b3f3:	e8 68 de ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 * Run a bunch of random operations
 */
void bench_test(uintptr_t, uint32_t* seed)
{
    uint32_t key, val;
    string skey, sval;
 804b3f8:	8d 44 24 68          	lea    0x68(%esp),%eax
 804b3fc:	89 04 24             	mov    %eax,(%esp)
 804b3ff:	e8 5c de ff ff       	call   8049260 <_ZNSsD1Ev@plt>
    }
    else {
//    	cout << "To remove an element with key = " << key << endl;
        hash_table->remove(skey);
//	hash_table->print();
    }
 804b404:	8d 44 24 64          	lea    0x64(%esp),%eax
 804b408:	89 04 24             	mov    %eax,(%esp)
 804b40b:	e8 50 de ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804b410:	89 1c 24             	mov    %ebx,(%esp)
 804b413:	e8 18 e0 ff ff       	call   8049430 <_Unwind_Resume@plt>
 804b418:	89 c3                	mov    %eax,%ebx
 804b41a:	31 c0                	xor    %eax,%eax
 804b41c:	c5 f8 77             	vzeroupper 
 804b41f:	e8 fc dd ff ff       	call   8049220 <_ITM_commitTransactionEH@plt>
    // select a random number to guide what operation to perform
    uint32_t act = rand_r(seed) % 100;

    // do an operation using the values we just created
    if (act < Config::CFG.lookpct)
        hash_table->lookup(skey);
 804b424:	8d 44 24 6c          	lea    0x6c(%esp),%eax
 804b428:	89 04 24             	mov    %eax,(%esp)
 804b42b:	e8 30 de ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804b430:	eb c6                	jmp    804b3f8 <_Z10bench_testjPj+0x8a8>
 804b432:	89 c3                	mov    %eax,%ebx
 804b434:	c5 f8 77             	vzeroupper 
 804b437:	eb bf                	jmp    804b3f8 <_Z10bench_testjPj+0x8a8>
 804b439:	eb a5                	jmp    804b3e0 <_Z10bench_testjPj+0x890>
 804b43b:	89 c3                	mov    %eax,%ebx
 804b43d:	c5 f8 77             	vzeroupper 
    else if (act < Config::CFG.inspct){
//    	cout << "To insert element (" << key << ", " << val << ")" << endl;
        hash_table->insert(skey, sval);
 804b440:	8d 44 24 78          	lea    0x78(%esp),%eax
 804b444:	89 04 24             	mov    %eax,(%esp)
 804b447:	e8 14 de ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804b44c:	eb aa                	jmp    804b3f8 <_Z10bench_testjPj+0x8a8>
 804b44e:	89 c3                	mov    %eax,%ebx
 804b450:	8d 44 24 74          	lea    0x74(%esp),%eax
 804b454:	89 04 24             	mov    %eax,(%esp)
 804b457:	c5 f8 77             	vzeroupper 
 804b45a:	e8 01 de ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804b45f:	eb df                	jmp    804b440 <_Z10bench_testjPj+0x8f0>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b461:	83 e8 04             	sub    $0x4,%eax
 804b464:	e8 94 e0 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b469:	85 c0                	test   %eax,%eax
 804b46b:	0f 8f d3 f8 ff ff    	jg     804ad44 <_Z10bench_testjPj+0x1f4>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b471:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b478:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b47c:	89 1c 24             	mov    %ebx,(%esp)
 804b47f:	e8 fc dd ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b484:	e9 bb f8 ff ff       	jmp    804ad44 <_Z10bench_testjPj+0x1f4>
 804b489:	89 c3                	mov    %eax,%ebx
 804b48b:	c5 f8 77             	vzeroupper 
 804b48e:	e9 59 ff ff ff       	jmp    804b3ec <_Z10bench_testjPj+0x89c>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b493:	83 e8 04             	sub    $0x4,%eax
 804b496:	e8 62 e0 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b49b:	85 c0                	test   %eax,%eax
 804b49d:	0f 8f 82 f9 ff ff    	jg     804ae25 <_Z10bench_testjPj+0x2d5>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b4a3:	8d 84 24 88 00 00 00 	lea    0x88(%esp),%eax
 804b4aa:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b4ae:	89 1c 24             	mov    %ebx,(%esp)
 804b4b1:	e8 ca dd ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b4b6:	e9 6a f9 ff ff       	jmp    804ae25 <_Z10bench_testjPj+0x2d5>
 804b4bb:	89 c3                	mov    %eax,%ebx
 804b4bd:	c5 f8 77             	vzeroupper 
 804b4c0:	e9 5f ff ff ff       	jmp    804b424 <_Z10bench_testjPj+0x8d4>
	}
	K key(){
		return kvpair.first;
	}
	V value(){
		return kvpair.second;
 804b4c5:	83 c3 04             	add    $0x4,%ebx
 804b4c8:	8d 44 24 70          	lea    0x70(%esp),%eax
 804b4cc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804b4d0:	89 04 24             	mov    %eax,(%esp)
 804b4d3:	e8 18 dd ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804b4d8:	e9 73 fc ff ff       	jmp    804b150 <_Z10bench_testjPj+0x600>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b4dd:	8d 45 fc             	lea    -0x4(%ebp),%eax
 804b4e0:	e8 18 e0 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b4e5:	85 c0                	test   %eax,%eax
 804b4e7:	0f 8f 42 fc ff ff    	jg     804b12f <_Z10bench_testjPj+0x5df>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b4ed:	89 74 24 04          	mov    %esi,0x4(%esp)
 804b4f1:	89 3c 24             	mov    %edi,(%esp)
 804b4f4:	e8 87 dd ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b4f9:	e9 31 fc ff ff       	jmp    804b12f <_Z10bench_testjPj+0x5df>
 804b4fe:	e9 15 ff ff ff       	jmp    804b418 <_Z10bench_testjPj+0x8c8>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b503:	83 e8 04             	sub    $0x4,%eax
 804b506:	e8 f2 df ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b50b:	85 c0                	test   %eax,%eax
 804b50d:	8d 76 00             	lea    0x0(%esi),%esi
 804b510:	0f 8f 5c fc ff ff    	jg     804b172 <_Z10bench_testjPj+0x622>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b516:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b51d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b521:	89 1c 24             	mov    %ebx,(%esp)
 804b524:	e8 57 dd ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b529:	e9 44 fc ff ff       	jmp    804b172 <_Z10bench_testjPj+0x622>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b52e:	83 e8 04             	sub    $0x4,%eax
 804b531:	e8 9c df ff ff       	call   80494d2 <_ZGTtN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.9>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b536:	85 c0                	test   %eax,%eax
 804b538:	0f 8f 33 fd ff ff    	jg     804b271 <_Z10bench_testjPj+0x721>
 804b53e:	31 c0                	xor    %eax,%eax
 804b540:	e8 7b de ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b545:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b54c:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b550:	89 34 24             	mov    %esi,(%esp)
 804b553:	e8 28 dd ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b558:	e9 14 fd ff ff       	jmp    804b271 <_Z10bench_testjPj+0x721>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b55d:	83 e8 04             	sub    $0x4,%eax
 804b560:	e8 6d df ff ff       	call   80494d2 <_ZGTtN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.9>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b565:	85 c0                	test   %eax,%eax
 804b567:	0f 8f e9 fc ff ff    	jg     804b256 <_Z10bench_testjPj+0x706>
 804b56d:	31 c0                	xor    %eax,%eax
 804b56f:	e8 4c de ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b574:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804b57b:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b57f:	89 34 24             	mov    %esi,(%esp)
 804b582:	e8 f9 dc ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b587:	e9 ca fc ff ff       	jmp    804b256 <_Z10bench_testjPj+0x706>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b58c:	8d 45 fc             	lea    -0x4(%ebp),%eax
 804b58f:	89 4c 24 58          	mov    %ecx,0x58(%esp)
 804b593:	e8 65 df ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b598:	8b 4c 24 58          	mov    0x58(%esp),%ecx
 804b59c:	85 c0                	test   %eax,%eax
 804b59e:	0f 8f 12 f9 ff ff    	jg     804aeb6 <_Z10bench_testjPj+0x366>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b5a4:	89 7c 24 04          	mov    %edi,0x4(%esp)
 804b5a8:	89 0c 24             	mov    %ecx,(%esp)
 804b5ab:	e8 d0 dc ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b5b0:	e9 01 f9 ff ff       	jmp    804aeb6 <_Z10bench_testjPj+0x366>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b5b5:	83 e8 04             	sub    $0x4,%eax
 804b5b8:	e8 40 df ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b5bd:	85 c0                	test   %eax,%eax
 804b5bf:	90                   	nop
 804b5c0:	0f 8f fd f9 ff ff    	jg     804afc3 <_Z10bench_testjPj+0x473>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b5c6:	89 74 24 04          	mov    %esi,0x4(%esp)
 804b5ca:	89 3c 24             	mov    %edi,(%esp)
 804b5cd:	e8 ae dc ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b5d2:	e9 ec f9 ff ff       	jmp    804afc3 <_Z10bench_testjPj+0x473>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b5d7:	83 e8 04             	sub    $0x4,%eax
 804b5da:	e8 1e df ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b5df:	85 c0                	test   %eax,%eax
 804b5e1:	0f 8f bf f9 ff ff    	jg     804afa6 <_Z10bench_testjPj+0x456>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b5e7:	89 74 24 04          	mov    %esi,0x4(%esp)
 804b5eb:	89 3c 24             	mov    %edi,(%esp)
 804b5ee:	e8 8d dc ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b5f3:	e9 ae f9 ff ff       	jmp    804afa6 <_Z10bench_testjPj+0x456>
					entry = entry->next;
				}

				if(entry != NULL) {	//found the key
					if(pre_entry == NULL)
						table[num] = NULL;
 804b5f8:	8b 44 24 38          	mov    0x38(%esp),%eax
 804b5fc:	8b 74 24 3c          	mov    0x3c(%esp),%esi
 804b600:	8b 00                	mov    (%eax),%eax
 804b602:	c7 04 b0 00 00 00 00 	movl   $0x0,(%eax,%esi,4)
 804b609:	e9 7a f9 ff ff       	jmp    804af88 <_Z10bench_testjPj+0x438>
 804b60e:	66 90                	xchg   %ax,%ax

0804b610 <_ZGTtNSsD1Ev>:
		     const _Alloc& __a = _Alloc());

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
 804b610:	56                   	push   %esi
 804b611:	53                   	push   %ebx
 804b612:	83 ec 24             	sub    $0x24,%esp
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b615:	8d 44 24 1f          	lea    0x1f(%esp),%eax
 804b619:	e8 92 f1 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b61e:	8b 44 24 30          	mov    0x30(%esp),%eax
 804b622:	e8 b9 dd ff ff       	call   80493e0 <_ITM_RU4@plt>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b627:	8d 58 f4             	lea    -0xc(%eax),%ebx
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b62a:	89 c6                	mov    %eax,%esi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b62c:	e8 df dd ff ff       	call   8049410 <_ZNSs4_Rep12_S_empty_repEv@plt>
 804b631:	39 c3                	cmp    %eax,%ebx
 804b633:	75 06                	jne    804b63b <_ZGTtNSsD1Ev+0x2b>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b635:	83 c4 24             	add    $0x24,%esp
 804b638:	5b                   	pop    %ebx
 804b639:	5e                   	pop    %esi
 804b63a:	c3                   	ret    
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b63b:	8d 46 fc             	lea    -0x4(%esi),%eax
 804b63e:	e8 8f de ff ff       	call   80494d2 <_ZGTtN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.9>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b643:	85 c0                	test   %eax,%eax
 804b645:	7f ee                	jg     804b635 <_ZGTtNSsD1Ev+0x25>
 804b647:	31 c0                	xor    %eax,%eax
 804b649:	e8 72 dd ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b64e:	8d 44 24 1f          	lea    0x1f(%esp),%eax
 804b652:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b656:	89 1c 24             	mov    %ebx,(%esp)
 804b659:	e8 22 dc ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804b65e:	eb d5                	jmp    804b635 <_ZGTtNSsD1Ev+0x25>

0804b660 <_ZGTtNSsC1Ev>:
      // arguments, per 17.4.4.4 para. 2 item 2.

      /**
       *  @brief  Default constructor creates an empty string.
       */
      basic_string()
 804b660:	83 ec 1c             	sub    $0x1c,%esp
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
 804b663:	e8 d8 dd ff ff       	call   8049440 <_ZNSs12_S_empty_repEv@plt>
 804b668:	89 04 24             	mov    %eax,(%esp)
 804b66b:	e8 60 db ff ff       	call   80491d0 <_ZNSs4_Rep10_M_refdataEv@plt>

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a)
	: _Alloc(__a), _M_p(__dat) { }
 804b670:	89 c2                	mov    %eax,%edx
 804b672:	8b 44 24 20          	mov    0x20(%esp),%eax
 804b676:	e8 55 dc ff ff       	call   80492d0 <_ITM_WU4@plt>
      /**
       *  @brief  Default constructor creates an empty string.
       */
      basic_string()
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
 804b67b:	83 c4 1c             	add    $0x1c,%esp
 804b67e:	c3                   	ret    
 804b67f:	90                   	nop

0804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>:
 804b680:	8b 44 24 04          	mov    0x4(%esp),%eax
 804b684:	c3                   	ret    
 804b685:	66 90                	xchg   %ax,%ax
 804b687:	66 90                	xchg   %ax,%ax
 804b689:	66 90                	xchg   %ax,%ax
 804b68b:	66 90                	xchg   %ax,%ax
 804b68d:	66 90                	xchg   %ax,%ax
 804b68f:	90                   	nop

0804b690 <_ZN9HashTableISsSsE6insertESsSs>:
				return V();
			}
		}
	}

	bool insert(K key, V val) {
 804b690:	55                   	push   %ebp
 804b691:	57                   	push   %edi
 804b692:	56                   	push   %esi
 804b693:	53                   	push   %ebx
 804b694:	81 ec bc 00 00 00    	sub    $0xbc,%esp
		int num = hash(key);
 804b69a:	8b 84 24 d4 00 00 00 	mov    0xd4(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b6a1:	8d b4 24 a8 00 00 00 	lea    0xa8(%esp),%esi
 804b6a8:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b6ac:	8d 84 24 ac 00 00 00 	lea    0xac(%esp),%eax
 804b6b3:	89 04 24             	mov    %eax,(%esp)
 804b6b6:	e8 35 db ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b6bb:	8b 84 24 ac 00 00 00 	mov    0xac(%esp),%eax
 804b6c2:	c7 44 24 08 07 69 0f 	movl   $0xc70f6907,0x8(%esp)
 804b6c9:	c7 
 804b6ca:	8b 50 f4             	mov    -0xc(%eax),%edx
 804b6cd:	89 04 24             	mov    %eax,(%esp)
 804b6d0:	89 54 24 04          	mov    %edx,0x4(%esp)
 804b6d4:	e8 b7 da ff ff       	call   8049190 <_ZSt11_Hash_bytesPKvjj@plt>
		}
	}

	int hash(K key) {
		std::hash<K> k_hash;
		return k_hash(key) % TableSize;
 804b6d9:	8b 8c 24 d0 00 00 00 	mov    0xd0(%esp),%ecx
 804b6e0:	31 d2                	xor    %edx,%edx
 804b6e2:	f7 71 04             	divl   0x4(%ecx)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b6e5:	89 f0                	mov    %esi,%eax
 804b6e7:	89 54 24 2c          	mov    %edx,0x2c(%esp)
 804b6eb:	e8 c0 f0 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b6f0:	8b bc 24 ac 00 00 00 	mov    0xac(%esp),%edi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b6f7:	e8 14 dd ff ff       	call   8049410 <_ZNSs4_Rep12_S_empty_repEv@plt>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b6fc:	8d 5f f4             	lea    -0xc(%edi),%ebx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b6ff:	39 c3                	cmp    %eax,%ebx
 804b701:	89 44 24 14          	mov    %eax,0x14(%esp)
 804b705:	0f 85 21 04 00 00    	jne    804bb2c <_ZN9HashTableISsSsE6insertESsSs+0x49c>
	}

	bool insert(K key, V val) {
		int num = hash(key);

		__transaction_relaxed {
 804b70b:	c7 04 24 4a 40 00 00 	movl   $0x404a,(%esp)
 804b712:	e8 99 db ff ff       	call   80492b0 <_ITM_beginTransaction@plt>
			if(table[num] == NULL){
 804b717:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
 804b71b:	a8 02                	test   $0x2,%al
 804b71d:	89 c8                	mov    %ecx,%eax
 804b71f:	0f 84 bb 00 00 00    	je     804b7e0 <_ZN9HashTableISsSsE6insertESsSs+0x150>
 804b725:	c1 e0 02             	shl    $0x2,%eax
				buckets_size[num]++;
				return true;
			}
			else{
				HashEntry<K,V> * entry = table[num];
				HashEntry<K,V> * pre_entry = NULL;
 804b728:	31 ff                	xor    %edi,%edi

	bool insert(K key, V val) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
 804b72a:	89 44 24 34          	mov    %eax,0x34(%esp)
 804b72e:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804b735:	8b 00                	mov    (%eax),%eax
 804b737:	8b 1c 88             	mov    (%eax,%ecx,4),%ebx
 804b73a:	85 db                	test   %ebx,%ebx
 804b73c:	0f 84 ec 02 00 00    	je     804ba2e <_ZN9HashTableISsSsE6insertESsSs+0x39e>
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804b742:	8d 84 24 ac 00 00 00 	lea    0xac(%esp),%eax
 804b749:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804b74d:	89 04 24             	mov    %eax,(%esp)
 804b750:	89 5c 24 44          	mov    %ebx,0x44(%esp)
 804b754:	e8 97 da ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b759:	8b b4 24 ac 00 00 00 	mov    0xac(%esp),%esi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804b760:	8b 46 f4             	mov    -0xc(%esi),%eax
 804b763:	89 c1                	mov    %eax,%ecx
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b765:	8b 84 24 d4 00 00 00 	mov    0xd4(%esp),%eax
 804b76c:	89 4c 24 48          	mov    %ecx,0x48(%esp)
 804b770:	8b 00                	mov    (%eax),%eax
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804b772:	8b 50 f4             	mov    -0xc(%eax),%edx
		< static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }
 804b775:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b779:	89 34 24             	mov    %esi,(%esp)
 804b77c:	39 ca                	cmp    %ecx,%edx
 804b77e:	0f 46 ca             	cmovbe %edx,%ecx
 804b781:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804b785:	89 54 24 50          	mov    %edx,0x50(%esp)
 804b789:	e8 92 d9 ff ff       	call   8049120 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
 804b78e:	85 c0                	test   %eax,%eax
 804b790:	89 c5                	mov    %eax,%ebp
 804b792:	75 16                	jne    804b7aa <_ZN9HashTableISsSsE6insertESsSs+0x11a>
	  __r = _S_compare(__size, __osize);
 804b794:	8b 54 24 50          	mov    0x50(%esp),%edx
 804b798:	8b 44 24 48          	mov    0x48(%esp),%eax
 804b79c:	89 54 24 04          	mov    %edx,0x4(%esp)
 804b7a0:	89 04 24             	mov    %eax,(%esp)
 804b7a3:	e8 88 db ff ff       	call   8049330 <_ZNSs10_S_compareEjj@plt>
 804b7a8:	89 c5                	mov    %eax,%ebp

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b7aa:	8d 84 24 a8 00 00 00 	lea    0xa8(%esp),%eax
 804b7b1:	e8 fa ef ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
 804b7b6:	8d 56 f4             	lea    -0xc(%esi),%edx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b7b9:	39 54 24 14          	cmp    %edx,0x14(%esp)
 804b7bd:	0f 85 34 10 00 00    	jne    804c7f7 <_ZN9HashTableISsSsE6insertESsSs+0x1167>
			}
			else{
				HashEntry<K,V> * entry = table[num];
				HashEntry<K,V> * pre_entry = NULL;
				while (entry != NULL) {
					if(entry->key() >= key)
 804b7c3:	85 ed                	test   %ebp,%ebp
 804b7c5:	0f 89 e2 0e 00 00    	jns    804c6ad <_ZN9HashTableISsSsE6insertESsSs+0x101d>
						break;
					pre_entry = entry;
					entry = entry->next;
 804b7cb:	8b 43 08             	mov    0x8(%ebx),%eax
				return true;
			}
			else{
				HashEntry<K,V> * entry = table[num];
				HashEntry<K,V> * pre_entry = NULL;
				while (entry != NULL) {
 804b7ce:	85 c0                	test   %eax,%eax
 804b7d0:	0f 84 77 03 00 00    	je     804bb4d <_ZN9HashTableISsSsE6insertESsSs+0x4bd>
 804b7d6:	89 df                	mov    %ebx,%edi
					if(entry->key() >= key)
						break;
					pre_entry = entry;
					entry = entry->next;
 804b7d8:	89 c3                	mov    %eax,%ebx
 804b7da:	e9 63 ff ff ff       	jmp    804b742 <_ZN9HashTableISsSsE6insertESsSs+0xb2>
 804b7df:	90                   	nop

	bool insert(K key, V val) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
 804b7e0:	c1 e0 02             	shl    $0x2,%eax
				buckets_size[num]++;
				return true;
			}
			else{
				HashEntry<K,V> * entry = table[num];
				HashEntry<K,V> * pre_entry = NULL;
 804b7e3:	31 ff                	xor    %edi,%edi

	bool insert(K key, V val) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
 804b7e5:	89 44 24 30          	mov    %eax,0x30(%esp)
 804b7e9:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804b7f0:	8b 00                	mov    (%eax),%eax
 804b7f2:	8b 1c 88             	mov    (%eax,%ecx,4),%ebx
 804b7f5:	85 db                	test   %ebx,%ebx
 804b7f7:	75 21                	jne    804b81a <_ZN9HashTableISsSsE6insertESsSs+0x18a>
 804b7f9:	e9 92 0b 00 00       	jmp    804c390 <_ZN9HashTableISsSsE6insertESsSs+0xd00>
 804b7fe:	66 90                	xchg   %ax,%ax
			}
			else{
				HashEntry<K,V> * entry = table[num];
				HashEntry<K,V> * pre_entry = NULL;
				while (entry != NULL) {
					if(entry->key() >= key)
 804b800:	85 ed                	test   %ebp,%ebp
 804b802:	0f 89 c6 00 00 00    	jns    804b8ce <_ZN9HashTableISsSsE6insertESsSs+0x23e>
						break;
					pre_entry = entry;
					entry = entry->next;
 804b808:	8b 43 08             	mov    0x8(%ebx),%eax
				return true;
			}
			else{
				HashEntry<K,V> * entry = table[num];
				HashEntry<K,V> * pre_entry = NULL;
				while (entry != NULL) {
 804b80b:	85 c0                	test   %eax,%eax
 804b80d:	8d 76 00             	lea    0x0(%esi),%esi
 804b810:	0f 84 6b 0c 00 00    	je     804c481 <_ZN9HashTableISsSsE6insertESsSs+0xdf1>
 804b816:	89 df                	mov    %ebx,%edi
					if(entry->key() >= key)
						break;
					pre_entry = entry;
					entry = entry->next;
 804b818:	89 c3                	mov    %eax,%ebx
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804b81a:	8d 84 24 ac 00 00 00 	lea    0xac(%esp),%eax
 804b821:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804b825:	89 04 24             	mov    %eax,(%esp)
 804b828:	89 5c 24 40          	mov    %ebx,0x40(%esp)
 804b82c:	e8 bf d9 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b831:	8b b4 24 ac 00 00 00 	mov    0xac(%esp),%esi
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804b838:	8b 46 f4             	mov    -0xc(%esi),%eax
 804b83b:	89 c1                	mov    %eax,%ecx
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b83d:	8b 84 24 d4 00 00 00 	mov    0xd4(%esp),%eax
 804b844:	89 4c 24 4c          	mov    %ecx,0x4c(%esp)
 804b848:	8b 00                	mov    (%eax),%eax
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804b84a:	8b 50 f4             	mov    -0xc(%eax),%edx
 804b84d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b851:	89 34 24             	mov    %esi,(%esp)
 804b854:	39 ca                	cmp    %ecx,%edx
 804b856:	0f 46 ca             	cmovbe %edx,%ecx
 804b859:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804b85d:	89 54 24 60          	mov    %edx,0x60(%esp)
 804b861:	e8 ba d8 ff ff       	call   8049120 <memcmp@plt>
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
 804b866:	85 c0                	test   %eax,%eax
 804b868:	89 c5                	mov    %eax,%ebp
 804b86a:	75 16                	jne    804b882 <_ZN9HashTableISsSsE6insertESsSs+0x1f2>
	  __r = _S_compare(__size, __osize);
 804b86c:	8b 54 24 60          	mov    0x60(%esp),%edx
 804b870:	8b 44 24 4c          	mov    0x4c(%esp),%eax
 804b874:	89 54 24 04          	mov    %edx,0x4(%esp)
 804b878:	89 04 24             	mov    %eax,(%esp)
 804b87b:	e8 b0 da ff ff       	call   8049330 <_ZNSs10_S_compareEjj@plt>
 804b880:	89 c5                	mov    %eax,%ebp

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b882:	8d 84 24 a8 00 00 00 	lea    0xa8(%esp),%eax
 804b889:	e8 22 ef ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
 804b88e:	8d 56 f4             	lea    -0xc(%esi),%edx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b891:	39 54 24 14          	cmp    %edx,0x14(%esp)
 804b895:	0f 84 65 ff ff ff    	je     804b800 <_ZN9HashTableISsSsE6insertESsSs+0x170>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804b89b:	8d 46 fc             	lea    -0x4(%esi),%eax
 804b89e:	89 54 24 64          	mov    %edx,0x64(%esp)
 804b8a2:	e8 56 dc ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804b8a7:	8b 54 24 64          	mov    0x64(%esp),%edx
 804b8ab:	85 c0                	test   %eax,%eax
 804b8ad:	0f 8f 4d ff ff ff    	jg     804b800 <_ZN9HashTableISsSsE6insertESsSs+0x170>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804b8b3:	8d 84 24 a8 00 00 00 	lea    0xa8(%esp),%eax
 804b8ba:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b8be:	89 14 24             	mov    %edx,(%esp)
 804b8c1:	e8 ba d9 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
			}
			else{
				HashEntry<K,V> * entry = table[num];
				HashEntry<K,V> * pre_entry = NULL;
				while (entry != NULL) {
					if(entry->key() >= key)
 804b8c6:	85 ed                	test   %ebp,%ebp
 804b8c8:	0f 88 3a ff ff ff    	js     804b808 <_ZN9HashTableISsSsE6insertESsSs+0x178>
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804b8ce:	8b 44 24 40          	mov    0x40(%esp),%eax
 804b8d2:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b8d6:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
 804b8dd:	89 04 24             	mov    %eax,(%esp)
 804b8e0:	e8 0b d9 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b8e5:	8b 84 24 d4 00 00 00 	mov    0xd4(%esp),%eax
 804b8ec:	8b b4 24 94 00 00 00 	mov    0x94(%esp),%esi
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
 804b8f3:	c6 44 24 3f 00       	movb   $0x0,0x3f(%esp)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b8f8:	8b 00                	mov    (%eax),%eax
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804b8fa:	8b 4e f4             	mov    -0xc(%esi),%ecx
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
 804b8fd:	3b 48 f4             	cmp    -0xc(%eax),%ecx
 804b900:	75 17                	jne    804b919 <_ZN9HashTableISsSsE6insertESsSs+0x289>
 804b902:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804b906:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b90a:	89 34 24             	mov    %esi,(%esp)
 804b90d:	e8 0e d8 ff ff       	call   8049120 <memcmp@plt>
 804b912:	85 c0                	test   %eax,%eax
 804b914:	0f 94 44 24 3f       	sete   0x3f(%esp)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b919:	8d 84 24 ac 00 00 00 	lea    0xac(%esp),%eax
 804b920:	e8 8b ee ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
 804b925:	8d 6e f4             	lea    -0xc(%esi),%ebp

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b928:	39 6c 24 14          	cmp    %ebp,0x14(%esp)
 804b92c:	0f 85 9f 0c 00 00    	jne    804c5d1 <_ZN9HashTableISsSsE6insertESsSs+0xf41>
				if(entry == NULL) {
					pre_entry->next = new HashEntry<K,V>(key, val);
					buckets_size[num]++;
				}
				else if (entry->key() == key)	//the key has already in the table
					return false;
 804b932:	31 f6                	xor    %esi,%esi

				if(entry == NULL) {
					pre_entry->next = new HashEntry<K,V>(key, val);
					buckets_size[num]++;
				}
				else if (entry->key() == key)	//the key has already in the table
 804b934:	80 7c 24 3f 00       	cmpb   $0x0,0x3f(%esp)
 804b939:	0f 85 db 01 00 00    	jne    804bb1a <_ZN9HashTableISsSsE6insertESsSs+0x48a>
					return false;
				else {	//entry->key > key
					HashEntry<K,V> * e = new HashEntry<K,V>(key, val);
 804b93f:	8b 84 24 d4 00 00 00 	mov    0xd4(%esp),%eax
 804b946:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b94a:	8d 84 24 98 00 00 00 	lea    0x98(%esp),%eax
 804b951:	89 04 24             	mov    %eax,(%esp)
 804b954:	e8 97 d8 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804b959:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
 804b960:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b964:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
 804b96b:	89 04 24             	mov    %eax,(%esp)
 804b96e:	e8 7d d8 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804b973:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
 804b97a:	e8 c1 d9 ff ff       	call   8049340 <_Znwj@plt>
 804b97f:	89 c6                	mov    %eax,%esi

      template<class _U1, class _U2, class = typename
	       enable_if<__and_<is_convertible<_U1, _T1>,
				is_convertible<_U2, _T2>>::value>::type>
	constexpr pair(_U1&& __x, _U2&& __y)
	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
 804b981:	8d 84 24 98 00 00 00 	lea    0x98(%esp),%eax
 804b988:	89 04 24             	mov    %eax,(%esp)
 804b98b:	e8 f0 fc ff ff       	call   804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>
 804b990:	89 34 24             	mov    %esi,(%esp)
 804b993:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b997:	e8 54 d8 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804b99c:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
 804b9a3:	89 04 24             	mov    %eax,(%esp)
 804b9a6:	e8 d5 fc ff ff       	call   804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>
 804b9ab:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b9af:	8d 46 04             	lea    0x4(%esi),%eax
 804b9b2:	89 04 24             	mov    %eax,(%esp)
 804b9b5:	e8 36 d8 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b9ba:	8d ac 24 ac 00 00 00 	lea    0xac(%esp),%ebp
 804b9c1:	89 e8                	mov    %ebp,%eax
template <class K, class V>
class HashEntry {
	pair<K,V> kvpair;
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
 804b9c3:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
 804b9ca:	e8 e1 ed ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b9cf:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b9d6:	8d 50 f4             	lea    -0xc(%eax),%edx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b9d9:	39 54 24 14          	cmp    %edx,0x14(%esp)
 804b9dd:	0f 85 8c 0c 00 00    	jne    804c66f <_ZN9HashTableISsSsE6insertESsSs+0xfdf>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b9e3:	8d ac 24 ac 00 00 00 	lea    0xac(%esp),%ebp
 804b9ea:	89 e8                	mov    %ebp,%eax
 804b9ec:	e8 bf ed ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804b9f1:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804b9f8:	8d 50 f4             	lea    -0xc(%eax),%edx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804b9fb:	39 54 24 14          	cmp    %edx,0x14(%esp)
 804b9ff:	0f 85 41 0c 00 00    	jne    804c646 <_ZN9HashTableISsSsE6insertESsSs+0xfb6>
				else if (entry->key() == key)	//the key has already in the table
					return false;
				else {	//entry->key > key
					HashEntry<K,V> * e = new HashEntry<K,V>(key, val);
					e->next = entry;
					if(pre_entry)
 804ba05:	85 ff                	test   %edi,%edi
				}
				else if (entry->key() == key)	//the key has already in the table
					return false;
				else {	//entry->key > key
					HashEntry<K,V> * e = new HashEntry<K,V>(key, val);
					e->next = entry;
 804ba07:	89 5e 08             	mov    %ebx,0x8(%esi)
					if(pre_entry)
 804ba0a:	0f 84 88 0c 00 00    	je     804c698 <_ZN9HashTableISsSsE6insertESsSs+0x1008>
						pre_entry->next = e;
 804ba10:	89 77 08             	mov    %esi,0x8(%edi)
 804ba13:	e9 32 0b 00 00       	jmp    804c54a <_ZN9HashTableISsSsE6insertESsSs+0xeba>
 804ba18:	89 c3                	mov    %eax,%ebx
 804ba1a:	c5 f8 77             	vzeroupper 
 804ba1d:	31 c0                	xor    %eax,%eax
 804ba1f:	e8 fc d7 ff ff       	call   8049220 <_ITM_commitTransactionEH@plt>
 804ba24:	89 1c 24             	mov    %ebx,(%esp)
 804ba27:	e8 04 da ff ff       	call   8049430 <_Unwind_Resume@plt>
 804ba2c:	eb ea                	jmp    804ba18 <_ZN9HashTableISsSsE6insertESsSs+0x388>
	bool insert(K key, V val) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
				table[num] = new HashEntry<K,V>(key, val);
 804ba2e:	8b 84 24 d4 00 00 00 	mov    0xd4(%esp),%eax
 804ba35:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ba39:	8d 84 24 84 00 00 00 	lea    0x84(%esp),%eax
 804ba40:	89 04 24             	mov    %eax,(%esp)
 804ba43:	e8 a8 d7 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804ba48:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
 804ba4f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ba53:	8d 84 24 88 00 00 00 	lea    0x88(%esp),%eax
 804ba5a:	89 04 24             	mov    %eax,(%esp)
 804ba5d:	e8 8e d7 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804ba62:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
 804ba69:	e8 d2 d8 ff ff       	call   8049340 <_Znwj@plt>
 804ba6e:	89 c3                	mov    %eax,%ebx
 804ba70:	8d 84 24 84 00 00 00 	lea    0x84(%esp),%eax
 804ba77:	89 04 24             	mov    %eax,(%esp)
 804ba7a:	e8 01 fc ff ff       	call   804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>
 804ba7f:	89 1c 24             	mov    %ebx,(%esp)
 804ba82:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ba86:	e8 65 d7 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804ba8b:	8d 84 24 88 00 00 00 	lea    0x88(%esp),%eax
 804ba92:	89 04 24             	mov    %eax,(%esp)
 804ba95:	e8 e6 fb ff ff       	call   804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>
 804ba9a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ba9e:	8d 43 04             	lea    0x4(%ebx),%eax
 804baa1:	89 04 24             	mov    %eax,(%esp)
 804baa4:	e8 47 d7 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804baa9:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804bab0:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
template <class K, class V>
class HashEntry {
	pair<K,V> kvpair;
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
 804bab4:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	bool insert(K key, V val) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
				table[num] = new HashEntry<K,V>(key, val);
 804babb:	8b 00                	mov    (%eax),%eax
 804babd:	89 1c 88             	mov    %ebx,(%eax,%ecx,4)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804bac0:	8d 9c 24 a8 00 00 00 	lea    0xa8(%esp),%ebx
 804bac7:	89 d8                	mov    %ebx,%eax
 804bac9:	e8 e2 ec ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804bace:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804bad5:	8d 70 f4             	lea    -0xc(%eax),%esi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804bad8:	39 74 24 14          	cmp    %esi,0x14(%esp)
 804badc:	0f 85 2c 0e 00 00    	jne    804c90e <_ZN9HashTableISsSsE6insertESsSs+0x127e>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804bae2:	8d 9c 24 a8 00 00 00 	lea    0xa8(%esp),%ebx
 804bae9:	89 d8                	mov    %ebx,%eax
 804baeb:	e8 c0 ec ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804baf0:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804baf7:	8d 70 f4             	lea    -0xc(%eax),%esi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804bafa:	39 74 24 14          	cmp    %esi,0x14(%esp)
 804bafe:	0f 85 e1 0d 00 00    	jne    804c8e5 <_ZN9HashTableISsSsE6insertESsSs+0x1255>
				buckets_size[num]++;
 804bb04:	8b 8c 24 d0 00 00 00 	mov    0xd0(%esp),%ecx
				return true;
 804bb0b:	be 01 00 00 00       	mov    $0x1,%esi
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
				table[num] = new HashEntry<K,V>(key, val);
				buckets_size[num]++;
 804bb10:	8b 44 24 34          	mov    0x34(%esp),%eax
 804bb14:	03 41 0c             	add    0xc(%ecx),%eax
 804bb17:	83 00 01             	addl   $0x1,(%eax)
				return true;
 804bb1a:	e8 81 d6 ff ff       	call   80491a0 <_ITM_commitTransaction@plt>

		__transaction_relaxed {
			resize();
			return true;
		}
	}
 804bb1f:	81 c4 bc 00 00 00    	add    $0xbc,%esp
 804bb25:	89 f0                	mov    %esi,%eax
 804bb27:	5b                   	pop    %ebx
 804bb28:	5e                   	pop    %esi
 804bb29:	5f                   	pop    %edi
 804bb2a:	5d                   	pop    %ebp
 804bb2b:	c3                   	ret    
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804bb2c:	8d 47 fc             	lea    -0x4(%edi),%eax
 804bb2f:	e8 c9 d9 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804bb34:	85 c0                	test   %eax,%eax
 804bb36:	0f 8f cf fb ff ff    	jg     804b70b <_ZN9HashTableISsSsE6insertESsSs+0x7b>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804bb3c:	89 74 24 04          	mov    %esi,0x4(%esp)
 804bb40:	89 1c 24             	mov    %ebx,(%esp)
 804bb43:	e8 38 d7 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804bb48:	e9 be fb ff ff       	jmp    804b70b <_ZN9HashTableISsSsE6insertESsSs+0x7b>
					pre_entry = entry;
					entry = entry->next;
				}

				if(entry == NULL) {
					pre_entry->next = new HashEntry<K,V>(key, val);
 804bb4d:	8b 84 24 d4 00 00 00 	mov    0xd4(%esp),%eax
 804bb54:	89 44 24 04          	mov    %eax,0x4(%esp)
 804bb58:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804bb5f:	89 04 24             	mov    %eax,(%esp)
 804bb62:	e8 89 d6 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804bb67:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
 804bb6e:	89 44 24 04          	mov    %eax,0x4(%esp)
 804bb72:	8d 84 24 90 00 00 00 	lea    0x90(%esp),%eax
 804bb79:	89 04 24             	mov    %eax,(%esp)
 804bb7c:	e8 6f d6 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804bb81:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
 804bb88:	e8 b3 d7 ff ff       	call   8049340 <_Znwj@plt>
 804bb8d:	89 c6                	mov    %eax,%esi
 804bb8f:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804bb96:	89 04 24             	mov    %eax,(%esp)
 804bb99:	e8 e2 fa ff ff       	call   804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>
 804bb9e:	89 34 24             	mov    %esi,(%esp)
 804bba1:	89 44 24 04          	mov    %eax,0x4(%esp)
 804bba5:	e8 46 d6 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804bbaa:	8d 84 24 90 00 00 00 	lea    0x90(%esp),%eax
 804bbb1:	89 04 24             	mov    %eax,(%esp)
 804bbb4:	e8 c7 fa ff ff       	call   804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>
 804bbb9:	89 44 24 04          	mov    %eax,0x4(%esp)
 804bbbd:	8d 46 04             	lea    0x4(%esi),%eax
 804bbc0:	89 04 24             	mov    %eax,(%esp)
 804bbc3:	e8 28 d6 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
template <class K, class V>
class HashEntry {
	pair<K,V> kvpair;
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
 804bbc8:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
					pre_entry = entry;
					entry = entry->next;
				}

				if(entry == NULL) {
					pre_entry->next = new HashEntry<K,V>(key, val);
 804bbcf:	89 73 08             	mov    %esi,0x8(%ebx)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804bbd2:	8d 9c 24 ac 00 00 00 	lea    0xac(%esp),%ebx
 804bbd9:	89 d8                	mov    %ebx,%eax
 804bbdb:	e8 d0 eb ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804bbe0:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804bbe7:	8d 70 f4             	lea    -0xc(%eax),%esi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804bbea:	39 74 24 14          	cmp    %esi,0x14(%esp)
 804bbee:	0f 85 27 07 00 00    	jne    804c31b <_ZN9HashTableISsSsE6insertESsSs+0xc8b>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804bbf4:	8d 9c 24 ac 00 00 00 	lea    0xac(%esp),%ebx
 804bbfb:	89 d8                	mov    %ebx,%eax
 804bbfd:	e8 ae eb ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804bc02:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804bc09:	8d 70 f4             	lea    -0xc(%eax),%esi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804bc0c:	39 74 24 14          	cmp    %esi,0x14(%esp)
 804bc10:	0f 85 91 04 00 00    	jne    804c0a7 <_ZN9HashTableISsSsE6insertESsSs+0xa17>
					e->next = entry;
					if(pre_entry)
						pre_entry->next = e;
					else
						table[num] = e;
					buckets_size[num]++;
 804bc16:	8b 8c 24 d0 00 00 00 	mov    0xd0(%esp),%ecx
 804bc1d:	8b 44 24 34          	mov    0x34(%esp),%eax
 804bc21:	03 41 0c             	add    0xc(%ecx),%eax
 804bc24:	83 00 01             	addl   $0x1,(%eax)
 804bc27:	e8 74 d5 ff ff       	call   80491a0 <_ITM_commitTransaction@plt>
				}
			}
		}

		__transaction_relaxed {
 804bc2c:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)
 804bc33:	e8 78 d6 ff ff       	call   80492b0 <_ITM_beginTransaction@plt>
 804bc38:	a8 02                	test   $0x2,%al
 804bc3a:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804bc41:	0f 85 0e 04 00 00    	jne    804c055 <_ZN9HashTableISsSsE6insertESsSs+0x9c5>
 804bc47:	8d 58 04             	lea    0x4(%eax),%ebx
 804bc4a:	89 d8                	mov    %ebx,%eax
 804bc4c:	e8 8f d7 ff ff       	call   80493e0 <_ITM_RU4@plt>
		return true;
	}

	void resize() {
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);
 804bc51:	89 5c 24 38          	mov    %ebx,0x38(%esp)
 804bc55:	89 c7                	mov    %eax,%edi
			if (table[i] != NULL) {
				int count = 0;
				for (HashEntry<K,V> * e = table[i]; e != NULL; e = e->next) {
					count++;
				}
				if(count > BucketCapacity)
 804bc57:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804bc5e:	83 c0 08             	add    $0x8,%eax
 804bc61:	89 44 24 28          	mov    %eax,0x28(%esp)

template <class K, class V>
class HashTable{
private:
	bool check_buckets_size() {
		for(int i = 0; i < TableSize; ++i) {
 804bc65:	85 ff                	test   %edi,%edi
 804bc67:	7e 4a                	jle    804bcb3 <_ZN9HashTableISsSsE6insertESsSs+0x623>
 804bc69:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804bc70:	31 f6                	xor    %esi,%esi
 804bc72:	e8 69 d7 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bc77:	89 c5                	mov    %eax,%ebp
 804bc79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804bc80:	8d 44 b5 00          	lea    0x0(%ebp,%esi,4),%eax
			if (table[i] != NULL) {
				int count = 0;
 804bc84:	31 db                	xor    %ebx,%ebx
template <class K, class V>
class HashTable{
private:
	bool check_buckets_size() {
		for(int i = 0; i < TableSize; ++i) {
			if (table[i] != NULL) {
 804bc86:	e8 55 d7 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bc8b:	85 c0                	test   %eax,%eax
 804bc8d:	74 1d                	je     804bcac <_ZN9HashTableISsSsE6insertESsSs+0x61c>
 804bc8f:	90                   	nop
				int count = 0;
				for (HashEntry<K,V> * e = table[i]; e != NULL; e = e->next) {
 804bc90:	83 c0 08             	add    $0x8,%eax
					count++;
 804bc93:	83 c3 01             	add    $0x1,%ebx
private:
	bool check_buckets_size() {
		for(int i = 0; i < TableSize; ++i) {
			if (table[i] != NULL) {
				int count = 0;
				for (HashEntry<K,V> * e = table[i]; e != NULL; e = e->next) {
 804bc96:	e8 45 d7 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bc9b:	85 c0                	test   %eax,%eax
 804bc9d:	75 f1                	jne    804bc90 <_ZN9HashTableISsSsE6insertESsSs+0x600>
					count++;
				}
				if(count > BucketCapacity)
 804bc9f:	8b 44 24 28          	mov    0x28(%esp),%eax
 804bca3:	e8 38 d7 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bca8:	39 d8                	cmp    %ebx,%eax
 804bcaa:	7c 1c                	jl     804bcc8 <_ZN9HashTableISsSsE6insertESsSs+0x638>

template <class K, class V>
class HashTable{
private:
	bool check_buckets_size() {
		for(int i = 0; i < TableSize; ++i) {
 804bcac:	83 c6 01             	add    $0x1,%esi
 804bcaf:	39 fe                	cmp    %edi,%esi
 804bcb1:	75 cd                	jne    804bc80 <_ZN9HashTableISsSsE6insertESsSs+0x5f0>
 804bcb3:	e8 e8 d4 ff ff       	call   80491a0 <_ITM_commitTransaction@plt>
			}
		}

		__transaction_relaxed {
			resize();
			return true;
 804bcb8:	b8 01 00 00 00       	mov    $0x1,%eax
		}
	}
 804bcbd:	81 c4 bc 00 00 00    	add    $0xbc,%esp
 804bcc3:	5b                   	pop    %ebx
 804bcc4:	5e                   	pop    %esi
 804bcc5:	5f                   	pop    %edi
 804bcc6:	5d                   	pop    %ebp
 804bcc7:	c3                   	ret    
		return true;
	}

	void resize() {
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);
 804bcc8:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
 804bccf:	e8 9c d5 ff ff       	call   8049270 <_ZGTtnwj@plt>
 804bcd4:	89 c5                	mov    %eax,%ebp
 804bcd6:	8b 44 24 38          	mov    0x38(%esp),%eax
 804bcda:	e8 01 d7 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bcdf:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
 804bce2:	89 c6                	mov    %eax,%esi
	int TableSize;
	int BucketCapacity;
	
	int * buckets_size;

	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
 804bce4:	89 da                	mov    %ebx,%edx
 804bce6:	8d 45 04             	lea    0x4(%ebp),%eax
 804bce9:	e8 e2 d5 ff ff       	call   80492d0 <_ITM_WU4@plt>
 804bcee:	8d 45 08             	lea    0x8(%ebp),%eax
 804bcf1:	ba 08 00 00 00       	mov    $0x8,%edx
 804bcf6:	e8 d5 d5 ff ff       	call   80492d0 <_ITM_WU4@plt>
		assert(BucketCapacity > 0);
		assert(TableSize > 0);
 804bcfb:	85 db                	test   %ebx,%ebx
 804bcfd:	0f 8e 22 03 00 00    	jle    804c025 <_ZN9HashTableISsSsE6insertESsSs+0x995>

		table = new HashEntry<K,V>*[TableSize];
 804bd03:	81 fb 00 00 c0 1f    	cmp    $0x1fc00000,%ebx
 804bd09:	0f 8f 04 03 00 00    	jg     804c013 <_ZN9HashTableISsSsE6insertESsSs+0x983>
 804bd0f:	c1 e6 03             	shl    $0x3,%esi
 804bd12:	89 34 24             	mov    %esi,(%esp)
 804bd15:	e8 76 d5 ff ff       	call   8049290 <_ZGTtnaj@plt>
 804bd1a:	89 c2                	mov    %eax,%edx
 804bd1c:	89 e8                	mov    %ebp,%eax
 804bd1e:	e8 ad d5 ff ff       	call   80492d0 <_ITM_WU4@plt>
		buckets_size = new int[TableSize];
 804bd23:	8d 45 04             	lea    0x4(%ebp),%eax
 804bd26:	e8 b5 d6 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bd2b:	3d 00 00 c0 1f       	cmp    $0x1fc00000,%eax
 804bd30:	0f 87 bf 02 00 00    	ja     804bff5 <_ZN9HashTableISsSsE6insertESsSs+0x965>
 804bd36:	c1 e0 02             	shl    $0x2,%eax
 804bd39:	89 04 24             	mov    %eax,(%esp)
 804bd3c:	e8 4f d5 ff ff       	call   8049290 <_ZGTtnaj@plt>
 804bd41:	8d 7d 0c             	lea    0xc(%ebp),%edi
 804bd44:	89 c2                	mov    %eax,%edx

		for(int i = 0 ; i < TableSize ; i ++ ){
 804bd46:	8d 75 04             	lea    0x4(%ebp),%esi
	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];
 804bd49:	89 f8                	mov    %edi,%eax
 804bd4b:	e8 80 d5 ff ff       	call   80492d0 <_ITM_WU4@plt>

		for(int i = 0 ; i < TableSize ; i ++ ){
 804bd50:	89 f0                	mov    %esi,%eax
 804bd52:	31 db                	xor    %ebx,%ebx
 804bd54:	e8 87 d6 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bd59:	89 74 24 24          	mov    %esi,0x24(%esp)
 804bd5d:	85 c0                	test   %eax,%eax
 804bd5f:	7e 3e                	jle    804bd9f <_ZN9HashTableISsSsE6insertESsSs+0x70f>
 804bd61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			table[i] = NULL;
 804bd68:	89 e8                	mov    %ebp,%eax
 804bd6a:	e8 71 d6 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bd6f:	8d 34 9d 00 00 00 00 	lea    0x0(,%ebx,4),%esi
 804bd76:	31 d2                	xor    %edx,%edx
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];

		for(int i = 0 ; i < TableSize ; i ++ ){
 804bd78:	83 c3 01             	add    $0x1,%ebx
			table[i] = NULL;
 804bd7b:	01 f0                	add    %esi,%eax
 804bd7d:	e8 4e d5 ff ff       	call   80492d0 <_ITM_WU4@plt>
			buckets_size[i] = 0;
 804bd82:	89 f8                	mov    %edi,%eax
 804bd84:	e8 57 d6 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bd89:	31 d2                	xor    %edx,%edx
 804bd8b:	01 f0                	add    %esi,%eax
 804bd8d:	e8 3e d5 ff ff       	call   80492d0 <_ITM_WU4@plt>
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];

		for(int i = 0 ; i < TableSize ; i ++ ){
 804bd92:	8b 44 24 24          	mov    0x24(%esp),%eax
 804bd96:	e8 45 d6 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bd9b:	39 c3                	cmp    %eax,%ebx
 804bd9d:	7c c9                	jl     804bd68 <_ZN9HashTableISsSsE6insertESsSs+0x6d8>

	void resize() {
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);

			for(int i = 0; i < TableSize; ++i) {
 804bd9f:	8b 44 24 38          	mov    0x38(%esp),%eax
 804bda3:	e8 38 d6 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bda8:	85 c0                	test   %eax,%eax
 804bdaa:	89 44 24 20          	mov    %eax,0x20(%esp)
 804bdae:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804bdb5:	0f 8e 2c 02 00 00    	jle    804bfe7 <_ZN9HashTableISsSsE6insertESsSs+0x957>
 804bdbb:	e8 20 d6 ff ff       	call   80493e0 <_ITM_RU4@plt>
	}
	K key(){
		return kvpair.first;
	}
	V value(){
		return kvpair.second;
 804bdc0:	8d bc 24 a8 00 00 00 	lea    0xa8(%esp),%edi

	void resize() {
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);

			for(int i = 0; i < TableSize; ++i) {
 804bdc7:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
 804bdce:	00 
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804bdcf:	8d b4 24 ac 00 00 00 	lea    0xac(%esp),%esi
 804bdd6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 804bdda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	void resize() {
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);

			for(int i = 0; i < TableSize; ++i) {
				if (table[i] != NULL) {
 804bde0:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 804bde4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804bde8:	8d 04 88             	lea    (%eax,%ecx,4),%eax
 804bdeb:	e8 f0 d5 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bdf0:	85 c0                	test   %eax,%eax
 804bdf2:	89 c3                	mov    %eax,%ebx
 804bdf4:	0f 84 95 00 00 00    	je     804be8f <_ZN9HashTableISsSsE6insertESsSs+0x7ff>
 804bdfa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804be00:	31 c0                	xor    %eax,%eax
 804be02:	e8 b9 d5 ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
	}
	K key(){
		return kvpair.first;
	}
	V value(){
		return kvpair.second;
 804be07:	8d 43 04             	lea    0x4(%ebx),%eax
 804be0a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804be0e:	89 3c 24             	mov    %edi,(%esp)
 804be11:	e8 da d3 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804be16:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804be1a:	89 34 24             	mov    %esi,(%esp)
 804be1d:	e8 ce d3 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);

			for(int i = 0; i < TableSize; ++i) {
				if (table[i] != NULL) {
					for(HashEntry<K,V> * e = table[i]; e != NULL; e = e->next) {
						new_table->insert(e->key(), e->value());
 804be22:	89 7c 24 08          	mov    %edi,0x8(%esp)
 804be26:	89 74 24 04          	mov    %esi,0x4(%esp)
 804be2a:	89 2c 24             	mov    %ebp,(%esp)
 804be2d:	e8 5e f8 ff ff       	call   804b690 <_ZN9HashTableISsSsE6insertESsSs>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804be32:	8d 84 24 a4 00 00 00 	lea    0xa4(%esp),%eax
 804be39:	e8 72 e9 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804be3e:	8b 84 24 ac 00 00 00 	mov    0xac(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804be45:	8d 50 f4             	lea    -0xc(%eax),%edx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804be48:	39 54 24 14          	cmp    %edx,0x14(%esp)
 804be4c:	0f 85 b5 00 00 00    	jne    804bf07 <_ZN9HashTableISsSsE6insertESsSs+0x877>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804be52:	89 f0                	mov    %esi,%eax
 804be54:	e8 57 e9 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804be59:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804be60:	8d 50 f4             	lea    -0xc(%eax),%edx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804be63:	39 54 24 14          	cmp    %edx,0x14(%esp)
 804be67:	0f 85 ca 00 00 00    	jne    804bf37 <_ZN9HashTableISsSsE6insertESsSs+0x8a7>
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);

			for(int i = 0; i < TableSize; ++i) {
				if (table[i] != NULL) {
					for(HashEntry<K,V> * e = table[i]; e != NULL; e = e->next) {
 804be6d:	8b 5b 08             	mov    0x8(%ebx),%ebx
 804be70:	85 db                	test   %ebx,%ebx
 804be72:	75 8c                	jne    804be00 <_ZN9HashTableISsSsE6insertESsSs+0x770>
 804be74:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804be7b:	8b 00                	mov    (%eax),%eax
 804be7d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 804be81:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804be88:	8b 40 04             	mov    0x4(%eax),%eax
 804be8b:	89 44 24 20          	mov    %eax,0x20(%esp)

	void resize() {
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);

			for(int i = 0; i < TableSize; ++i) {
 804be8f:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
 804be94:	8b 44 24 18          	mov    0x18(%esp),%eax
 804be98:	39 44 24 20          	cmp    %eax,0x20(%esp)
 804be9c:	0f 8f 3e ff ff ff    	jg     804bde0 <_ZN9HashTableISsSsE6insertESsSs+0x750>
 804bea2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
					for(HashEntry<K,V> * e = table[i]; e != NULL; e = e->next) {
						new_table->insert(e->key(), e->value());
					}
				}
			}
			delete this->table;
 804bea6:	89 04 24             	mov    %eax,(%esp)
 804bea9:	e8 52 d2 ff ff       	call   8049100 <_ZGTtdlPv@plt>
			delete this->buckets_size;
 804beae:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804beb5:	8d 58 0c             	lea    0xc(%eax),%ebx
 804beb8:	89 d8                	mov    %ebx,%eax
 804beba:	e8 21 d5 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bebf:	89 04 24             	mov    %eax,(%esp)
 804bec2:	e8 39 d2 ff ff       	call   8049100 <_ZGTtdlPv@plt>

			this->table = new_table->table;
 804bec7:	89 e8                	mov    %ebp,%eax
 804bec9:	e8 12 d5 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bece:	89 c2                	mov    %eax,%edx
 804bed0:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804bed7:	e8 f4 d3 ff ff       	call   80492d0 <_ITM_WU4@plt>
			this->buckets_size = new_table->buckets_size;
 804bedc:	8d 45 0c             	lea    0xc(%ebp),%eax
 804bedf:	e8 fc d4 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bee4:	89 c2                	mov    %eax,%edx
 804bee6:	89 d8                	mov    %ebx,%eax
 804bee8:	e8 e3 d3 ff ff       	call   80492d0 <_ITM_WU4@plt>
			this->TableSize = new_table->TableSize;
 804beed:	8d 45 04             	lea    0x4(%ebp),%eax
 804bef0:	e8 eb d4 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bef5:	89 c7                	mov    %eax,%edi
 804bef7:	89 c2                	mov    %eax,%edx
 804bef9:	8b 44 24 38          	mov    0x38(%esp),%eax
 804befd:	e8 ce d3 ff ff       	call   80492d0 <_ITM_WU4@plt>
 804bf02:	e9 5e fd ff ff       	jmp    804bc65 <_ZN9HashTableISsSsE6insertESsSs+0x5d5>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804bf07:	83 e8 04             	sub    $0x4,%eax
 804bf0a:	89 54 24 78          	mov    %edx,0x78(%esp)
 804bf0e:	e8 ea d5 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804bf13:	8b 54 24 78          	mov    0x78(%esp),%edx
 804bf17:	85 c0                	test   %eax,%eax
 804bf19:	0f 8f 33 ff ff ff    	jg     804be52 <_ZN9HashTableISsSsE6insertESsSs+0x7c2>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804bf1f:	8d 84 24 a4 00 00 00 	lea    0xa4(%esp),%eax
 804bf26:	89 44 24 04          	mov    %eax,0x4(%esp)
 804bf2a:	89 14 24             	mov    %edx,(%esp)
 804bf2d:	e8 4e d3 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804bf32:	e9 1b ff ff ff       	jmp    804be52 <_ZN9HashTableISsSsE6insertESsSs+0x7c2>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804bf37:	83 e8 04             	sub    $0x4,%eax
 804bf3a:	89 54 24 7c          	mov    %edx,0x7c(%esp)
 804bf3e:	e8 ba d5 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804bf43:	8b 54 24 7c          	mov    0x7c(%esp),%edx
 804bf47:	85 c0                	test   %eax,%eax
 804bf49:	0f 8f 1e ff ff ff    	jg     804be6d <_ZN9HashTableISsSsE6insertESsSs+0x7dd>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804bf4f:	89 74 24 04          	mov    %esi,0x4(%esp)
 804bf53:	89 14 24             	mov    %edx,(%esp)
 804bf56:	e8 25 d3 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804bf5b:	e9 0d ff ff ff       	jmp    804be6d <_ZN9HashTableISsSsE6insertESsSs+0x7dd>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804bf60:	8d b4 24 a4 00 00 00 	lea    0xa4(%esp),%esi
 804bf67:	89 c3                	mov    %eax,%ebx
 804bf69:	89 f0                	mov    %esi,%eax
 804bf6b:	c5 f8 77             	vzeroupper 
 804bf6e:	e8 3d e8 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804bf73:	8b 94 24 ac 00 00 00 	mov    0xac(%esp),%edx

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804bf7a:	8d 7a f4             	lea    -0xc(%edx),%edi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804bf7d:	39 7c 24 14          	cmp    %edi,0x14(%esp)
 804bf81:	75 4a                	jne    804bfcd <_ZN9HashTableISsSsE6insertESsSs+0x93d>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804bf83:	8d b4 24 a4 00 00 00 	lea    0xa4(%esp),%esi
 804bf8a:	89 f0                	mov    %esi,%eax
 804bf8c:	e8 1f e8 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804bf91:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804bf98:	8d 78 f4             	lea    -0xc(%eax),%edi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804bf9b:	39 7c 24 14          	cmp    %edi,0x14(%esp)
 804bf9f:	0f 84 78 fa ff ff    	je     804ba1d <_ZN9HashTableISsSsE6insertESsSs+0x38d>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804bfa5:	83 e8 04             	sub    $0x4,%eax
 804bfa8:	e8 50 d5 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804bfad:	85 c0                	test   %eax,%eax
 804bfaf:	0f 8f 68 fa ff ff    	jg     804ba1d <_ZN9HashTableISsSsE6insertESsSs+0x38d>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804bfb5:	89 74 24 04          	mov    %esi,0x4(%esp)
 804bfb9:	89 3c 24             	mov    %edi,(%esp)
 804bfbc:	e8 bf d2 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804bfc1:	e9 57 fa ff ff       	jmp    804ba1d <_ZN9HashTableISsSsE6insertESsSs+0x38d>
 804bfc6:	89 c3                	mov    %eax,%ebx
 804bfc8:	c5 f8 77             	vzeroupper 
 804bfcb:	eb b6                	jmp    804bf83 <_ZN9HashTableISsSsE6insertESsSs+0x8f3>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804bfcd:	8d 42 fc             	lea    -0x4(%edx),%eax
 804bfd0:	e8 28 d5 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804bfd5:	85 c0                	test   %eax,%eax
 804bfd7:	7f aa                	jg     804bf83 <_ZN9HashTableISsSsE6insertESsSs+0x8f3>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804bfd9:	89 74 24 04          	mov    %esi,0x4(%esp)
 804bfdd:	89 3c 24             	mov    %edi,(%esp)
 804bfe0:	e8 9b d2 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804bfe5:	eb 9c                	jmp    804bf83 <_ZN9HashTableISsSsE6insertESsSs+0x8f3>
 804bfe7:	e8 f4 d3 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804bfec:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 804bff0:	e9 b1 fe ff ff       	jmp    804bea6 <_ZN9HashTableISsSsE6insertESsSs+0x816>
 804bff5:	31 c0                	xor    %eax,%eax
 804bff7:	e8 c4 d3 ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];
 804bffc:	e8 af d1 ff ff       	call   80491b0 <__cxa_throw_bad_array_new_length@plt>
 804c001:	89 c3                	mov    %eax,%ebx
		return true;
	}

	void resize() {
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);
 804c003:	89 2c 24             	mov    %ebp,(%esp)
 804c006:	c5 f8 77             	vzeroupper 
 804c009:	e8 f2 d0 ff ff       	call   8049100 <_ZGTtdlPv@plt>
 804c00e:	e9 0a fa ff ff       	jmp    804ba1d <_ZN9HashTableISsSsE6insertESsSs+0x38d>
 804c013:	31 c0                	xor    %eax,%eax
 804c015:	e8 a6 d3 ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
 804c01a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
 804c020:	e8 8b d1 ff ff       	call   80491b0 <__cxa_throw_bad_array_new_length@plt>
 804c025:	31 c0                	xor    %eax,%eax
 804c027:	e8 94 d3 ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
	
	int * buckets_size;

	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
		assert(TableSize > 0);
 804c02c:	c7 44 24 0c c0 cf 04 	movl   $0x804cfc0,0xc(%esp)
 804c033:	08 
 804c034:	c7 44 24 08 4a 00 00 	movl   $0x4a,0x8(%esp)
 804c03b:	00 
 804c03c:	c7 44 24 04 7c cf 04 	movl   $0x804cf7c,0x4(%esp)
 804c043:	08 
 804c044:	c7 04 24 93 cf 04 08 	movl   $0x804cf93,(%esp)
 804c04b:	e8 c0 d1 ff ff       	call   8049210 <__assert_fail@plt>
 804c050:	e9 c3 f9 ff ff       	jmp    804ba18 <_ZN9HashTableISsSsE6insertESsSs+0x388>
 804c055:	8b 50 04             	mov    0x4(%eax),%edx
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804c058:	8d bc 24 a0 00 00 00 	lea    0xa0(%esp),%edi

template <class K, class V>
class HashTable{
private:
	bool check_buckets_size() {
		for(int i = 0; i < TableSize; ++i) {
 804c05f:	85 d2                	test   %edx,%edx
 804c061:	0f 8e 4c fc ff ff    	jle    804bcb3 <_ZN9HashTableISsSsE6insertESsSs+0x623>
 804c067:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804c06e:	8b 30                	mov    (%eax),%esi
 804c070:	31 c0                	xor    %eax,%eax
			if (table[i] != NULL) {
 804c072:	8b 0c 86             	mov    (%esi,%eax,4),%ecx
				int count = 0;
 804c075:	31 db                	xor    %ebx,%ebx
template <class K, class V>
class HashTable{
private:
	bool check_buckets_size() {
		for(int i = 0; i < TableSize; ++i) {
			if (table[i] != NULL) {
 804c077:	85 c9                	test   %ecx,%ecx
 804c079:	74 16                	je     804c091 <_ZN9HashTableISsSsE6insertESsSs+0xa01>
				int count = 0;
				for (HashEntry<K,V> * e = table[i]; e != NULL; e = e->next) {
 804c07b:	8b 49 08             	mov    0x8(%ecx),%ecx
					count++;
 804c07e:	83 c3 01             	add    $0x1,%ebx
private:
	bool check_buckets_size() {
		for(int i = 0; i < TableSize; ++i) {
			if (table[i] != NULL) {
				int count = 0;
				for (HashEntry<K,V> * e = table[i]; e != NULL; e = e->next) {
 804c081:	85 c9                	test   %ecx,%ecx
 804c083:	75 f6                	jne    804c07b <_ZN9HashTableISsSsE6insertESsSs+0x9eb>
					count++;
				}
				if(count > BucketCapacity)
 804c085:	8b 8c 24 d0 00 00 00 	mov    0xd0(%esp),%ecx
 804c08c:	39 59 08             	cmp    %ebx,0x8(%ecx)
 804c08f:	7c 37                	jl     804c0c8 <_ZN9HashTableISsSsE6insertESsSs+0xa38>

template <class K, class V>
class HashTable{
private:
	bool check_buckets_size() {
		for(int i = 0; i < TableSize; ++i) {
 804c091:	83 c0 01             	add    $0x1,%eax
 804c094:	39 d0                	cmp    %edx,%eax
 804c096:	75 da                	jne    804c072 <_ZN9HashTableISsSsE6insertESsSs+0x9e2>
 804c098:	e8 03 d1 ff ff       	call   80491a0 <_ITM_commitTransaction@plt>
			}
		}

		__transaction_relaxed {
			resize();
			return true;
 804c09d:	b8 01 00 00 00       	mov    $0x1,%eax
 804c0a2:	e9 16 fc ff ff       	jmp    804bcbd <_ZN9HashTableISsSsE6insertESsSs+0x62d>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c0a7:	83 e8 04             	sub    $0x4,%eax
 804c0aa:	e8 4e d4 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c0af:	85 c0                	test   %eax,%eax
 804c0b1:	0f 8f 5f fb ff ff    	jg     804bc16 <_ZN9HashTableISsSsE6insertESsSs+0x586>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c0b7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804c0bb:	89 34 24             	mov    %esi,(%esp)
 804c0be:	e8 bd d1 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c0c3:	e9 4e fb ff ff       	jmp    804bc16 <_ZN9HashTableISsSsE6insertESsSs+0x586>
		return true;
	}

	void resize() {
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);
 804c0c8:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
 804c0cf:	e8 6c d2 ff ff       	call   8049340 <_Znwj@plt>
 804c0d4:	89 c3                	mov    %eax,%ebx
 804c0d6:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804c0dd:	8b 50 04             	mov    0x4(%eax),%edx
	int TableSize;
	int BucketCapacity;
	
	int * buckets_size;

	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
 804c0e0:	c7 43 08 08 00 00 00 	movl   $0x8,0x8(%ebx)
		return true;
	}

	void resize() {
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);
 804c0e7:	8d 04 12             	lea    (%edx,%edx,1),%eax
	
	int * buckets_size;

	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
		assert(TableSize > 0);
 804c0ea:	85 c0                	test   %eax,%eax
	int TableSize;
	int BucketCapacity;
	
	int * buckets_size;

	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
 804c0ec:	89 43 04             	mov    %eax,0x4(%ebx)
		assert(BucketCapacity > 0);
		assert(TableSize > 0);
 804c0ef:	0f 8e 37 ff ff ff    	jle    804c02c <_ZN9HashTableISsSsE6insertESsSs+0x99c>

		table = new HashEntry<K,V>*[TableSize];
 804c0f5:	3d 00 00 c0 1f       	cmp    $0x1fc00000,%eax
 804c0fa:	0f 8f 16 02 00 00    	jg     804c316 <_ZN9HashTableISsSsE6insertESsSs+0xc86>
 804c100:	c1 e2 03             	shl    $0x3,%edx
 804c103:	89 14 24             	mov    %edx,(%esp)
 804c106:	e8 65 d2 ff ff       	call   8049370 <_Znaj@plt>
 804c10b:	89 03                	mov    %eax,(%ebx)
		buckets_size = new int[TableSize];
 804c10d:	8b 43 04             	mov    0x4(%ebx),%eax
 804c110:	3d 00 00 c0 1f       	cmp    $0x1fc00000,%eax
 804c115:	0f 87 1e 01 00 00    	ja     804c239 <_ZN9HashTableISsSsE6insertESsSs+0xba9>
 804c11b:	c1 e0 02             	shl    $0x2,%eax
 804c11e:	89 04 24             	mov    %eax,(%esp)
 804c121:	e8 4a d2 ff ff       	call   8049370 <_Znaj@plt>

		for(int i = 0 ; i < TableSize ; i ++ ){
 804c126:	8b 73 04             	mov    0x4(%ebx),%esi
	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];
 804c129:	89 43 0c             	mov    %eax,0xc(%ebx)

		for(int i = 0 ; i < TableSize ; i ++ ){
 804c12c:	31 c0                	xor    %eax,%eax
 804c12e:	85 f6                	test   %esi,%esi
 804c130:	7e 1b                	jle    804c14d <_ZN9HashTableISsSsE6insertESsSs+0xabd>
			table[i] = NULL;
 804c132:	8b 13                	mov    (%ebx),%edx
 804c134:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
			buckets_size[i] = 0;
 804c13b:	8b 53 0c             	mov    0xc(%ebx),%edx
 804c13e:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];

		for(int i = 0 ; i < TableSize ; i ++ ){
 804c145:	83 c0 01             	add    $0x1,%eax
 804c148:	3b 43 04             	cmp    0x4(%ebx),%eax
 804c14b:	7c e5                	jl     804c132 <_ZN9HashTableISsSsE6insertESsSs+0xaa2>

	void resize() {
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);

			for(int i = 0; i < TableSize; ++i) {
 804c14d:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804c154:	8b 50 04             	mov    0x4(%eax),%edx
 804c157:	8b 00                	mov    (%eax),%eax
 804c159:	85 d2                	test   %edx,%edx
 804c15b:	0f 8e a2 00 00 00    	jle    804c203 <_ZN9HashTableISsSsE6insertESsSs+0xb73>
 804c161:	31 ed                	xor    %ebp,%ebp
				if (table[i] != NULL) {
 804c163:	8b 34 a8             	mov    (%eax,%ebp,4),%esi
 804c166:	85 f6                	test   %esi,%esi
 804c168:	0f 84 8a 00 00 00    	je     804c1f8 <_ZN9HashTableISsSsE6insertESsSs+0xb68>
	}
	K key(){
		return kvpair.first;
	}
	V value(){
		return kvpair.second;
 804c16e:	8d 46 04             	lea    0x4(%esi),%eax
 804c171:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c175:	8d 84 24 a4 00 00 00 	lea    0xa4(%esp),%eax
 804c17c:	89 04 24             	mov    %eax,(%esp)
 804c17f:	e8 6c d0 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804c184:	89 74 24 04          	mov    %esi,0x4(%esp)
 804c188:	89 3c 24             	mov    %edi,(%esp)
 804c18b:	e8 60 d0 ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);

			for(int i = 0; i < TableSize; ++i) {
				if (table[i] != NULL) {
					for(HashEntry<K,V> * e = table[i]; e != NULL; e = e->next) {
						new_table->insert(e->key(), e->value());
 804c190:	8d 84 24 a4 00 00 00 	lea    0xa4(%esp),%eax
 804c197:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c19b:	89 7c 24 04          	mov    %edi,0x4(%esp)
 804c19f:	89 1c 24             	mov    %ebx,(%esp)
 804c1a2:	e8 e9 f4 ff ff       	call   804b690 <_ZN9HashTableISsSsE6insertESsSs>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c1a7:	8d 84 24 83 00 00 00 	lea    0x83(%esp),%eax
 804c1ae:	e8 fd e5 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804c1b3:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c1ba:	8d 50 f4             	lea    -0xc(%eax),%edx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804c1bd:	39 54 24 14          	cmp    %edx,0x14(%esp)
 804c1c1:	0f 85 b4 00 00 00    	jne    804c27b <_ZN9HashTableISsSsE6insertESsSs+0xbeb>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c1c7:	89 f8                	mov    %edi,%eax
 804c1c9:	e8 e2 e5 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804c1ce:	8b 84 24 a4 00 00 00 	mov    0xa4(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c1d5:	8d 50 f4             	lea    -0xc(%eax),%edx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804c1d8:	39 54 24 14          	cmp    %edx,0x14(%esp)
 804c1dc:	75 74                	jne    804c252 <_ZN9HashTableISsSsE6insertESsSs+0xbc2>
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);

			for(int i = 0; i < TableSize; ++i) {
				if (table[i] != NULL) {
					for(HashEntry<K,V> * e = table[i]; e != NULL; e = e->next) {
 804c1de:	8b 76 08             	mov    0x8(%esi),%esi
 804c1e1:	85 f6                	test   %esi,%esi
 804c1e3:	75 89                	jne    804c16e <_ZN9HashTableISsSsE6insertESsSs+0xade>
 804c1e5:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804c1ec:	8b 8c 24 d0 00 00 00 	mov    0xd0(%esp),%ecx
 804c1f3:	8b 00                	mov    (%eax),%eax
 804c1f5:	8b 51 04             	mov    0x4(%ecx),%edx

	void resize() {
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);

			for(int i = 0; i < TableSize; ++i) {
 804c1f8:	83 c5 01             	add    $0x1,%ebp
 804c1fb:	39 ea                	cmp    %ebp,%edx
 804c1fd:	0f 8f 60 ff ff ff    	jg     804c163 <_ZN9HashTableISsSsE6insertESsSs+0xad3>
					for(HashEntry<K,V> * e = table[i]; e != NULL; e = e->next) {
						new_table->insert(e->key(), e->value());
					}
				}
			}
			delete this->table;
 804c203:	89 04 24             	mov    %eax,(%esp)
 804c206:	e8 65 cf ff ff       	call   8049170 <_ZdlPv@plt>
			delete this->buckets_size;
 804c20b:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804c212:	8b 40 0c             	mov    0xc(%eax),%eax
 804c215:	89 04 24             	mov    %eax,(%esp)
 804c218:	e8 53 cf ff ff       	call   8049170 <_ZdlPv@plt>

			this->table = new_table->table;
 804c21d:	8b 03                	mov    (%ebx),%eax
 804c21f:	8b 8c 24 d0 00 00 00 	mov    0xd0(%esp),%ecx
			this->buckets_size = new_table->buckets_size;
			this->TableSize = new_table->TableSize;
 804c226:	8b 53 04             	mov    0x4(%ebx),%edx
				}
			}
			delete this->table;
			delete this->buckets_size;

			this->table = new_table->table;
 804c229:	89 01                	mov    %eax,(%ecx)
			this->buckets_size = new_table->buckets_size;
 804c22b:	8b 43 0c             	mov    0xc(%ebx),%eax
			this->TableSize = new_table->TableSize;
 804c22e:	89 51 04             	mov    %edx,0x4(%ecx)
			}
			delete this->table;
			delete this->buckets_size;

			this->table = new_table->table;
			this->buckets_size = new_table->buckets_size;
 804c231:	89 41 0c             	mov    %eax,0xc(%ecx)
 804c234:	e9 26 fe ff ff       	jmp    804c05f <_ZN9HashTableISsSsE6insertESsSs+0x9cf>
	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];
 804c239:	e8 72 cf ff ff       	call   80491b0 <__cxa_throw_bad_array_new_length@plt>
 804c23e:	89 c6                	mov    %eax,%esi
		return true;
	}

	void resize() {
		while(check_buckets_size() == false) {
			HashTable<K,V> * new_table = new HashTable<K,V>(TableSize << 1);
 804c240:	89 1c 24             	mov    %ebx,(%esp)
 804c243:	c5 f8 77             	vzeroupper 
 804c246:	89 f3                	mov    %esi,%ebx
 804c248:	e8 23 cf ff ff       	call   8049170 <_ZdlPv@plt>
 804c24d:	e9 cb f7 ff ff       	jmp    804ba1d <_ZN9HashTableISsSsE6insertESsSs+0x38d>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c252:	83 e8 04             	sub    $0x4,%eax
 804c255:	89 54 24 74          	mov    %edx,0x74(%esp)
 804c259:	e8 9f d2 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c25e:	8b 54 24 74          	mov    0x74(%esp),%edx
 804c262:	85 c0                	test   %eax,%eax
 804c264:	0f 8f 74 ff ff ff    	jg     804c1de <_ZN9HashTableISsSsE6insertESsSs+0xb4e>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c26a:	89 7c 24 04          	mov    %edi,0x4(%esp)
 804c26e:	89 14 24             	mov    %edx,(%esp)
 804c271:	e8 0a d0 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c276:	e9 63 ff ff ff       	jmp    804c1de <_ZN9HashTableISsSsE6insertESsSs+0xb4e>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c27b:	83 e8 04             	sub    $0x4,%eax
 804c27e:	89 54 24 70          	mov    %edx,0x70(%esp)
 804c282:	e8 76 d2 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c287:	8b 54 24 70          	mov    0x70(%esp),%edx
 804c28b:	85 c0                	test   %eax,%eax
 804c28d:	0f 8f 34 ff ff ff    	jg     804c1c7 <_ZN9HashTableISsSsE6insertESsSs+0xb37>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c293:	8d 84 24 83 00 00 00 	lea    0x83(%esp),%eax
 804c29a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c29e:	89 14 24             	mov    %edx,(%esp)
 804c2a1:	e8 da cf ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c2a6:	e9 1c ff ff ff       	jmp    804c1c7 <_ZN9HashTableISsSsE6insertESsSs+0xb37>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c2ab:	8d b4 24 83 00 00 00 	lea    0x83(%esp),%esi
 804c2b2:	89 c3                	mov    %eax,%ebx
 804c2b4:	89 f0                	mov    %esi,%eax
 804c2b6:	c5 f8 77             	vzeroupper 
 804c2b9:	e8 f2 e4 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804c2be:	8b 94 24 a0 00 00 00 	mov    0xa0(%esp),%edx

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c2c5:	8d 7a f4             	lea    -0xc(%edx),%edi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804c2c8:	39 7c 24 14          	cmp    %edi,0x14(%esp)
 804c2cc:	75 2e                	jne    804c2fc <_ZN9HashTableISsSsE6insertESsSs+0xc6c>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c2ce:	8d b4 24 83 00 00 00 	lea    0x83(%esp),%esi
 804c2d5:	89 f0                	mov    %esi,%eax
 804c2d7:	e8 d4 e4 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804c2dc:	8b 84 24 a4 00 00 00 	mov    0xa4(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c2e3:	8d 78 f4             	lea    -0xc(%eax),%edi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804c2e6:	39 7c 24 14          	cmp    %edi,0x14(%esp)
 804c2ea:	0f 84 2d f7 ff ff    	je     804ba1d <_ZN9HashTableISsSsE6insertESsSs+0x38d>
 804c2f0:	e9 b0 fc ff ff       	jmp    804bfa5 <_ZN9HashTableISsSsE6insertESsSs+0x915>
 804c2f5:	89 c3                	mov    %eax,%ebx
 804c2f7:	c5 f8 77             	vzeroupper 
 804c2fa:	eb d2                	jmp    804c2ce <_ZN9HashTableISsSsE6insertESsSs+0xc3e>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c2fc:	8d 42 fc             	lea    -0x4(%edx),%eax
 804c2ff:	e8 f9 d1 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c304:	85 c0                	test   %eax,%eax
 804c306:	7f c6                	jg     804c2ce <_ZN9HashTableISsSsE6insertESsSs+0xc3e>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c308:	89 74 24 04          	mov    %esi,0x4(%esp)
 804c30c:	89 3c 24             	mov    %edi,(%esp)
 804c30f:	e8 6c cf ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c314:	eb b8                	jmp    804c2ce <_ZN9HashTableISsSsE6insertESsSs+0xc3e>

	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
 804c316:	e8 95 ce ff ff       	call   80491b0 <__cxa_throw_bad_array_new_length@plt>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c31b:	83 e8 04             	sub    $0x4,%eax
 804c31e:	66 90                	xchg   %ax,%ax
 804c320:	e8 d8 d1 ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c325:	85 c0                	test   %eax,%eax
 804c327:	0f 8f c7 f8 ff ff    	jg     804bbf4 <_ZN9HashTableISsSsE6insertESsSs+0x564>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c32d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804c331:	89 34 24             	mov    %esi,(%esp)
 804c334:	e8 47 cf ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c339:	e9 b6 f8 ff ff       	jmp    804bbf4 <_ZN9HashTableISsSsE6insertESsSs+0x564>
 804c33e:	89 c3                	mov    %eax,%ebx
 804c340:	89 34 24             	mov    %esi,(%esp)
 804c343:	c5 f8 77             	vzeroupper 
 804c346:	e8 15 cf ff ff       	call   8049260 <_ZNSsD1Ev@plt>
					pre_entry = entry;
					entry = entry->next;
				}

				if(entry == NULL) {
					pre_entry->next = new HashEntry<K,V>(key, val);
 804c34b:	89 34 24             	mov    %esi,(%esp)
 804c34e:	e8 1d ce ff ff       	call   8049170 <_ZdlPv@plt>
 804c353:	8d 84 24 90 00 00 00 	lea    0x90(%esp),%eax
 804c35a:	89 04 24             	mov    %eax,(%esp)
 804c35d:	e8 fe ce ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804c362:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804c369:	89 04 24             	mov    %eax,(%esp)
 804c36c:	e8 ef ce ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804c371:	e9 a7 f6 ff ff       	jmp    804ba1d <_ZN9HashTableISsSsE6insertESsSs+0x38d>
 804c376:	e9 9d f6 ff ff       	jmp    804ba18 <_ZN9HashTableISsSsE6insertESsSs+0x388>
 804c37b:	89 c3                	mov    %eax,%ebx
 804c37d:	c5 f8 77             	vzeroupper 
 804c380:	eb c9                	jmp    804c34b <_ZN9HashTableISsSsE6insertESsSs+0xcbb>
 804c382:	89 c3                	mov    %eax,%ebx
 804c384:	c5 f8 77             	vzeroupper 
 804c387:	eb ca                	jmp    804c353 <_ZN9HashTableISsSsE6insertESsSs+0xcc3>
 804c389:	89 c3                	mov    %eax,%ebx
 804c38b:	c5 f8 77             	vzeroupper 
 804c38e:	eb d2                	jmp    804c362 <_ZN9HashTableISsSsE6insertESsSs+0xcd2>
	bool insert(K key, V val) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
				table[num] = new HashEntry<K,V>(key, val);
 804c390:	8b 84 24 d4 00 00 00 	mov    0xd4(%esp),%eax
 804c397:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c39b:	8d 84 24 84 00 00 00 	lea    0x84(%esp),%eax
 804c3a2:	89 04 24             	mov    %eax,(%esp)
 804c3a5:	e8 46 ce ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804c3aa:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
 804c3b1:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c3b5:	8d 84 24 88 00 00 00 	lea    0x88(%esp),%eax
 804c3bc:	89 04 24             	mov    %eax,(%esp)
 804c3bf:	e8 2c ce ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804c3c4:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
 804c3cb:	e8 70 cf ff ff       	call   8049340 <_Znwj@plt>
 804c3d0:	89 c3                	mov    %eax,%ebx
 804c3d2:	8d 84 24 84 00 00 00 	lea    0x84(%esp),%eax
 804c3d9:	89 04 24             	mov    %eax,(%esp)
 804c3dc:	e8 9f f2 ff ff       	call   804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>
 804c3e1:	89 1c 24             	mov    %ebx,(%esp)
 804c3e4:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c3e8:	e8 03 ce ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804c3ed:	8d 84 24 88 00 00 00 	lea    0x88(%esp),%eax
 804c3f4:	89 04 24             	mov    %eax,(%esp)
 804c3f7:	e8 84 f2 ff ff       	call   804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>
 804c3fc:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c400:	8d 43 04             	lea    0x4(%ebx),%eax
 804c403:	89 04 24             	mov    %eax,(%esp)
 804c406:	e8 e5 cd ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804c40b:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804c412:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
template <class K, class V>
class HashEntry {
	pair<K,V> kvpair;
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
 804c416:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	bool insert(K key, V val) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
				table[num] = new HashEntry<K,V>(key, val);
 804c41d:	8b 00                	mov    (%eax),%eax
 804c41f:	89 1c 88             	mov    %ebx,(%eax,%ecx,4)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c422:	8d 9c 24 a8 00 00 00 	lea    0xa8(%esp),%ebx
 804c429:	89 d8                	mov    %ebx,%eax
 804c42b:	e8 80 e3 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804c430:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c437:	8d 70 f4             	lea    -0xc(%eax),%esi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804c43a:	39 74 24 14          	cmp    %esi,0x14(%esp)
 804c43e:	0f 85 3d 01 00 00    	jne    804c581 <_ZN9HashTableISsSsE6insertESsSs+0xef1>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c444:	8d 9c 24 a8 00 00 00 	lea    0xa8(%esp),%ebx
 804c44b:	89 d8                	mov    %ebx,%eax
 804c44d:	e8 5e e3 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804c452:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c459:	8d 70 f4             	lea    -0xc(%eax),%esi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804c45c:	39 74 24 14          	cmp    %esi,0x14(%esp)
 804c460:	0f 85 fa 00 00 00    	jne    804c560 <_ZN9HashTableISsSsE6insertESsSs+0xed0>
				buckets_size[num]++;
 804c466:	8b 8c 24 d0 00 00 00 	mov    0xd0(%esp),%ecx
				return true;
 804c46d:	be 01 00 00 00       	mov    $0x1,%esi
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
				table[num] = new HashEntry<K,V>(key, val);
				buckets_size[num]++;
 804c472:	8b 44 24 30          	mov    0x30(%esp),%eax
 804c476:	03 41 0c             	add    0xc(%ecx),%eax
 804c479:	83 00 01             	addl   $0x1,(%eax)
				return true;
 804c47c:	e9 99 f6 ff ff       	jmp    804bb1a <_ZN9HashTableISsSsE6insertESsSs+0x48a>
					pre_entry = entry;
					entry = entry->next;
				}

				if(entry == NULL) {
					pre_entry->next = new HashEntry<K,V>(key, val);
 804c481:	8b 84 24 d4 00 00 00 	mov    0xd4(%esp),%eax
 804c488:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c48c:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804c493:	89 04 24             	mov    %eax,(%esp)
 804c496:	e8 55 cd ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804c49b:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
 804c4a2:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c4a6:	8d 84 24 90 00 00 00 	lea    0x90(%esp),%eax
 804c4ad:	89 04 24             	mov    %eax,(%esp)
 804c4b0:	e8 3b cd ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804c4b5:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
 804c4bc:	e8 7f ce ff ff       	call   8049340 <_Znwj@plt>
 804c4c1:	89 c6                	mov    %eax,%esi
 804c4c3:	8d 84 24 8c 00 00 00 	lea    0x8c(%esp),%eax
 804c4ca:	89 04 24             	mov    %eax,(%esp)
 804c4cd:	e8 ae f1 ff ff       	call   804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>
 804c4d2:	89 34 24             	mov    %esi,(%esp)
 804c4d5:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c4d9:	e8 12 cd ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804c4de:	8d 84 24 90 00 00 00 	lea    0x90(%esp),%eax
 804c4e5:	89 04 24             	mov    %eax,(%esp)
 804c4e8:	e8 93 f1 ff ff       	call   804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>
 804c4ed:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c4f1:	8d 46 04             	lea    0x4(%esi),%eax
 804c4f4:	89 04 24             	mov    %eax,(%esp)
 804c4f7:	e8 f4 cc ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
template <class K, class V>
class HashEntry {
	pair<K,V> kvpair;
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
 804c4fc:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
					pre_entry = entry;
					entry = entry->next;
				}

				if(entry == NULL) {
					pre_entry->next = new HashEntry<K,V>(key, val);
 804c503:	89 73 08             	mov    %esi,0x8(%ebx)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c506:	8d 9c 24 ac 00 00 00 	lea    0xac(%esp),%ebx
 804c50d:	89 d8                	mov    %ebx,%eax
 804c50f:	e8 9c e2 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804c514:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c51b:	8d 70 f4             	lea    -0xc(%eax),%esi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804c51e:	39 74 24 14          	cmp    %esi,0x14(%esp)
 804c522:	0f 85 3f 03 00 00    	jne    804c867 <_ZN9HashTableISsSsE6insertESsSs+0x11d7>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c528:	8d 9c 24 ac 00 00 00 	lea    0xac(%esp),%ebx
 804c52f:	89 d8                	mov    %ebx,%eax
 804c531:	e8 7a e2 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804c536:	8b 84 24 8c 00 00 00 	mov    0x8c(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c53d:	8d 70 f4             	lea    -0xc(%eax),%esi

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804c540:	39 74 24 14          	cmp    %esi,0x14(%esp)
 804c544:	0f 85 f9 02 00 00    	jne    804c843 <_ZN9HashTableISsSsE6insertESsSs+0x11b3>
					e->next = entry;
					if(pre_entry)
						pre_entry->next = e;
					else
						table[num] = e;
					buckets_size[num]++;
 804c54a:	8b 8c 24 d0 00 00 00 	mov    0xd0(%esp),%ecx
 804c551:	8b 44 24 30          	mov    0x30(%esp),%eax
 804c555:	03 41 0c             	add    0xc(%ecx),%eax
 804c558:	83 00 01             	addl   $0x1,(%eax)
 804c55b:	e9 c7 f6 ff ff       	jmp    804bc27 <_ZN9HashTableISsSsE6insertESsSs+0x597>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c560:	83 e8 04             	sub    $0x4,%eax
 804c563:	e8 95 cf ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c568:	85 c0                	test   %eax,%eax
 804c56a:	0f 8f f6 fe ff ff    	jg     804c466 <_ZN9HashTableISsSsE6insertESsSs+0xdd6>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c570:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804c574:	89 34 24             	mov    %esi,(%esp)
 804c577:	e8 04 cd ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c57c:	e9 e5 fe ff ff       	jmp    804c466 <_ZN9HashTableISsSsE6insertESsSs+0xdd6>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c581:	83 e8 04             	sub    $0x4,%eax
 804c584:	e8 74 cf ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c589:	85 c0                	test   %eax,%eax
 804c58b:	0f 8f b3 fe ff ff    	jg     804c444 <_ZN9HashTableISsSsE6insertESsSs+0xdb4>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c591:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804c595:	89 34 24             	mov    %esi,(%esp)
 804c598:	e8 e3 cc ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c59d:	e9 a2 fe ff ff       	jmp    804c444 <_ZN9HashTableISsSsE6insertESsSs+0xdb4>
 804c5a2:	89 c3                	mov    %eax,%ebx
 804c5a4:	c5 f8 77             	vzeroupper 
	bool insert(K key, V val) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
				table[num] = new HashEntry<K,V>(key, val);
 804c5a7:	8d 84 24 88 00 00 00 	lea    0x88(%esp),%eax
 804c5ae:	89 04 24             	mov    %eax,(%esp)
 804c5b1:	e8 aa cc ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804c5b6:	8d 84 24 84 00 00 00 	lea    0x84(%esp),%eax
 804c5bd:	89 04 24             	mov    %eax,(%esp)
 804c5c0:	e8 9b cc ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804c5c5:	e9 53 f4 ff ff       	jmp    804ba1d <_ZN9HashTableISsSsE6insertESsSs+0x38d>
 804c5ca:	89 c3                	mov    %eax,%ebx
 804c5cc:	c5 f8 77             	vzeroupper 
 804c5cf:	eb e5                	jmp    804c5b6 <_ZN9HashTableISsSsE6insertESsSs+0xf26>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c5d1:	8d 46 fc             	lea    -0x4(%esi),%eax
 804c5d4:	e8 24 cf ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c5d9:	85 c0                	test   %eax,%eax
 804c5db:	0f 8f 51 f3 ff ff    	jg     804b932 <_ZN9HashTableISsSsE6insertESsSs+0x2a2>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c5e1:	8d 84 24 ac 00 00 00 	lea    0xac(%esp),%eax
 804c5e8:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c5ec:	89 2c 24             	mov    %ebp,(%esp)
 804c5ef:	e8 8c cc ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c5f4:	e9 39 f3 ff ff       	jmp    804b932 <_ZN9HashTableISsSsE6insertESsSs+0x2a2>
 804c5f9:	89 c3                	mov    %eax,%ebx
 804c5fb:	89 34 24             	mov    %esi,(%esp)
 804c5fe:	c5 f8 77             	vzeroupper 
 804c601:	e8 5a cc ff ff       	call   8049260 <_ZNSsD1Ev@plt>
					buckets_size[num]++;
				}
				else if (entry->key() == key)	//the key has already in the table
					return false;
				else {	//entry->key > key
					HashEntry<K,V> * e = new HashEntry<K,V>(key, val);
 804c606:	89 34 24             	mov    %esi,(%esp)
 804c609:	e8 62 cb ff ff       	call   8049170 <_ZdlPv@plt>
 804c60e:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
 804c615:	89 04 24             	mov    %eax,(%esp)
 804c618:	e8 43 cc ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804c61d:	8d 84 24 98 00 00 00 	lea    0x98(%esp),%eax
 804c624:	89 04 24             	mov    %eax,(%esp)
 804c627:	e8 34 cc ff ff       	call   8049260 <_ZNSsD1Ev@plt>
 804c62c:	e9 ec f3 ff ff       	jmp    804ba1d <_ZN9HashTableISsSsE6insertESsSs+0x38d>
 804c631:	89 c3                	mov    %eax,%ebx
 804c633:	c5 f8 77             	vzeroupper 
 804c636:	eb ce                	jmp    804c606 <_ZN9HashTableISsSsE6insertESsSs+0xf76>
 804c638:	89 c3                	mov    %eax,%ebx
 804c63a:	c5 f8 77             	vzeroupper 
 804c63d:	eb cf                	jmp    804c60e <_ZN9HashTableISsSsE6insertESsSs+0xf7e>
 804c63f:	89 c3                	mov    %eax,%ebx
 804c641:	c5 f8 77             	vzeroupper 
 804c644:	eb d7                	jmp    804c61d <_ZN9HashTableISsSsE6insertESsSs+0xf8d>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c646:	83 e8 04             	sub    $0x4,%eax
 804c649:	89 54 24 6c          	mov    %edx,0x6c(%esp)
 804c64d:	e8 ab ce ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c652:	8b 54 24 6c          	mov    0x6c(%esp),%edx
 804c656:	85 c0                	test   %eax,%eax
 804c658:	0f 8f a7 f3 ff ff    	jg     804ba05 <_ZN9HashTableISsSsE6insertESsSs+0x375>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c65e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
 804c662:	89 14 24             	mov    %edx,(%esp)
 804c665:	e8 16 cc ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c66a:	e9 96 f3 ff ff       	jmp    804ba05 <_ZN9HashTableISsSsE6insertESsSs+0x375>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c66f:	83 e8 04             	sub    $0x4,%eax
 804c672:	89 54 24 68          	mov    %edx,0x68(%esp)
 804c676:	e8 82 ce ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c67b:	8b 54 24 68          	mov    0x68(%esp),%edx
 804c67f:	85 c0                	test   %eax,%eax
 804c681:	0f 8f 5c f3 ff ff    	jg     804b9e3 <_ZN9HashTableISsSsE6insertESsSs+0x353>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c687:	89 6c 24 04          	mov    %ebp,0x4(%esp)
 804c68b:	89 14 24             	mov    %edx,(%esp)
 804c68e:	e8 ed cb ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c693:	e9 4b f3 ff ff       	jmp    804b9e3 <_ZN9HashTableISsSsE6insertESsSs+0x353>
					e->next = entry;
					if(pre_entry)
						pre_entry->next = e;
					else
						table[num] = e;
 804c698:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804c69f:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
 804c6a3:	8b 00                	mov    (%eax),%eax
 804c6a5:	89 34 88             	mov    %esi,(%eax,%ecx,4)
 804c6a8:	e9 9d fe ff ff       	jmp    804c54a <_ZN9HashTableISsSsE6insertESsSs+0xeba>
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
	}
	K key(){
		return kvpair.first;
 804c6ad:	8b 44 24 44          	mov    0x44(%esp),%eax
 804c6b1:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c6b5:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
 804c6bc:	89 04 24             	mov    %eax,(%esp)
 804c6bf:	e8 2c cb ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804c6c4:	8b 84 24 d4 00 00 00 	mov    0xd4(%esp),%eax
 804c6cb:	8b b4 24 94 00 00 00 	mov    0x94(%esp),%esi
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
 804c6d2:	c6 44 24 3e 00       	movb   $0x0,0x3e(%esp)
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804c6d7:	8b 00                	mov    (%eax),%eax
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }
 804c6d9:	8b 4e f4             	mov    -0xc(%esi),%ecx
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
 804c6dc:	3b 48 f4             	cmp    -0xc(%eax),%ecx
 804c6df:	75 17                	jne    804c6f8 <_ZN9HashTableISsSsE6insertESsSs+0x1068>
 804c6e1:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804c6e5:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c6e9:	89 34 24             	mov    %esi,(%esp)
 804c6ec:	e8 2f ca ff ff       	call   8049120 <memcmp@plt>
 804c6f1:	85 c0                	test   %eax,%eax
 804c6f3:	0f 94 44 24 3e       	sete   0x3e(%esp)

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c6f8:	8d 84 24 ac 00 00 00 	lea    0xac(%esp),%eax
 804c6ff:	e8 ac e0 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
 804c704:	8d 6e f4             	lea    -0xc(%esi),%ebp

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804c707:	39 6c 24 14          	cmp    %ebp,0x14(%esp)
 804c70b:	0f 85 1e 02 00 00    	jne    804c92f <_ZN9HashTableISsSsE6insertESsSs+0x129f>
				if(entry == NULL) {
					pre_entry->next = new HashEntry<K,V>(key, val);
					buckets_size[num]++;
				}
				else if (entry->key() == key)	//the key has already in the table
					return false;
 804c711:	31 f6                	xor    %esi,%esi

				if(entry == NULL) {
					pre_entry->next = new HashEntry<K,V>(key, val);
					buckets_size[num]++;
				}
				else if (entry->key() == key)	//the key has already in the table
 804c713:	80 7c 24 3e 00       	cmpb   $0x0,0x3e(%esp)
 804c718:	0f 85 fc f3 ff ff    	jne    804bb1a <_ZN9HashTableISsSsE6insertESsSs+0x48a>
					return false;
				else {	//entry->key > key
					HashEntry<K,V> * e = new HashEntry<K,V>(key, val);
 804c71e:	8b 84 24 d4 00 00 00 	mov    0xd4(%esp),%eax
 804c725:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c729:	8d 84 24 98 00 00 00 	lea    0x98(%esp),%eax
 804c730:	89 04 24             	mov    %eax,(%esp)
 804c733:	e8 b8 ca ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804c738:	8b 84 24 d8 00 00 00 	mov    0xd8(%esp),%eax
 804c73f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c743:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
 804c74a:	89 04 24             	mov    %eax,(%esp)
 804c74d:	e8 9e ca ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804c752:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
 804c759:	e8 e2 cb ff ff       	call   8049340 <_Znwj@plt>
 804c75e:	89 c6                	mov    %eax,%esi
 804c760:	8d 84 24 98 00 00 00 	lea    0x98(%esp),%eax
 804c767:	89 04 24             	mov    %eax,(%esp)
 804c76a:	e8 11 ef ff ff       	call   804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>
 804c76f:	89 34 24             	mov    %esi,(%esp)
 804c772:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c776:	e8 75 ca ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>
 804c77b:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
 804c782:	89 04 24             	mov    %eax,(%esp)
 804c785:	e8 f6 ee ff ff       	call   804b680 <_ZSt7forwardIRSsEOT_RNSt16remove_referenceIS1_E4typeE>
 804c78a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c78e:	8d 46 04             	lea    0x4(%esi),%eax
 804c791:	89 04 24             	mov    %eax,(%esp)
 804c794:	e8 57 ca ff ff       	call   80491f0 <_ZNSsC1ERKSs@plt>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c799:	8d ac 24 ac 00 00 00 	lea    0xac(%esp),%ebp
 804c7a0:	89 e8                	mov    %ebp,%eax
template <class K, class V>
class HashEntry {
	pair<K,V> kvpair;
public:
	HashEntry* next;
	HashEntry(K k, V v) : kvpair(k, v), next(NULL) {
 804c7a2:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
 804c7a9:	e8 02 e0 ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804c7ae:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c7b5:	8d 50 f4             	lea    -0xc(%eax),%edx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804c7b8:	39 54 24 14          	cmp    %edx,0x14(%esp)
 804c7bc:	0f 85 d8 01 00 00    	jne    804c99a <_ZN9HashTableISsSsE6insertESsSs+0x130a>

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c7c2:	8d ac 24 ac 00 00 00 	lea    0xac(%esp),%ebp
 804c7c9:	89 e8                	mov    %ebp,%eax
 804c7cb:	e8 e0 df ff ff       	call   804a7b0 <_ZNKSs13get_allocatorEv.isra.7>
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const
      { return  _M_dataplus._M_p; }
 804c7d0:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }
 804c7d7:	8d 50 f4             	lea    -0xc(%eax),%edx

	void
	_M_dispose(const _Alloc& __a)
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
 804c7da:	39 54 24 14          	cmp    %edx,0x14(%esp)
 804c7de:	0f 85 8d 01 00 00    	jne    804c971 <_ZN9HashTableISsSsE6insertESsSs+0x12e1>
				else if (entry->key() == key)	//the key has already in the table
					return false;
				else {	//entry->key > key
					HashEntry<K,V> * e = new HashEntry<K,V>(key, val);
					e->next = entry;
					if(pre_entry)
 804c7e4:	85 ff                	test   %edi,%edi
				}
				else if (entry->key() == key)	//the key has already in the table
					return false;
				else {	//entry->key > key
					HashEntry<K,V> * e = new HashEntry<K,V>(key, val);
					e->next = entry;
 804c7e6:	89 5e 08             	mov    %ebx,0x8(%esi)
					if(pre_entry)
 804c7e9:	0f 84 6d 01 00 00    	je     804c95c <_ZN9HashTableISsSsE6insertESsSs+0x12cc>
						pre_entry->next = e;
 804c7ef:	89 77 08             	mov    %esi,0x8(%edi)
 804c7f2:	e9 1f f4 ff ff       	jmp    804bc16 <_ZN9HashTableISsSsE6insertESsSs+0x586>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c7f7:	8d 46 fc             	lea    -0x4(%esi),%eax
 804c7fa:	89 54 24 54          	mov    %edx,0x54(%esp)
 804c7fe:	e8 fa cc ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c803:	8b 54 24 54          	mov    0x54(%esp),%edx
 804c807:	85 c0                	test   %eax,%eax
 804c809:	0f 8f b4 ef ff ff    	jg     804b7c3 <_ZN9HashTableISsSsE6insertESsSs+0x133>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c80f:	8d 84 24 a8 00 00 00 	lea    0xa8(%esp),%eax
 804c816:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c81a:	89 14 24             	mov    %edx,(%esp)
 804c81d:	e8 5e ca ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c822:	e9 9c ef ff ff       	jmp    804b7c3 <_ZN9HashTableISsSsE6insertESsSs+0x133>
 804c827:	89 c6                	mov    %eax,%esi
 804c829:	89 1c 24             	mov    %ebx,(%esp)
 804c82c:	c5 f8 77             	vzeroupper 
 804c82f:	e8 2c ca ff ff       	call   8049260 <_ZNSsD1Ev@plt>
	bool insert(K key, V val) {
		int num = hash(key);

		__transaction_relaxed {
			if(table[num] == NULL){
				table[num] = new HashEntry<K,V>(key, val);
 804c834:	89 1c 24             	mov    %ebx,(%esp)
 804c837:	89 f3                	mov    %esi,%ebx
 804c839:	e8 32 c9 ff ff       	call   8049170 <_ZdlPv@plt>
 804c83e:	e9 64 fd ff ff       	jmp    804c5a7 <_ZN9HashTableISsSsE6insertESsSs+0xf17>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c843:	83 e8 04             	sub    $0x4,%eax
 804c846:	e8 b2 cc ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c84b:	85 c0                	test   %eax,%eax
 804c84d:	8d 76 00             	lea    0x0(%esi),%esi
 804c850:	0f 8f f4 fc ff ff    	jg     804c54a <_ZN9HashTableISsSsE6insertESsSs+0xeba>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c856:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804c85a:	89 34 24             	mov    %esi,(%esp)
 804c85d:	e8 1e ca ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c862:	e9 e3 fc ff ff       	jmp    804c54a <_ZN9HashTableISsSsE6insertESsSs+0xeba>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c867:	83 e8 04             	sub    $0x4,%eax
 804c86a:	e8 8e cc ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c86f:	85 c0                	test   %eax,%eax
 804c871:	0f 8f b1 fc ff ff    	jg     804c528 <_ZN9HashTableISsSsE6insertESsSs+0xe98>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c877:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804c87b:	89 34 24             	mov    %esi,(%esp)
 804c87e:	e8 fd c9 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c883:	e9 a0 fc ff ff       	jmp    804c528 <_ZN9HashTableISsSsE6insertESsSs+0xe98>
 804c888:	e9 b1 fa ff ff       	jmp    804c33e <_ZN9HashTableISsSsE6insertESsSs+0xcae>
 804c88d:	8d 76 00             	lea    0x0(%esi),%esi
 804c890:	e9 e6 fa ff ff       	jmp    804c37b <_ZN9HashTableISsSsE6insertESsSs+0xceb>
 804c895:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804c899:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 804c8a0:	e9 dd fa ff ff       	jmp    804c382 <_ZN9HashTableISsSsE6insertESsSs+0xcf2>
 804c8a5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804c8a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 804c8b0:	e9 d4 fa ff ff       	jmp    804c389 <_ZN9HashTableISsSsE6insertESsSs+0xcf9>
 804c8b5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804c8b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 804c8c0:	e9 62 ff ff ff       	jmp    804c827 <_ZN9HashTableISsSsE6insertESsSs+0x1197>
 804c8c5:	89 c6                	mov    %eax,%esi
 804c8c7:	c5 f8 77             	vzeroupper 
 804c8ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804c8d0:	e9 5f ff ff ff       	jmp    804c834 <_ZN9HashTableISsSsE6insertESsSs+0x11a4>
 804c8d5:	e9 c8 fc ff ff       	jmp    804c5a2 <_ZN9HashTableISsSsE6insertESsSs+0xf12>
 804c8da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804c8e0:	e9 e5 fc ff ff       	jmp    804c5ca <_ZN9HashTableISsSsE6insertESsSs+0xf3a>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c8e5:	83 e8 04             	sub    $0x4,%eax
 804c8e8:	90                   	nop
 804c8e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804c8f0:	e8 08 cc ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c8f5:	85 c0                	test   %eax,%eax
 804c8f7:	0f 8f 07 f2 ff ff    	jg     804bb04 <_ZN9HashTableISsSsE6insertESsSs+0x474>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c8fd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804c901:	89 34 24             	mov    %esi,(%esp)
 804c904:	e8 77 c9 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c909:	e9 f6 f1 ff ff       	jmp    804bb04 <_ZN9HashTableISsSsE6insertESsSs+0x474>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c90e:	83 e8 04             	sub    $0x4,%eax
 804c911:	e8 e7 cb ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c916:	85 c0                	test   %eax,%eax
 804c918:	0f 8f c4 f1 ff ff    	jg     804bae2 <_ZN9HashTableISsSsE6insertESsSs+0x452>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c91e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804c922:	89 34 24             	mov    %esi,(%esp)
 804c925:	e8 56 c9 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c92a:	e9 b3 f1 ff ff       	jmp    804bae2 <_ZN9HashTableISsSsE6insertESsSs+0x452>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c92f:	8d 46 fc             	lea    -0x4(%esi),%eax
 804c932:	e8 c6 cb ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c937:	85 c0                	test   %eax,%eax
 804c939:	0f 8f d2 fd ff ff    	jg     804c711 <_ZN9HashTableISsSsE6insertESsSs+0x1081>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c93f:	8d 84 24 ac 00 00 00 	lea    0xac(%esp),%eax
 804c946:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c94a:	89 2c 24             	mov    %ebp,(%esp)
 804c94d:	e8 2e c9 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c952:	e9 ba fd ff ff       	jmp    804c711 <_ZN9HashTableISsSsE6insertESsSs+0x1081>
 804c957:	e9 69 ff ff ff       	jmp    804c8c5 <_ZN9HashTableISsSsE6insertESsSs+0x1235>
					HashEntry<K,V> * e = new HashEntry<K,V>(key, val);
					e->next = entry;
					if(pre_entry)
						pre_entry->next = e;
					else
						table[num] = e;
 804c95c:	8b 84 24 d0 00 00 00 	mov    0xd0(%esp),%eax
 804c963:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
 804c967:	8b 00                	mov    (%eax),%eax
 804c969:	89 34 88             	mov    %esi,(%eax,%ecx,4)
 804c96c:	e9 a5 f2 ff ff       	jmp    804bc16 <_ZN9HashTableISsSsE6insertESsSs+0x586>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c971:	83 e8 04             	sub    $0x4,%eax
 804c974:	89 54 24 5c          	mov    %edx,0x5c(%esp)
 804c978:	e8 80 cb ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c97d:	8b 54 24 5c          	mov    0x5c(%esp),%edx
 804c981:	85 c0                	test   %eax,%eax
 804c983:	0f 8f 5b fe ff ff    	jg     804c7e4 <_ZN9HashTableISsSsE6insertESsSs+0x1154>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c989:	89 6c 24 04          	mov    %ebp,0x4(%esp)
 804c98d:	89 14 24             	mov    %edx,(%esp)
 804c990:	e8 eb c8 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c995:	e9 4a fe ff ff       	jmp    804c7e4 <_ZN9HashTableISsSsE6insertESsSs+0x1154>
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
 804c99a:	83 e8 04             	sub    $0x4,%eax
 804c99d:	89 54 24 58          	mov    %edx,0x58(%esp)
 804c9a1:	e8 57 cb ff ff       	call   80494fd <_ZN9__gnu_cxxL27__exchange_and_add_dispatchEPii.constprop.12>
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
 804c9a6:	8b 54 24 58          	mov    0x58(%esp),%edx
 804c9aa:	85 c0                	test   %eax,%eax
 804c9ac:	0f 8f 10 fe ff ff    	jg     804c7c2 <_ZN9HashTableISsSsE6insertESsSs+0x1132>
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
 804c9b2:	89 6c 24 04          	mov    %ebp,0x4(%esp)
 804c9b6:	89 14 24             	mov    %edx,(%esp)
 804c9b9:	e8 c2 c8 ff ff       	call   8049280 <_ZNSs4_Rep10_M_destroyERKSaIcE@plt>
 804c9be:	e9 ff fd ff ff       	jmp    804c7c2 <_ZN9HashTableISsSsE6insertESsSs+0x1132>
 804c9c3:	e9 31 fc ff ff       	jmp    804c5f9 <_ZN9HashTableISsSsE6insertESsSs+0xf69>
 804c9c8:	90                   	nop
 804c9c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804c9d0:	e9 5c fc ff ff       	jmp    804c631 <_ZN9HashTableISsSsE6insertESsSs+0xfa1>
 804c9d5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804c9d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 804c9e0:	e9 53 fc ff ff       	jmp    804c638 <_ZN9HashTableISsSsE6insertESsSs+0xfa8>
 804c9e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804c9e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 804c9f0:	e9 4a fc ff ff       	jmp    804c63f <_ZN9HashTableISsSsE6insertESsSs+0xfaf>
 804c9f5:	66 90                	xchg   %ax,%ax
 804c9f7:	66 90                	xchg   %ax,%ax
 804c9f9:	66 90                	xchg   %ax,%ax
 804c9fb:	66 90                	xchg   %ax,%ax
 804c9fd:	66 90                	xchg   %ax,%ax
 804c9ff:	90                   	nop

0804ca00 <_ZGTtN9HashTableISsSsEC1Eii>:
	int TableSize;
	int BucketCapacity;
	
	int * buckets_size;

	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
 804ca00:	55                   	push   %ebp
 804ca01:	57                   	push   %edi
 804ca02:	56                   	push   %esi
 804ca03:	53                   	push   %ebx
 804ca04:	83 ec 2c             	sub    $0x2c,%esp
 804ca07:	8b 74 24 40          	mov    0x40(%esp),%esi
 804ca0b:	8b 5c 24 44          	mov    0x44(%esp),%ebx
 804ca0f:	8b 6c 24 48          	mov    0x48(%esp),%ebp
 804ca13:	8d 7e 04             	lea    0x4(%esi),%edi
 804ca16:	89 da                	mov    %ebx,%edx
 804ca18:	89 f8                	mov    %edi,%eax
 804ca1a:	e8 b1 c8 ff ff       	call   80492d0 <_ITM_WU4@plt>
 804ca1f:	8d 46 08             	lea    0x8(%esi),%eax
 804ca22:	89 ea                	mov    %ebp,%edx
 804ca24:	e8 a7 c8 ff ff       	call   80492d0 <_ITM_WU4@plt>
		assert(BucketCapacity > 0);
 804ca29:	85 ed                	test   %ebp,%ebp
 804ca2b:	0f 8e a6 00 00 00    	jle    804cad7 <_ZGTtN9HashTableISsSsEC1Eii+0xd7>
		assert(TableSize > 0);
 804ca31:	85 db                	test   %ebx,%ebx
 804ca33:	0f 8e d5 00 00 00    	jle    804cb0e <_ZGTtN9HashTableISsSsEC1Eii+0x10e>

		table = new HashEntry<K,V>*[TableSize];
 804ca39:	81 fb 00 00 c0 1f    	cmp    $0x1fc00000,%ebx
 804ca3f:	0f 8f bd 00 00 00    	jg     804cb02 <_ZGTtN9HashTableISsSsEC1Eii+0x102>
 804ca45:	c1 e3 02             	shl    $0x2,%ebx
 804ca48:	89 1c 24             	mov    %ebx,(%esp)
 804ca4b:	e8 40 c8 ff ff       	call   8049290 <_ZGTtnaj@plt>
 804ca50:	89 c2                	mov    %eax,%edx
 804ca52:	89 f0                	mov    %esi,%eax
 804ca54:	e8 77 c8 ff ff       	call   80492d0 <_ITM_WU4@plt>
		buckets_size = new int[TableSize];
 804ca59:	89 f8                	mov    %edi,%eax
 804ca5b:	e8 80 c9 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804ca60:	3d 00 00 c0 1f       	cmp    $0x1fc00000,%eax
 804ca65:	0f 87 97 00 00 00    	ja     804cb02 <_ZGTtN9HashTableISsSsEC1Eii+0x102>
 804ca6b:	c1 e0 02             	shl    $0x2,%eax

		for(int i = 0 ; i < TableSize ; i ++ ){
 804ca6e:	31 db                	xor    %ebx,%ebx
	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];
 804ca70:	89 04 24             	mov    %eax,(%esp)
 804ca73:	e8 18 c8 ff ff       	call   8049290 <_ZGTtnaj@plt>
 804ca78:	8d 4e 0c             	lea    0xc(%esi),%ecx
 804ca7b:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 804ca7f:	89 c2                	mov    %eax,%edx
 804ca81:	89 c8                	mov    %ecx,%eax
 804ca83:	e8 48 c8 ff ff       	call   80492d0 <_ITM_WU4@plt>

		for(int i = 0 ; i < TableSize ; i ++ ){
 804ca88:	89 f8                	mov    %edi,%eax
 804ca8a:	e8 51 c9 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804ca8f:	85 c0                	test   %eax,%eax
 804ca91:	7e 3c                	jle    804cacf <_ZGTtN9HashTableISsSsEC1Eii+0xcf>
 804ca93:	90                   	nop
 804ca94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			table[i] = NULL;
 804ca98:	89 f0                	mov    %esi,%eax
 804ca9a:	e8 41 c9 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804ca9f:	8d 2c 9d 00 00 00 00 	lea    0x0(,%ebx,4),%ebp
 804caa6:	31 d2                	xor    %edx,%edx
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];

		for(int i = 0 ; i < TableSize ; i ++ ){
 804caa8:	83 c3 01             	add    $0x1,%ebx
			table[i] = NULL;
 804caab:	01 e8                	add    %ebp,%eax
 804caad:	e8 1e c8 ff ff       	call   80492d0 <_ITM_WU4@plt>
			buckets_size[i] = 0;
 804cab2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804cab6:	e8 25 c9 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804cabb:	31 d2                	xor    %edx,%edx
 804cabd:	01 e8                	add    %ebp,%eax
 804cabf:	e8 0c c8 ff ff       	call   80492d0 <_ITM_WU4@plt>
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
		buckets_size = new int[TableSize];

		for(int i = 0 ; i < TableSize ; i ++ ){
 804cac4:	89 f8                	mov    %edi,%eax
 804cac6:	e8 15 c9 ff ff       	call   80493e0 <_ITM_RU4@plt>
 804cacb:	39 c3                	cmp    %eax,%ebx
 804cacd:	7c c9                	jl     804ca98 <_ZGTtN9HashTableISsSsEC1Eii+0x98>
			table[i] = NULL;
			buckets_size[i] = 0;
		}
	}
 804cacf:	83 c4 2c             	add    $0x2c,%esp
 804cad2:	5b                   	pop    %ebx
 804cad3:	5e                   	pop    %esi
 804cad4:	5f                   	pop    %edi
 804cad5:	5d                   	pop    %ebp
 804cad6:	c3                   	ret    
 804cad7:	31 c0                	xor    %eax,%eax
 804cad9:	e8 e2 c8 ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
	int BucketCapacity;
	
	int * buckets_size;

	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
 804cade:	c7 44 24 0c c0 cf 04 	movl   $0x804cfc0,0xc(%esp)
 804cae5:	08 
 804cae6:	c7 44 24 08 49 00 00 	movl   $0x49,0x8(%esp)
 804caed:	00 
 804caee:	c7 44 24 04 7c cf 04 	movl   $0x804cf7c,0x4(%esp)
 804caf5:	08 
 804caf6:	c7 04 24 a1 cf 04 08 	movl   $0x804cfa1,(%esp)
 804cafd:	e8 0e c7 ff ff       	call   8049210 <__assert_fail@plt>
 804cb02:	31 c0                	xor    %eax,%eax
 804cb04:	e8 b7 c8 ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
		assert(TableSize > 0);

		table = new HashEntry<K,V>*[TableSize];
 804cb09:	e8 a2 c6 ff ff       	call   80491b0 <__cxa_throw_bad_array_new_length@plt>
 804cb0e:	31 c0                	xor    %eax,%eax
 804cb10:	e8 ab c8 ff ff       	call   80493c0 <_ITM_changeTransactionMode@plt>
	
	int * buckets_size;

	HashTable(int _size = 1024, int _bucketCap = 8) : TableSize(_size), BucketCapacity(_bucketCap) {
		assert(BucketCapacity > 0);
		assert(TableSize > 0);
 804cb15:	c7 44 24 0c c0 cf 04 	movl   $0x804cfc0,0xc(%esp)
 804cb1c:	08 
 804cb1d:	c7 44 24 08 4a 00 00 	movl   $0x4a,0x8(%esp)
 804cb24:	00 
 804cb25:	c7 44 24 04 7c cf 04 	movl   $0x804cf7c,0x4(%esp)
 804cb2c:	08 
 804cb2d:	c7 04 24 93 cf 04 08 	movl   $0x804cf93,(%esp)
 804cb34:	e8 d7 c6 ff ff       	call   8049210 <__assert_fail@plt>
 804cb39:	66 90                	xchg   %ax,%ax
 804cb3b:	66 90                	xchg   %ax,%ax
 804cb3d:	66 90                	xchg   %ax,%ax
 804cb3f:	90                   	nop

0804cb40 <__libc_csu_init>:
 804cb40:	55                   	push   %ebp
 804cb41:	57                   	push   %edi
 804cb42:	31 ff                	xor    %edi,%edi
 804cb44:	56                   	push   %esi
 804cb45:	53                   	push   %ebx
 804cb46:	e8 25 d0 ff ff       	call   8049b70 <__x86.get_pc_thunk.bx>
 804cb4b:	81 c3 e5 15 00 00    	add    $0x15e5,%ebx
 804cb51:	83 ec 1c             	sub    $0x1c,%esp
 804cb54:	8b 6c 24 30          	mov    0x30(%esp),%ebp
 804cb58:	8d b3 dc fe ff ff    	lea    -0x124(%ebx),%esi
 804cb5e:	e8 65 c5 ff ff       	call   80490c8 <_init>
 804cb63:	8d 83 d0 fe ff ff    	lea    -0x130(%ebx),%eax
 804cb69:	29 c6                	sub    %eax,%esi
 804cb6b:	c1 fe 02             	sar    $0x2,%esi
 804cb6e:	85 f6                	test   %esi,%esi
 804cb70:	74 27                	je     804cb99 <__libc_csu_init+0x59>
 804cb72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804cb78:	8b 44 24 38          	mov    0x38(%esp),%eax
 804cb7c:	89 2c 24             	mov    %ebp,(%esp)
 804cb7f:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cb83:	8b 44 24 34          	mov    0x34(%esp),%eax
 804cb87:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cb8b:	ff 94 bb d0 fe ff ff 	call   *-0x130(%ebx,%edi,4)
 804cb92:	83 c7 01             	add    $0x1,%edi
 804cb95:	39 f7                	cmp    %esi,%edi
 804cb97:	75 df                	jne    804cb78 <__libc_csu_init+0x38>
 804cb99:	83 c4 1c             	add    $0x1c,%esp
 804cb9c:	5b                   	pop    %ebx
 804cb9d:	5e                   	pop    %esi
 804cb9e:	5f                   	pop    %edi
 804cb9f:	5d                   	pop    %ebp
 804cba0:	c3                   	ret    
 804cba1:	eb 0d                	jmp    804cbb0 <__libc_csu_fini>
 804cba3:	90                   	nop
 804cba4:	90                   	nop
 804cba5:	90                   	nop
 804cba6:	90                   	nop
 804cba7:	90                   	nop
 804cba8:	90                   	nop
 804cba9:	90                   	nop
 804cbaa:	90                   	nop
 804cbab:	90                   	nop
 804cbac:	90                   	nop
 804cbad:	90                   	nop
 804cbae:	90                   	nop
 804cbaf:	90                   	nop

0804cbb0 <__libc_csu_fini>:
 804cbb0:	f3 c3                	repz ret 
 804cbb2:	66 90                	xchg   %ax,%ax

Disassembly of section .fini:

0804cbb4 <_fini>:
 804cbb4:	53                   	push   %ebx
 804cbb5:	83 ec 08             	sub    $0x8,%esp
 804cbb8:	e8 b3 cf ff ff       	call   8049b70 <__x86.get_pc_thunk.bx>
 804cbbd:	81 c3 73 15 00 00    	add    $0x1573,%ebx
 804cbc3:	83 c4 08             	add    $0x8,%esp
 804cbc6:	5b                   	pop    %ebx
 804cbc7:	c3                   	ret    
